{"version":3,"sources":["Front End/patmos-mode.js","Front End/Editor.js","Front End/Simulator/DisplayButtons.js","Helpers/misc.js","Front End/Simulator/DisplayStorage.js","Front End/Simulator/DisplayCode.js","Front End/Simulator/Simulator.js","Front End/FrontEnd.js","Work Logic/Processor/ProcessorState.js","Helpers/typeStrings.js","Helpers/regStrings.js","Work Logic/Processor/CPU.js","Work Logic/Instructions/Binary Arithmetics/BinaryArithmetics.js","Work Logic/Instructions/Binary Arithmetics/compilers.js","Work Logic/Instructions/Binary Arithmetics/Add.js","Work Logic/Instructions/Binary Arithmetics/Nor.js","Work Logic/Instructions/Binary Arithmetics/ShiftAdd.js","Work Logic/Instructions/Binary Arithmetics/ShiftAdd2.js","Work Logic/Instructions/Binary Arithmetics/ShiftLeft.js","Work Logic/Instructions/Binary Arithmetics/ShiftRight.js","Work Logic/Instructions/Binary Arithmetics/ShiftRightArithmetic.js","Work Logic/Instructions/Binary Arithmetics/Sub.js","Work Logic/Instructions/Binary Arithmetics/Xor.js","Work Logic/Instructions/Binary Arithmetics/Or.js","Work Logic/Instructions/Binary Arithmetics/And.js","Work Logic/Instructions/Compare/Compare.js","Work Logic/Instructions/Compare/compilers.js","Work Logic/Instructions/Compare/Btest.js","Work Logic/Instructions/Compare/Cmpeq.js","Work Logic/Instructions/Compare/Cmple.js","Work Logic/Instructions/Compare/Cmplt.js","Work Logic/Instructions/Compare/Cmpneq.js","Work Logic/Instructions/Compare/Cmpule.js","Work Logic/Instructions/Compare/Cmpult.js","Work Logic/Instructions/Control Flow/ControlFlow.js","Work Logic/Instructions/Control Flow/compilers.js","Work Logic/Instructions/Control Flow/Br.js","Work Logic/Instructions/Control Flow/Brcf.js","Work Logic/Instructions/Control Flow/Brcfnd.js","Work Logic/Instructions/Control Flow/Brnd.js","Work Logic/Instructions/Control Flow/Call.js","Work Logic/Instructions/Control Flow/Callnd.js","Work Logic/Instructions/Control Flow/Ret.js","Work Logic/Instructions/Control Flow/Retnd.js","Work Logic/Instructions/Control Flow/Trap.js","Work Logic/Instructions/Control Flow/Xret.js","Work Logic/Instructions/Control Flow/Xretnd.js","Work Logic/Instructions/Load Typed/LoadTyped.js","Work Logic/Instructions/Load Typed/compilers.js","Work Logic/Instructions/Load Typed/Lws.js","Work Logic/Instructions/Load Typed/Lwl.js","Work Logic/Instructions/Load Typed/Lwc.js","Work Logic/Instructions/Load Typed/Lwm.js","Work Logic/Instructions/Load Typed/Lhs.js","Work Logic/Instructions/Load Typed/Lhl.js","Work Logic/Instructions/Load Typed/Lhc.js","Work Logic/Instructions/Load Typed/Lhm.js","Work Logic/Instructions/Load Typed/Lbs.js","Work Logic/Instructions/Load Typed/Lbl.js","Work Logic/Instructions/Load Typed/Lbc.js","Work Logic/Instructions/Load Typed/Lbm.js","Work Logic/Instructions/Load Typed/Lhus.js","Work Logic/Instructions/Load Typed/Lhul.js","Work Logic/Instructions/Load Typed/Lhuc.js","Work Logic/Instructions/Load Typed/Lhum.js","Work Logic/Instructions/Load Typed/Lbus.js","Work Logic/Instructions/Load Typed/Lbul.js","Work Logic/Instructions/Load Typed/Lbuc.js","Work Logic/Instructions/Load Typed/Lbum.js","Work Logic/Instructions/Multiply/Multiply.js","Work Logic/Instructions/Multiply/compilers.js","Work Logic/Instructions/Multiply/Mul.js","Work Logic/Instructions/Multiply/Mulu.js","Work Logic/Instructions/Predicate/Predicate.js","Work Logic/Instructions/Predicate/compilers.js","Work Logic/Instructions/Predicate/Pand.js","Work Logic/Instructions/Predicate/Pxor.js","Work Logic/Instructions/Predicate/Por.js","Work Logic/Instructions/Stack Control/StackControl.js","Work Logic/Instructions/Stack Control/compilers.js","Work Logic/Instructions/Stack Control/Sens.js","Work Logic/Instructions/Stack Control/Sfree.js","Work Logic/Instructions/Stack Control/Sres.js","Work Logic/Instructions/Stack Control/Sspill.js","Work Logic/Instructions/Store Typed/StoreTyped.js","Work Logic/Instructions/Store Typed/compilers.js","Work Logic/Instructions/Store Typed/Sbc.js","Work Logic/Instructions/Store Typed/Sbl.js","Work Logic/Instructions/Store Typed/Sbm.js","Work Logic/Instructions/Store Typed/Sbs.js","Work Logic/Instructions/Store Typed/Shc.js","Work Logic/Instructions/Store Typed/Shl.js","Work Logic/Instructions/Store Typed/Shm.js","Work Logic/Instructions/Store Typed/Shs.js","Work Logic/Instructions/Store Typed/Swc.js","Work Logic/Instructions/Store Typed/Swl.js","Work Logic/Instructions/Store Typed/Swm.js","Work Logic/Instructions/Store Typed/Sws.js","Work Logic/Instructions/Bcopy.js","Work Logic/Instructions/Mfs.js","Work Logic/Instructions/Mts.js","Helpers/regEx.js","Work Logic/Processor/Assembler.js","App.js","index.js"],"names":["CodeMirror","defineMode","config","parserConfig","getRegex","w","i","RegExp","join","instTypes","registers","keywords","normal","stream","state","ch","next","skipToEnd","test","eatWhile","startState","basecol","indentDepth","cur","token","eatSpace","style","word","current","Editor","props","code","readOnly","mode","lint","updateCode","bind","newCode","this","setState","editorUpdate","options","lineNumbers","value","onChange","autoFocus","Component","buttonCSS","forwardBtn","bundles","pc","runClick","stepClick","tooltipRun","tooltipStep","title","type","className","onClick","disabled","backwardsBtn","history","prevClick","resetClick","tooltipPrev","tooltipReset","length","DisplayButtons","dumpClick","parseNum","input","Number","parseReg","match","toUint32","n","intToHex","integer","toString","toUpperCase","padStart","intToHexStr","tableCSS","DisplayStorage","pagenumber","pageRows","maxPage","hex","incPage","decPage","jumpPage","updateDimensions","toggleHex","Math","floor","window","innerHeight","ceil","addEventListener","removeEventListener","prevState","des","parseInt","prompt","href","data-toggle","role","id","RenderRegTable","RenderMemoryTable","memory","rows","push","RegRow","key","scope","gm_temp","startAddr","endAddr","Object","assign","undefined","zeroRow","MemoryRowHex","MemoryRowDec","emptyRow","row","letter","idx","val","GenMachineRows","o","MachineRow","bundle","addr","color","instruction","binary","original","DisplayCode","Simulator","FrontEnd","click","toggle","errMes","error","numMap","alert","ProcessorState","reg","mem","cpu","r","m","c","prev","pop","pseudoTypes","binTypes","compTypes","loadTypes","storeTypes","mulTypes","stackTypes","predTypes","cfTypes","concat","pseudoMapping","getInstType","keys","instTypeStr","bin","includes","comp","load","store","mul","stack","pred","cf","regStr","allRegStr","sregMap","sl","sh","ss","st","srb","sro","sxb","sxo","CPU","pending_branch","reset","updateHistory","dualIssue","execute","handlePendingBranch","conflicts","ops","op","conflict","delay","inst","name","rewindOnce","start","end","performance","now","step","console","log","base_set","offset","is_data","data","base","instructions","setMem","size","int","setReadReg","getReg","getMemory","r0","p0","s0","BinaryArithmetics","func","rd","rs1","op2","isNaN","rs2","compile_reg","imm","compile_imm","long","compile_long","Error","Add","Nor","ShiftAdd","ShiftAdd2","ShiftLeft","ShiftRight","ShiftRightArithmetic","Sub","Xor","Or","And","Compare","pd","Btest","Cmpeq","Cmple","Cmplt","Cmpneq","Cmpule","Cmpult","ControlFLow","d","s1","s2","compile_ireg","compile_reg2","Br","ControlFlow","Brcf","Brcfnd","Brnd","Call","s7","s8","Callnd","Ret","Retnd","Trap","s9","s10","Xret","Xretnd","LoadTyped","ra","Lws","address","hh","hl","lh","ll","Lwl","Lwc","Lwm","Lhs","hi","lo","Lhl","Lhc","Lhm","Lbs","Lbl","Lbc","Lbm","Lhus","Lhul","Lhuc","Lhum","Lbus","Lbul","Lbuc","Lbum","Multiply","Mul","imul","Mulu","Predicate","ps1","ps2","neg1","neg2","replace","Pand","Pxor","Por","StackControl","rs","Sens","max","Sfree","Sres","Sspill","StoreTyped","Sbc","Sbl","Sbm","Sbs","Shc","Shl","Shm","Shs","Swc","Swl","Swm","Sws","Bcopy","ps","shift","Mfs","Mts","sd","regEx","getRegEx","getRegExError","Assembler","cleanInput","editor","lines","split","output","line","trim","insts","j","only_label","labels","parse","resolveOperands","compileBundle","checkErr","is_word","label","neg","toLowerCase","ptype","basic","_","p","slice","is_long_imm","allowedPipelineTwo","multi","t1","t2","op_lc","target","String","cInst","predicate","BinaryInst","CompareInst","ControlInst","LoadInst","MulInst","PredInst","StackInst","StoreInst","BcopyInst","App","clear","a","run","populate","forceUpdate","stepBtn","runBtn","resetBtn","prevBtn","dumpBtn","getMem","dump","Uint8Array","file","Blob","document","createElement","url","URL","createObjectURL","download","body","appendChild","setTimeout","removeChild","revokeObjectURL","overflowY","getPC","ReactDOM","render","getElementById"],"mappings":"0SAGKA,EAIOC,WAAW,UAAU,SAACC,EAAQC,GACxC,IAAIC,EAAW,SAACC,EAAGC,GAClB,OAAO,IAAIC,OAAO,OAASF,EAAEG,KAAK,KAAO,KAAMF,IAG5CG,EAAYL,EAAS,CAGxB,MAAO,OAAQ,OAAQ,MAAO,OAAQ,OAAQ,MAAO,OAAQ,OAAQ,KAAM,MAAO,MAClF,KAAM,MAAO,MAAO,MAAO,OAAQ,OAAQ,MAAO,OAAQ,QAAS,SAAU,KAAM,MAAO,MAC1F,MAAO,OAAQ,OAEf,QAAS,SAAU,QAAS,SAAU,QAAS,SAAU,QAAS,SAClE,SAAU,UAAW,SAAU,UAAW,SAAU,UAEpD,MAAO,MAAO,MAAO,MAAO,OAAQ,OAAQ,OAAQ,OAAQ,MAAO,MACnE,MAAO,MAAO,OAAQ,OAAQ,OAAQ,OAAQ,MAAO,MAAO,MAAO,MAEnE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAE7E,MAAO,OAEP,OAAQ,QAAS,OAAQ,SAAW,UAAW,QAE/C,OAAQ,MAAO,OAEf,MAAO,MAEP,SAAU,OAAQ,OAAQ,KAAM,SAAU,OAAQ,OAClD,QAAS,MAAO,SAAU,OAAQ,UAAW,QAC7C,QAAS,MAAO,QAAS,UAEzB,QAGA,MAAO,MAAO,MAAO,MAAO,KAAM,MAAO,QAAS,OAAQ,OAAQ,OAAQ,QACxE,KAECM,EAAYN,EAAS,CAExB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC5D,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAC/D,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAEtE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAE1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACtD,MAAO,MAAO,MAAO,MAAO,MAAO,MAEnC,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,MAAO,OAC3C,IAECO,EAAWP,EAAS,CAAC,SAAU,KAE/BQ,EAAS,SAACC,EAAQC,GACrB,IAAIC,EAAKF,EAAOG,OAGhB,MAAW,MAAPD,GACHF,EAAOI,YACA,WAIJ,KAAKC,KAAKH,IACbF,EAAOM,SAAS,UACT,UAIJ,SAASD,KAAKH,IACjBF,EAAOM,SAAS,cACT,YAGD,MAGR,MAAO,CACNC,WAAY,SAACC,GACZ,MAAO,CAAEA,QAASA,GAAW,EAAGC,YAAa,EAAGC,IAAKX,IAGtDY,MAAO,SAACX,EAAQC,GACf,GAAID,EAAOY,WAAY,OAAO,KAC9B,IAAIC,EAAQZ,EAAMS,IAAIV,EAAQC,GAC1Ba,EAAOd,EAAOe,UAQlB,MALc,aAAVF,IACCf,EAASO,KAAKS,GAAOD,EAAQ,UACxBjB,EAAUS,KAAKS,GAAOD,EAAQ,UAC9BhB,EAAUQ,KAAKS,KAAOD,EAAQ,eAEjCA,O,IC9FLG,E,YACL,WAAYC,GAAQ,IAAD,8BAClB,4CAAMA,KACDhB,MAAQ,CACZiB,KAAM,GACNC,UAAU,EACVC,KAAM,SACNC,MAAM,GAGP,EAAKC,WAAa,EAAKA,WAAWC,KAAhB,gBATA,E,wEAYPC,GACXC,KAAKC,SAAS,CACbR,KAAMM,IAEPC,KAAKR,MAAMU,aAAaH,K,+BAIxB,IAAII,EAAU,CACbR,KAAMK,KAAKxB,MAAMmB,KACjBS,aAAa,GAEd,OACC,6BAAK,kBAAC,IAAD,CAAYC,MAAOL,KAAKxB,MAAMiB,KAAMa,SAAUN,KAAKH,WAAYM,QAASA,EAASI,WAAW,S,GA1B/EC,aAmCNjB,ICtCTkB,G,MAAY,CACjB,uBACA,wBACA,wBACA,yBACA,0BA8BKC,EAAa,SAACC,EAASC,EAAIC,EAAUC,GAC1C,IAAIC,EAAa,0CACbC,EAAc,iCAElB,OAAKL,EAAQC,GAWZ,kBAAC,WAAD,KACC,4BAAQK,MAAOF,EAAYG,KAAK,SAASC,UAAWV,EAAU,GAAIW,QAASP,GAA3E,OACA,4BAAQI,MAAOD,EAAaE,KAAK,SAASC,UAAWV,EAAU,GAAIW,QAASN,GAA5E,UAZDC,EAAa,yBACbC,EAAc,0BAEb,kBAAC,WAAD,KACC,4BAAQC,MAAOF,EAAYG,KAAK,SAASC,UAAWV,EAAU,GAAIY,UAAQ,GAA1E,OACA,4BAAQJ,MAAOD,EAAaE,KAAK,SAASC,UAAWV,EAAU,GAAIY,UAAQ,GAA3E,WAmBEC,EAAe,SAACC,EAASC,EAAWC,GACzC,IAAIC,EAAc,uDACdC,EAAe,yDAEnB,OAAuB,IAAnBJ,EAAQK,QACXD,EAAe,0BACfD,EAAc,0BAEb,kBAAC,WAAD,KACC,4BAAQT,MAAOS,EAAaR,KAAK,SAASC,UAAWV,EAAU,GAAIY,UAAQ,GAA3E,QACA,4BAAQJ,MAAOU,EAAcT,KAAK,SAASC,UAAWV,EAAU,GAAIY,UAAQ,GAA5E,WAKF,kBAAC,WAAD,KACC,4BAAQJ,MAAOS,EAAaR,KAAK,SAASC,UAAWV,EAAU,GAAIW,QAASI,GAA5E,QACA,4BAAQP,MAAOU,EAAcT,KAAK,SAASC,UAAWV,EAAU,GAAIW,QAASK,GAA7E,WAiBYI,EAjFQ,SAACrC,GACvB,OACC,yBAAK2B,UAAU,oBACbT,EAAWlB,EAAMmB,QAASnB,EAAMoB,GAAIpB,EAAMqB,SAAUrB,EAAMsB,WAC1DQ,EAAa9B,EAAM+B,QAAS/B,EAAMgC,UAAWhC,EAAMiC,YACpD,4BAAQP,KAAM,SAASC,UAAWV,EAAU,GAAIW,QAAW5B,EAAMsC,WAAjE,UC1BUC,EAAW,SAACC,GAAD,MAA2B,iBAATA,EAAoBA,EAAQC,OAAOD,IAChEE,EAAW,SAACF,GAAD,MAA2B,iBAATA,EAAoBA,EAAQC,OAAOD,EAAMG,MAAM,QAAQ,KACpFC,EAAW,SAACC,GAAD,OAAOA,IAAM,GAExBC,EAAW,SAACC,EAASX,GAMjC,OALAW,EAAUN,OAAOM,IAEH,IACbA,EAAU,WAAaA,EAAU,GAE3BA,EAAQC,SAAS,IAAIC,cAAcC,SAASd,EAAQ,MAE/Ce,EAAc,SAACJ,EAASX,GACpC,MAAM,KAAN,OAAYU,EAASC,EAASX,KCNzBgB,G,WAAW,qCAGXC,E,YACL,WAAYrD,GAAQ,IAAD,8BAClB,4CAAMA,KACDhB,MAAQ,CACZsE,WAAa,EACbC,SAAY,EACZC,QAAW,EACXC,KAAQ,GAGT,EAAKC,QAAU,EAAKA,QAAQpD,KAAb,gBACf,EAAKqD,QAAU,EAAKA,QAAQrD,KAAb,gBACf,EAAKsD,SAAW,EAAKA,SAAStD,KAAd,gBAChB,EAAKuD,iBAAmB,EAAKA,iBAAiBvD,KAAtB,gBACxB,EAAKwD,UAAY,EAAKA,UAAUxD,KAAf,gBAbC,E,gFAiBlB,IAAIiD,EAAWQ,KAAKC,OAAOC,OAAOC,YAAc,KAAO,IACvD1D,KAAKC,SAAS,CACb8C,SAAWA,EACXC,QAAWO,KAAKI,KAvBH,SAuB4B,EAATZ,Q,0CAKjC/C,KAAKqD,mBACLI,OAAOG,iBAAiB,SAAU5D,KAAKqD,oB,6CAIvCI,OAAOI,oBAAoB,SAAU7D,KAAKqD,oB,gCAIrCrD,KAAKxB,MAAMsE,WAAW,GAAM9C,KAAKxB,MAAMwE,SAC3ChD,KAAKC,UAAS,SAAC6D,GAAD,MAAgB,CAAEhB,WAAYgB,EAAUhB,WAAa,Q,gCAIhE9C,KAAKxB,MAAMsE,WAAa,GAC3B9C,KAAKC,UAAS,SAAC6D,GAAD,MAAgB,CAAEhB,WAAYgB,EAAUhB,WAAa,Q,iCAIpE,IAAIiB,EAAMC,SAAS/B,OAAOgC,OAAO,wFAAyF,KAA2B,EAApBjE,KAAKxB,MAAMuE,UACxIgB,GAAO/D,KAAKxB,MAAMwE,SACrBhD,KAAKC,UAAS,iBAAO,CAAE6C,WAAYS,KAAKC,MAAMO,GAAK,Q,kCAIpD/D,KAAKC,UAAS,SAAC6D,GAAD,MAAgB,CAAEb,KAAMa,EAAUb,U,+BAIhD,OACC,6BACC,wBAAI9B,UAAW,uCACd,wBAAIA,UAAU,YACb,uBAAG+C,KAAK,aAAa/C,UAAU,kBAAkBgD,cAAY,MAAMC,KAAK,OAAxE,cAED,wBAAIjD,UAAU,YACb,uBAAG+C,KAAK,MAAM/C,UAAU,WAAWgD,cAAY,MAAMC,KAAK,OAA1D,YAIF,yBAAKjD,UAAU,eACd,yBAAKiD,KAAK,WAAWjD,UAAU,kCAAkCkD,GAAG,aAClEC,EAAetE,KAAKR,MAAMpB,YAE5B,yBAAKgG,KAAK,WAAWjD,UAAU,WAAWkD,GAAG,MAC3CE,EAAkBvE,KAAKR,MAAMgF,OAAQxE,KAAKxB,MAAMsE,WAAY9C,KAAKxB,MAAMuE,SAAU/C,KAAKxB,MAAMyE,KAC7F,6BACC,4BAAQ/B,KAAK,SAASC,UAAU,4BAA4BC,QAASpB,KAAKmD,SAA1E,QACA,4BAAQjC,KAAK,SAASC,UAAU,4BAA4BC,QAASpB,KAAKkD,SAA1E,QACA,4BAAQhC,KAAK,SAASC,UAAU,4BAA4BC,QAASpB,KAAKoD,UAA1E,SAED,6BACC,4BAAQlC,KAAK,SAASC,UAAU,6BAA6BC,QAASpB,KAAKsD,WAEzEtD,KAAKxB,MAAMyE,IAAM,oBAAsB,iC,GAhFnBzC,aA+FvB8D,EAAiB,SAAClG,GAIvB,IAHA,IAAIqG,EAAO,GAGFzG,EAAI,EAAGA,EAAI,GAAIA,IACvByG,EAAKC,KAAKC,EAAO,IAAK3G,EAAGI,IAE1B,IAAK,IAAIJ,EAAI,EAAGA,EAAI,GAAIA,IACvByG,EAAKC,KAAKC,EAAO,IAAK3G,EAAGI,IAE1B,IAAK,IAAIJ,EAAI,EAAGA,EAAI,EAAGA,IACtByG,EAAKC,KAAKC,EAAO,IAAK3G,EAAGI,IAa1B,OATAqG,EAAKC,KACJ,wBAAIE,IAAK,UACR,mCACA,mCACA,qCAMD,2BAAOzD,UAAWyB,GACjB,2BAAOzB,UAAU,gBAChB,wBAAIA,UAAU,gBACb,wBAAIA,UAAU,eAAe0D,MAAM,OAAnC,YACA,wBAAI1D,UAAU,eAAe0D,MAAM,OAAnC,WACA,wBAAI1D,UAAU,eAAe0D,MAAM,OAAnC,iBAGF,+BACEJ,KAUCF,EAAoB,SAACC,EAAQ1B,EAAYC,EAAUE,GACxD,IAAI6B,EAASL,EAAO,GAEhBM,GAAajC,EAAW,GAAGC,EAAS,EACpCiC,EAAUlC,EAAWC,EAAS,SAGlC+B,EAAUG,OAAOC,OAAO,GAAIV,IACd,iBACPM,EAAO,gBACPA,EAAO,SAEd,IAAK,IAAI9G,EAAI+G,EAAW/G,EAAIgH,EAAShH,GAAI,EACpCA,GA1JU,aA2JMmH,IAAfL,EAAQ9G,SAAqCmH,IAAjBL,EAAQ9G,EAAE,SAAqCmH,IAAjBL,EAAQ9G,EAAE,SAAqCmH,IAAjBL,EAAQ9G,EAAE,GACrGyG,EAAKC,KAAKU,EAAQpH,EAAGiF,IAErBA,EAAMwB,EAAKC,KAAKW,EAAaP,EAAS9G,IAAMyG,EAAKC,KAAKY,EAAaR,EAAS9G,IAG7EyG,EAAKC,KAAKa,EAASvH,IAKrB,OACC,2BAAOmD,UAAWyB,GACjB,+BACC,4BACC,wBAAIiC,MAAM,OAAV,WACA,wBAAIA,MAAM,OAAV,MACA,wBAAIA,MAAM,OAAV,MACA,wBAAIA,MAAM,OAAV,MACA,wBAAIA,MAAM,OAAV,QAGF,+BACEJ,KAUCc,EAAW,SAACX,GACjB,OACC,wBAAIA,IAAKA,GACR,0CACA,mCACA,mCACA,mCACA,qCAUGQ,EAAU,SAACR,EAAK3B,GACrB,OACC,wBAAI2B,IAAKA,GACR,4BAAKjC,EAAYiC,EAAK,IACtB,4BAAK3B,EAAM,KAAO,KAClB,4BAAKA,EAAM,KAAO,KAClB,4BAAKA,EAAM,KAAO,KAClB,4BAAKA,EAAM,KAAO,OASfqC,EAAe,SAACd,EAAQI,GAC7B,IAAIY,EAAM,MACYL,IAArBX,EAAO,GAAD,OAAII,IAAuB,EAAIJ,EAAO,GAAD,OAAII,SACxBO,IAAvBX,EAAO,GAAD,OAAII,EAAI,IAAqB,EAAIJ,EAAO,GAAD,OAAII,EAAI,SAC9BO,IAAvBX,EAAO,GAAD,OAAII,EAAI,IAAqB,EAAIJ,EAAO,GAAD,OAAII,EAAI,SAC9BO,IAAvBX,EAAO,GAAD,OAAII,EAAI,IAAqB,EAAIJ,EAAO,GAAD,OAAII,EAAI,KAGtD,OACC,wBAAIA,IAAKA,GACR,4BAAKjC,EAAYiC,EAAK,IACtB,4BAAKY,EAAI,IACT,4BAAKA,EAAI,IACT,4BAAKA,EAAI,IACT,4BAAKA,EAAI,MASNH,EAAe,SAACb,EAAQI,GAC7B,IAAIY,EAAM,MACYL,IAArBX,EAAO,GAAD,OAAII,IAAuB,EAAIJ,EAAO,GAAD,OAAII,SACxBO,IAAvBX,EAAO,GAAD,OAAII,EAAI,IAAqB,EAAIJ,EAAO,GAAD,OAAII,EAAI,SAC9BO,IAAvBX,EAAO,GAAD,OAAII,EAAI,IAAqB,EAAIJ,EAAO,GAAD,OAAII,EAAI,SAC9BO,IAAvBX,EAAO,GAAD,OAAII,EAAI,IAAqB,EAAIJ,EAAO,GAAD,OAAII,EAAI,KAGtD,OACC,wBAAIA,IAAKA,GACR,4BAAKjC,EAAYiC,EAAK,IACtB,4BAAKtC,EAASkD,EAAI,GAAI,IACtB,4BAAKlD,EAASkD,EAAI,GAAI,IACtB,4BAAKlD,EAASkD,EAAI,GAAI,IACtB,4BAAKlD,EAASkD,EAAI,GAAI,MAWnBb,EAAS,SAACc,EAAQC,EAAKtH,GAC5B,IAAIuH,EAAMvH,EAAU,GAAD,OAAIqH,GAAJ,OAAaC,IAEhC,OACC,wBAAId,IAAG,UAAKa,GAAL,OAAcC,IACpB,4BAAKD,EAAQC,GACb,4BAAKC,GACL,4BAAKhD,EAAYgD,EAAK,MAUV9C,ICnQT+C,EAAiB,SAAChF,EAAID,GAC3B,IAAI8D,EAAO,GACX,IAAK,IAAIoB,KAAKlF,EACb8D,EAAKC,KAAKoB,EAAWnF,EAAQkF,GAAIjF,EAAIiF,IAEtC,OAAOpB,GAUFqB,EAAa,SAACC,EAAQnF,EAAIoF,GAC/B,IAAIN,EAAM,EACNO,EAAQrF,IAAOqB,OAAO+D,GAAQ,eAAiB,GAC/CvB,EAAO,GAH6B,uBAKxC,IAAI,IAAJ,IAAasB,EAAb,+CAAoB,CAAC,IAAb/H,EAAY,QACnByG,EAAKC,KACJ,wBAAIE,IAAKc,EAAKvE,UAAW8E,GACxB,4BAAKtD,EAAY3E,EAAEkI,YAAYC,OAAO,GAAI,IAC1C,4BAAKnI,EAAEkI,YAAY1D,YACnB,4BAAKxE,EAAEoI,YAGTV,KAbuC,kFAexC,OAAOjB,GAQO4B,EA/DK,SAAC7G,GACpB,OACC,yBAAK2B,UAAU,kBACd,2BAAOA,UAAU,6BAA6BkD,GAAG,eAChD,+BACC,4BACC,wBAAIQ,MAAM,OAAV,gBACA,wBAAIA,MAAM,OAAV,cACA,wBAAIA,MAAM,OAAV,mBAGF,+BACEe,EAAepG,EAAMoB,GAAIpB,EAAMmB,aCwCtB2F,EA3CG,SAAC9G,GAClB,OACC,yBAAK2B,UAAU,OACd,yBAAKA,UAAU,4BACd,kBAAC,EAAD,CACCI,QAAW/B,EAAM+B,QACjBT,UAAatB,EAAMsB,UACnBD,SAAYrB,EAAMqB,SAClBW,UAAahC,EAAMgC,UACnBC,WAAcjC,EAAMiC,WACpBK,UAAatC,EAAMsC,UACnBlB,GAAMpB,EAAMoB,GACZD,QAAWnB,EAAMmB,UAElB,kBAAC,EAAD,CACCC,GAAMpB,EAAMoB,GACZD,QAAWnB,EAAMmB,WAInB,yBAAKQ,UAAU,0CACd,kBAAC,EAAD,CACC/C,UAAaoB,EAAMpB,UACnBoG,OAAUhF,EAAMgF,YC4BN+B,EA9DE,SAAC/G,GACjB,IAAIgH,EAAOC,EAAS,MAAOC,EAAS,GAGpC,GAAIlH,EAAMmH,MAAM/E,OAAQ,CACvB,IAAK,IAAI5D,KAAKwB,EAAMmH,MAAOD,GAA6B,SAAnBlH,EAAMmH,MAAM3I,GAAgB,GAAK,WAAIwB,EAAMoH,OAAO5I,GAAjB,MAA0BwB,EAAMmH,MAAM3I,GAAK,KACjHwI,EAAQ,WAAQK,MAAMH,IACtBD,EAAS,GAGV,OACC,kBAAC,WAAD,KACC,wBAAItF,UAAW,uCACd,wBAAIA,UAAU,YACb,uBAAG+C,KAAK,UAAU/C,UAAU,kBAAkBgD,cAAY,MAAMC,KAAK,OAArE,WAED,wBAAIjD,UAAU,aACb,uBAAG+C,KAAK,aAAa/C,UAAU,WAAWC,QAASoF,EAAOrC,cAAasC,EAAQrC,KAAK,OAApF,eAIF,yBAAKjD,UAAU,yBACd,yBAAKiD,KAAK,WAAWjD,UAAU,kBAAkBkD,GAAG,UACnD,kBAAC,EAAD,CACCnE,aAAgBV,EAAMU,gBAGxB,yBAAKkE,KAAK,WAAWjD,UAAU,WAAWkD,GAAG,aAC5C,kBAAC,EAAD,CACC9C,QAAW/B,EAAM+B,QACjBiD,OAAUhF,EAAMgF,OAChB1D,UAAatB,EAAMsB,UACnBD,SAAYrB,EAAMqB,SAClBW,UAAahC,EAAMgC,UACnBC,WAAcjC,EAAMiC,WACpBK,UAAatC,EAAMsC,UACnB1D,UAAaoB,EAAMpB,UACnBwC,GAAMpB,EAAMoB,GACZD,QAAWnB,EAAMmB,cC9CjBmG,E,WACL,aAAe,oBACd9G,KAAKuB,QAAU,GACfvB,KAAK+G,IAAM,CAEV,GAAO,EACP,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAC/C,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,IAAQ,EAChD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EACpD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EACpD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EACpD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EACpD,IAAQ,EAER,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EACzD,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,IAAQ,EAChD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAEpD,GAAM,EAAG,GAAM,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EACvD,GAAO,EAAG,GAAO,GAElB/G,KAAKgH,IAAM,CACV,SAAc,EACd,UAAc,EACd,SAAa,SAEdhH,KAAKiH,IAAM,CACV,KAAQ,EACR,GAAM,G,oDAKPjH,KAAKuB,QAAU,GACfvB,KAAKgH,IAAM,CACV,SAAc,EACd,UAAc,EACd,SAAa,SAEdhH,KAAK+G,IAAM,CAEV,GAAO,EACP,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAC/C,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,IAAQ,EAChD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EACpD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EACpD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EACpD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EACpD,IAAQ,EAER,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EACzD,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,IAAQ,EAChD,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAAG,IAAQ,EAEpD,GAAM,EAAG,GAAM,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EAAG,GAAO,EACvD,GAAO,EAAG,GAAO,GAElB/G,KAAKiH,IAAM,CACV,KAAQ,EACR,GAAM,K,kCAKP,OAAOjH,KAAKgH,M,+BAIZ,OAAOhH,KAAK+G,M,sCAIZ,IAAIG,EAAGC,EAAGC,EACVF,EAAIjC,OAAOC,OAAO,GAAIlF,KAAK+G,KAC3BI,EAAIlC,OAAOC,OAAO,GAAIlF,KAAKgH,KAC3BI,EAAInC,OAAOC,OAAO,GAAIlF,KAAKiH,KAC3BjH,KAAKuB,QAAQmD,KAAK,CAACqC,IAAKG,EAAGF,IAAKG,EAAGF,IAAKG,M,mCAIxC,IAAIC,EAAOrH,KAAKuB,QAAQ+F,MACxB,QAAID,IAEJrH,KAAK+G,IAAMM,EAAKN,IAChB/G,KAAKgH,IAAMK,EAAKL,IAChBhH,KAAKiH,IAAMI,EAAKJ,KACT,O,KAIMH,IC1FTS,EAAc,CACnB,MAAO,MAAO,MAAO,MAAO,KAAM,MAAO,QAAS,OAAQ,OAAQ,OAAQ,QAErEC,EAAW,CAChB,MAAO,OAAQ,OAAQ,MAAO,OAAQ,OAAQ,MAAO,OAAQ,OAAQ,KAAM,MAAO,MAClF,KAAM,MAAO,MAAO,MAAO,OAAQ,OAAQ,MAAO,OAAQ,QAAS,SAAU,KAAM,MAAO,MAC1F,MAAO,OAAQ,QAEVC,EAAY,CACjB,QAAS,SAAU,QAAS,SAAU,QAAS,SAAU,QAAS,SAClE,SAAU,UAAW,SAAU,UAAW,SAAU,WAE/CC,EAAY,CACjB,MAAO,MAAO,MAAO,MAAO,OAAQ,OAAQ,OAAQ,OAAQ,MAAO,MACnE,MAAO,MAAO,OAAQ,OAAQ,OAAQ,OAAQ,MAAO,MAAO,MAAO,OAE9DC,EAAa,CAClB,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAExEC,EAAW,CAChB,MAAO,QAEFC,EAAa,CAClB,OAAQ,QAAS,OAAQ,SACzB,UAAW,SAENC,EAAY,CACjB,OAAQ,MAAO,QAKVC,EAAU,CACf,SAAU,OAAQ,OAAQ,KAAM,SAAU,OAAQ,OAClD,QAAS,MAAO,SAAU,OAG1B,UAAW,QAAS,QAAS,MAG7B,QAAS,WAMJ5J,EAAY,GAAG6J,OACpBT,EAAaC,EAAUC,EAAWC,EAAWC,EAC7CC,EAAUC,EAAYC,EAnBL,CACjB,MAAO,OAkBqCC,EANxB,CACpB,UAQKE,GAAgB,CACrB,OAAY,mBACZ,IAAU,kBACV,IAAU,oBACV,IAAU,oBACV,OAAY,oBACZ,OAAY,oBACZ,IAAS,iBACT,MAAW,sBACX,OAAY,uBACZ,KAAW,qBACX,KAAW,qBACX,KAAW,mBACX,KAAU,oBACV,OAAY,0BAQPC,GAAc,SAAChH,GACpB,IAAIwE,EAAKd,EAAKuD,EAEVC,EAAc,CACjBC,IAAOb,EAASc,SAASpH,GACzBqH,KAAQd,EAAUa,SAASpH,GAC3BsH,KAAOd,EAAUY,SAASpH,GAC1BuH,MAASd,EAAWW,SAASpH,GAC7BwH,IAAOd,EAASU,SAASpH,GACzByH,MAAQd,EAAWS,SAASpH,GAC5B0H,KAAQd,EAAUQ,SAASpH,GAC3B2H,GAAOd,EAAQO,SAASpH,IAKzB,IAAKwE,KAFLyC,EAAOlD,OAAOkD,KAAKC,GAIlB,GAAIA,EADJxD,EAAMuD,EAAKzC,IACW,OAAOd,EAE9B,OAAO1D,GC5FF4H,GAAS,CACd,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC5D,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAC/D,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAUjEC,GAAY,GAAGf,OACpBc,GATe,CACf,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAElC,CACf,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACtD,MAAO,MAAO,MAAO,MAAO,MAAO,QAM9BE,GAAU,CACfC,GAAK,KACLC,GAAK,KACLC,GAAK,KACLC,GAAK,KACLC,IAAM,KACNC,IAAM,KACNC,IAAM,KACNC,IAAM,OCgLQC,G,WArMd,aAAe,oBACdzJ,KAAKxB,MAAQ,IAAIsI,EACjB9G,KAAKuB,QAAU,GACfvB,KAAKW,QAAU,GACfX,KAAK0J,eAAiB,KACtBjG,OAAOjF,MAAQwB,KAAKxB,M,oDAIpBwB,KAAKxB,MAAMmL,QACX3J,KAAKuB,QAAU,GACfvB,KAAKW,QAAU,GACfX,KAAK0J,eAAiB,O,8BAItB,OAAO1J,KAAKxB,MAAMyI,IAAX,K,6BAIP,IAAIlB,EAAS/F,KAAKW,QAAQX,KAAKxB,MAAMyI,IAAIrG,IACzC,QAAImF,IACJ/F,KAAKxB,MAAMoL,gBACO,IAAlB7D,EAAOnE,OAAe5B,KAAK6J,UAAU9D,GAAU/F,KAAK8J,QAAQ/D,EAAO,GAAGG,aAClElG,KAAK0J,gBAAgB1J,KAAK+J,uBACvB,K,gCAGEhE,GAET,IAAInF,EAAKZ,KAAKxB,MAAMyI,IAAIrG,GACpBoJ,EAAY,GAHC,uBAIjB,IAAI,IAAJ,IAAcjE,EAAO,GAAGkE,IAAxB,+CAA4B,CAAC,IAArBC,EAAoB,QACxBnB,GAAUT,SAAS4B,IAAOnE,EAAO,GAAGkE,IAAI3B,SAAS4B,KACnDF,EAAUE,GAAM,KAND,kFAUjB,IAAI,IAAIC,KAAYH,EACnBA,EAAUG,GAAU9C,KAAOrH,KAAKxB,MAAMuI,IAAIoD,GAK3C,IAAI,IAAIA,KAFRnK,KAAK8J,QAAQ/D,EAAO,GAAGG,aAEH8D,EAChBA,EAAUG,GAAU9C,OAASrH,KAAKxB,MAAMuI,IAAIoD,KAC9CH,EAAUG,GAAUzL,KAAOsB,KAAKxB,MAAMuI,IAAIoD,GAC1CnK,KAAKxB,MAAMuI,IAAIoD,GAAYH,EAAUG,GAAU9C,MAMjD,IAAI,IAAI8C,KAFRnK,KAAK8J,QAAQ/D,EAAO,GAAGG,aAEH8D,EAChBA,EAAUG,GAAUzL,OACtBsB,KAAKxB,MAAMuI,IAAIoD,GAAYH,EAAUG,GAAUzL,MAGjDsB,KAAKxB,MAAMyI,IAAIrG,GAAKA,EAAK,I,4CAIQ,IAA9BZ,KAAK0J,eAAeU,MACtBpK,KAAK0J,eAAeU,SAEiB,OAAlCpK,KAAK0J,eAAeW,KAAKC,KAC3BtK,KAAKxB,MAAMyI,IAAIrG,GAAKZ,KAAK0J,eAAe9I,GAExCZ,KAAKxB,MAAMyI,IAAIrG,IAAM,EAEtBZ,KAAK0J,eAAeW,KAAKP,QAAQ9J,KAAKxB,OACtCwB,KAAK0J,eAAiB,Q,6BAMvB1J,KAAKxB,MAAM+L,e,4BAKX,IACIC,EAAOC,EADPpI,EAAI,EAGR,IADAmI,EAAQE,YAAYC,MACd3K,KAAKW,QAAQX,KAAKxB,MAAMyI,IAAIrG,KACjCZ,KAAK4K,OACLvI,IAEDoI,EAAMC,YAAYC,MAClBE,QAAQC,IAAIzI,EAAG,sBAAuBoI,EAAID,EAAO,OACjDK,QAAQC,IAAIzI,IAAIoI,EAAID,GAAO,KAAO,yB,+BAQ1B7J,GACRX,KAAK2J,QACL,IAAI5D,EAAQC,EAAM+E,GAAW,EAFb,uBAIhB,IAAI,IAAJ,IAAcpK,EAAd,+CAEC,GADAqF,GADGD,EAAkB,SACPiF,OACXjF,EAAOkF,QACT,OAAOlF,EAAOmF,KAAKhK,MAClB,IAAK,OACJlB,KAAKxB,MAAMwI,IAAIhB,EAAO,GAAyB,IAApBD,EAAOmF,KAAK7K,MACvCL,KAAKxB,MAAMwI,IAAIhB,EAAO,GAAMD,EAAOmF,KAAK7K,OAAS,EAAK,IACtDL,KAAKxB,MAAMwI,IAAIhB,EAAO,GAAMD,EAAOmF,KAAK7K,OAAS,GAAM,IACvDL,KAAKxB,MAAMwI,IAAIhB,EAAO,GAAMD,EAAOmF,KAAK7K,OAAS,GAAM,IACvD,MACD,QACC,OAAO,OAGL0K,IACH/K,KAAKxB,MAAMyI,IAAIkE,KAAOnF,EACtBhG,KAAKxB,MAAMyI,IAAIrG,GAAKoF,EACpB+E,GAAW,GAEZ/K,KAAKW,QAAQqF,GAAQD,EAAOqF,aAC5BpL,KAAKqL,OAAOrF,EAAMD,GAxBJ,kFA4BhB,YAAeZ,IAAXY,IAGJ/F,KAAKxB,MAAMwI,IAAX,SAA6B/E,OAAO+D,GAAQD,EAAOuF,MAC5C,K,6BAGDtF,EAAMD,GACZ,IAAIF,EAAI,EADW,uBAEnB,IAAI,IAAJ,IAAgBE,EAAOqF,aAAvB,+CAAoC,CAAC,IAA7Bf,EAA4B,+BACnC,IAAI,IAAJ,IAAeA,EAAKnE,YAAYC,OAAhC,+CAAuC,CAAC,IAAhCoF,EAA+B,QACtCvL,KAAKxB,MAAMwI,IAAIhB,EAAOH,EAAI,GAAW,IAAN0F,EAC/BvL,KAAKxB,MAAMwI,IAAIhB,EAAOH,EAAI,GAAM0F,GAAO,EAAK,IAC5CvL,KAAKxB,MAAMwI,IAAIhB,EAAOH,EAAI,GAAM0F,GAAO,GAAM,IAC7CvL,KAAKxB,MAAMwI,IAAIhB,EAAOH,EAAI,GAAM0F,GAAO,GAAM,IAC7C1F,GAAK,GAN6B,oFAFjB,qF,8BAgBZwE,GACP,IAAmB,EAAZA,EAAKzB,QAAmB,IAAO5I,KAAKxB,MAAMuI,IAAX,WAA+B,EAAZsD,EAAKzB,OAC7D,IAAIb,EAAQO,SAAS+B,EAAKC,OAASD,EAAKC,KAAKhC,SAAS,MACrD+B,EAAKP,QAAQ9J,KAAKxB,WACZ,CACN,IAAI4L,EAAQ,EACZ,OAAOC,EAAKC,MACX,IAAK,KACJF,EAAQ,EACR,MACD,QACCA,EAAQ,EAGVpK,KAAK0J,eAAiB,CAAEU,QAAOC,OAAMzJ,GAAIZ,KAAKxB,MAAMyI,IAAIrG,IACxDZ,KAAKxB,MAAMyI,IAAIrG,IAAM,OAEZmH,EAAQO,SAAS+B,EAAKC,QAChCtK,KAAKxB,MAAMyI,IAAIrG,IAAM,GAGnB4G,EAASc,SAAS+B,EAAKC,OAAuB,MAAdD,EAAKnJ,KACvClB,KAAKxB,MAAMyI,IAAIrG,IAAM,EACXmH,EAAQO,SAAS+B,EAAKC,QAChCtK,KAAKxB,MAAMyI,IAAIrG,IAAM,GAEtBZ,KAAKwL,e,+BAIL,OAAOxL,KAAKxB,MAAMiN,W,+BAIlB,OAAOzL,KAAKxB,MAAMkN,c,mCAIlB1L,KAAKxB,MAAMuI,IAAI4E,GAAK,EACpB3L,KAAKxB,MAAMuI,IAAI6E,GAAK,EACpB5L,KAAKxB,MAAMuI,IAAI8E,GAAK,EACpB,IAAK,IAAI7N,EAAI,EAAGA,EAAI,EAAGA,IACtBgC,KAAKxB,MAAMuI,IAAI8E,IAAM7L,KAAKxB,MAAMuI,IAAX,WAAmB/I,KAAQA,M,KC9IpC8N,G,WAvCd,cAAiD,IAAnCxB,EAAkC,EAAlCA,KAAMyB,EAA4B,EAA5BA,KAAMnD,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAcxC,OAd+C,oBAC/ClM,KAAKkB,KAAOiL,MAAMD,GAAO,IAAOjK,OAAOiK,GAAO,KAAS,IAAM,IAC7DlM,KAAK4I,KAAOA,EACZ5I,KAAKgM,GAAKA,EACVhM,KAAKiM,IAAMA,EACXjM,KAAKkM,IAAMA,EACXlM,KAAKsK,KAAOA,EACZtK,KAAK+L,KAAOA,EAGT,CAAC,GAAQ,GAAQ,IAAQzD,SAASyD,IAAuB,MAAd/L,KAAKkB,OAClDlB,KAAKkB,KAAO,KAGLlB,KAAKkB,MACZ,IAAK,IACJlB,KAAKmG,OC9BkB,SAACyC,EAAMoD,EAAIC,EAAKG,EAAKL,GAC/C,IAAI5F,EAAS,CAAC,GAed,OAbAyC,EAAO7G,EAAS6G,GAChBmD,EAAOhK,EAASgK,GAChBC,EAAK9J,EAAS8J,GACdC,EAAM/J,EAAS+J,GACfG,EAAMlK,EAASkK,GAEfjG,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,GAAW,GACxBA,EAAO,IAAM6F,GAAM,GACnB7F,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,IAAMiG,GAAO,EACpBjG,EAAO,IAAM4F,GAAQ,EAEd5F,EDcUkG,CAAYzD,EAAMoD,EAAIC,EAAKC,EAAKH,GAC9C,MACD,IAAK,IACJ/L,KAAKkM,KAAO,KACZlM,KAAKmG,OCfkB,SAACyC,EAAMmD,EAAMC,EAAIC,EAAKK,GAChD,IAAInG,EAAS,CAAC,GAcd,OAZAyC,EAAO7G,EAAS6G,GAChBmD,EAAOhK,EAASgK,GAChBO,EAAMvK,EAASuK,GACfN,EAAK9J,EAAS8J,GACdC,EAAM/J,EAAS+J,GAEf9F,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,KAAc,EAAP4F,IAAe,GAC7B5F,EAAO,IAAM6F,GAAM,GACnB7F,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,IAAMmG,GAAO,EAEbnG,EDAUoG,CAAY3D,EAAMmD,EAAMC,EAAIC,EAAKC,GAC/C,MACD,IAAK,IACJlM,KAAKmG,OCAmB,SAACyC,EAAMoD,EAAIC,EAAKF,EAAMS,GACjD,IAAIrG,EAAS,CAAC,EAAG,GAgBjB,OAdAyC,EAAO7G,EAAS6G,GAChBmD,EAAOhK,EAASgK,GAChBS,EAAOzK,EAASyK,GAChBR,EAAK9J,EAAS8J,GACdC,EAAM/J,EAAS+J,GAEf9F,EAAO,IAAM,GAAK,GAClBA,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,IAAW,GACxBA,EAAO,IAAM6F,GAAM,GACnB7F,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,IAAM4F,EACb5F,EAAO,GAAY,WAAPqG,EAELrG,EDjBUsG,CAAa7D,EAAMoD,EAAIC,EAAKF,EAAMG,GAChD,MACD,QACC,MAAM,IAAIQ,MAAJ,6BAAgC1M,KAAKsK,Q,sDAK7C,MAAM,IAAIoC,MAAM,8BAA+B1M,Q,iCAI/C,MAAM,GAAN,OAAUA,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkGtK,KAAKgM,GAAvG,cAA+GhM,KAAKiM,IAApH,aAA4HjM,KAAKkM,S,KErBpHS,G,YAdd,cAAqC,IAAvB/D,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,MAAOyB,KAAM,EAAGnD,OAAMoD,KAAIC,MAAKC,S,wEAQ5B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,IAAOjF,EAAI/G,KAAKiM,MAAsB,MAAdjM,KAAKkB,KAAe6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,MAAS,M,GAnB1EJ,ICuBHc,G,YAdd,cAAqC,IAAvBhE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,MAAOyB,KAAM,GAAInD,OAAMoD,KAAIC,MAAKC,S,wEAQ7B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,MAASjF,EAAI/G,KAAKiM,MAAsB,MAAdjM,KAAKkB,KAAe6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,MAAS,O,GAnB5EJ,ICuBHe,G,YAdd,cAAqC,IAAvBjE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,QAASyB,KAAM,GAAInD,OAAMoD,KAAIC,MAAKC,S,wEAQ/B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,KAAQjF,EAAI/G,KAAKiM,MAAQ,IAAoB,MAAdjM,KAAKkB,KAAe6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,MAAS,M,GAnB5EJ,ICuBRgB,G,YAdd,cAAqC,IAAvBlE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,SAAUyB,KAAM,GAAInD,OAAMoD,KAAIC,MAAKC,S,wEAQhC,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,KAAQjF,EAAI/G,KAAKiM,MAAQ,IAAoB,MAAdjM,KAAKkB,KAAe6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,MAAS,M,GAnB3EJ,ICuBTiB,G,YAdd,cAAqC,IAAvBnE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,KAAMyB,KAAM,EAAGnD,OAAMoD,KAAIC,MAAKC,S,wEAQ3B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,IAAOjF,EAAI/G,KAAKiM,OAAuB,MAAdjM,KAAKkB,KAA+B,GAAhB6F,EAAI/G,KAAKkM,KAAiC,GAAnBjK,OAAOjC,KAAKkM,MAAgB,M,GAnBnFJ,ICuBTkB,G,YAdd,cAAqC,IAAvBpE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,KAAMyB,KAAM,EAAGnD,OAAMoD,KAAIC,MAAKC,S,wEAQ3B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,IAAOjF,EAAI/G,KAAKiM,QAAwB,MAAdjM,KAAKkB,KAA+B,GAAhB6F,EAAI/G,KAAKkM,KAAiC,GAAnBjK,OAAOjC,KAAKkM,MAAgB,M,GAnBnFJ,ICuBVmB,G,YAdd,cAAqC,IAAvBrE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,MAAOyB,KAAM,EAAGnD,OAAMoD,KAAIC,MAAKC,S,wEAQ5B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,IAAOjF,EAAI/G,KAAKiM,OAAuB,MAAdjM,KAAKkB,KAA+B,GAAhB6F,EAAI/G,KAAKkM,KAAiC,GAAnBjK,OAAOjC,KAAKkM,MAAgB,M,GAnBxEJ,ICuBpBoB,G,YAdd,cAAqC,IAAvBtE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,MAAOyB,KAAM,EAAGnD,OAAMoD,KAAIC,MAAKC,S,wEAQ5B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,IAAOjF,EAAI/G,KAAKiM,MAAsB,MAAdjM,KAAKkB,KAAe6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,MAAS,M,GAnB1EJ,ICuBHqB,G,YAdd,cAAqC,IAAvBvE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,MAAOyB,KAAM,EAAGnD,OAAMoD,KAAIC,MAAKC,S,wEAQ5B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,IAAOjF,EAAI/G,KAAKiM,MAAsB,MAAdjM,KAAKkB,KAAe6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,MAAS,M,GAnB1EJ,ICuBHsB,G,YAdd,cAAqC,IAAvBxE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,KAAMyB,KAAM,EAAGnD,OAAMoD,KAAIC,MAAKC,S,wEAQ3B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,IAAMjF,EAAI/G,KAAKiM,MAAsB,MAAdjM,KAAKkB,KAAe6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,U,GAnBjEJ,ICuBFuB,G,YAdd,cAAqC,IAAvBzE,EAAsB,EAAtBA,KAAMoD,EAAgB,EAAhBA,GAAIC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAE5B,KAAM,MAAOyB,KAAM,EAAGnD,OAAMoD,KAAIC,MAAKC,S,wEAQ5B,IAARnF,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,IAAMjF,EAAI/G,KAAKiM,MAAsB,MAAdjM,KAAKkB,KAAe6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,U,GAnBhEJ,ICuCHwB,G,WA9Bd,cAAiD,IAAnChD,EAAkC,EAAlCA,KAAM1B,EAA4B,EAA5BA,KAAM2E,EAAsB,EAAtBA,GAAItB,EAAkB,EAAlBA,IAAKC,EAAa,EAAbA,IAAKH,EAAQ,EAARA,KASvC,OAT+C,oBAC/C/L,KAAKkB,KAAOiL,MAAMD,GAAO,IAAM,IAC/BlM,KAAK4I,KAAOA,EACZ5I,KAAKuN,GAAKA,EACVvN,KAAKiM,IAAMA,EACXjM,KAAKkM,IAAMA,EACXlM,KAAKsK,KAAOA,EACZtK,KAAK+L,KAAOA,EAEJ/L,KAAKkB,MACZ,IAAK,IACJlB,KAAKmG,OCzBkB,SAACyC,EAAM2E,EAAItB,EAAKG,EAAKL,GAC/C,IAAI5F,EAAS,CAAC,GAgBd,OAdAyC,EAAO7G,EAAS6G,GAChBmD,EAAOhK,EAASgK,GAChBwB,EAAKrL,EAASqL,GACdtB,EAAM/J,EAAS+J,GACfG,EAAMlK,EAASkK,GAEfjG,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,GAAW,GACxBA,EAAO,IAAMoH,GAAM,GACnBpH,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,IAAMiG,GAAO,EACpBjG,EAAO,IAAM,GACbA,EAAO,IAAM4F,GAAQ,EAEd5F,EDQUkG,CAAYzD,EAAM2E,EAAItB,EAAKC,EAAKH,GAC9C,MACD,IAAK,IACJ/L,KAAKkM,KAAO,GACZlM,KAAKmG,OCTkB,SAACyC,EAAM2E,EAAItB,EAAKK,EAAKP,GAC/C,IAAI5F,EAAS,CAAC,GAgBd,OAdAyC,EAAO7G,EAAS6G,GAChBmD,EAAOhK,EAASgK,GAChBO,EAAMvK,EAASuK,GACfiB,EAAKrL,EAASqL,GACdtB,EAAM/J,EAAS+J,GAEf9F,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,GAAW,GACxBA,EAAO,IAAMoH,GAAM,GACnBpH,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,KAAc,GAANmG,IAAe,EAC9BnG,EAAO,IAAM,GACbA,EAAO,IAAM4F,GAAQ,EAEd5F,EDRUoG,CAAY3D,EAAM2E,EAAItB,EAAKC,EAAKH,GAC9C,MACD,QACC,MAAM,IAAIW,MAAJ,6BAAgC1M,KAAKsK,Q,sDAK7C,MAAM,IAAIoC,MAAM,8BAA+B1M,Q,iCAG/C,MAAM,GAAN,OAAUA,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkGtK,KAAKuN,GAAvG,cAA+GvN,KAAKiM,IAApH,aAA4HjM,KAAKkM,S,KEZpHsB,G,YAdd,cAAqC,IAAvB5E,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAItB,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAC5B,KAAM,QAASyB,KAAM,EAAQnD,OAAM2E,KAAItB,MAAKC,S,wEAQhC,IAATnF,EAAQ,EAARA,IACVA,EAAI/G,KAAKuN,IAAMtL,OAAoG,KAA5F8E,EAAI/G,KAAKiM,KAAS,IAAoB,MAAdjM,KAAKkB,KAAe6F,EAAI/G,KAAKkM,KAA0B,GAAnBjK,OAAOjC,KAAKkM,Y,GAnB7EoB,ICwBLG,G,YAfd,cAAqC,IAAvB7E,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAItB,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAC5B,KAAM,QAASyB,KAAM,EAAQnD,OAAM2E,KAAItB,MAAKC,S,wEAQhC,IAATnF,EAAQ,EAARA,IACVA,EAAI/G,KAAKuN,IAAMtL,OAAO8E,EAAI/G,KAAKiM,QAAwB,MAAdjM,KAAKkB,KAC7C6F,EAAI/G,KAAKkM,KAASjK,OAAOjC,KAAKkM,MAAQ,IAAO,S,GApB5BoB,ICwBLI,G,YAfd,cAAqC,IAAvB9E,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAItB,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAC5B,KAAM,QAASyB,KAAM,EAAQnD,OAAM2E,KAAItB,MAAKC,S,wEAQhC,IAATnF,EAAQ,EAARA,IACVA,EAAI/G,KAAKuN,IAAMtL,OAAO8E,EAAI/G,KAAKiM,OAAuB,MAAdjM,KAAKkB,KAC5C6F,EAAI/G,KAAKkM,KAAQjK,OAAOjC,KAAKkM,MAAQ,IAAO,S,GApB3BoB,ICwBLK,G,YAfd,cAAqC,IAAvB/E,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAItB,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAC5B,KAAM,QAASyB,KAAM,EAAQnD,OAAM2E,KAAItB,MAAKC,S,wEAQhC,IAATnF,EAAQ,EAARA,IACVA,EAAI/G,KAAKuN,IAAMtL,OAAO8E,EAAI/G,KAAKiM,MAAsB,MAAdjM,KAAKkB,KAC3C6F,EAAI/G,KAAKkM,KAAQjK,OAAOjC,KAAKkM,MAAQ,IAAO,S,GApB3BoB,ICwBLM,G,YAfd,cAAqC,IAAvBhF,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAItB,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAC5B,KAAM,SAAUyB,KAAM,EAAQnD,OAAM2E,KAAItB,MAAKC,S,wEAQjC,IAATnF,EAAQ,EAARA,IACVA,EAAI/G,KAAKuN,IAAMtL,OAAO8E,EAAI/G,KAAKiM,QAAwB,MAAdjM,KAAKkB,KAC7C6F,EAAI/G,KAAKkM,KAAQjK,OAAOjC,KAAKkM,MAAQ,IAAO,S,GApB1BoB,ICwBNO,G,YAfd,cAAqC,IAAvBjF,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAItB,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAC5B,KAAM,SAAUyB,KAAM,EAAQnD,OAAM2E,KAAItB,MAAKC,S,wEAQjC,IAATnF,EAAQ,EAARA,IACVA,EAAI/G,KAAKuN,IAAMtL,OAAQ8E,EAAI/G,KAAKiM,OAAS,IAAsB,MAAdjM,KAAKkB,KACrD6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,QAAU,O,GApBpBoB,ICwBNQ,G,YAfd,cAAqC,IAAvBlF,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAItB,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAC5B,KAAM,SAAUyB,KAAM,EAAQnD,OAAM2E,KAAItB,MAAKC,S,wEAOxB,IAATnF,EAAQ,EAARA,IACnBA,EAAI/G,KAAKuN,IACRtL,OAAQ8E,EAAI/G,KAAKiM,OAAS,GAAqB,MAAdjM,KAAKkB,KACrC6F,EAAI/G,KAAKkM,KAAOjK,OAAOjC,KAAKkM,QAAW,O,GApBtBoB,IC6CNS,G,WArCd,cAA4C,IAA9BzD,EAA6B,EAA7BA,KAAM1B,EAAuB,EAAvBA,KAAMoF,EAAiB,EAAjBA,EAAG9D,EAAc,EAAdA,GAAI+D,EAAU,EAAVA,GAAIC,EAAM,EAANA,GASpC,OAT0C,oBAC1ClO,KAAKkB,KAAS+M,GAAOC,EAAoB/B,MAAM8B,GAAQC,EAAoB,UAAf,aAA4B,YAA7D,WAC3BlO,KAAKsK,KAAOA,EACZtK,KAAK4I,KAAOA,EACZ5I,KAAKgO,EAAIA,EACThO,KAAKkK,GAAKA,EACVlK,KAAKiO,GAAKA,EACVjO,KAAKkO,GAAKA,EAEHlO,KAAKkB,MACX,IAAK,WACJlB,KAAKmG,OCcmB,SAACyC,EAAMoF,EAAG9D,GACrC,IAAI/D,EAAS,CAAC,GAYd,OAVAyC,EAAO7G,EAAS6G,GAChBoF,EAAIjM,EAASiM,GACb9D,EAAKnI,EAASmI,GAEd/D,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,IAAU,GACvBA,EAAO,IAAM6H,GAAK,GAClB7H,EAAO,IAAM,EACbA,EAAO,IAAM+D,GAAM,EAEZ/D,ED3BUgI,CAAanO,KAAK4I,KAAM5I,KAAKgO,EAAGhO,KAAKkK,IACnD,MACD,IAAK,aACJlK,KAAKmG,OC3BkB,SAACyC,EAAMoF,EAAG9D,EAAI+B,GACxC,IAAI9F,EAAS,CAAC,GAcd,OAZAyC,EAAO7G,EAAS6G,GAChBoF,EAAIjM,EAASiM,GACb9D,EAAKnI,EAASmI,GACd+B,EAAM/J,EAAS+J,GAEf9F,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,IAAU,GACvBA,EAAO,IAAM6H,GAAK,GAClB7H,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,IAAM,EACbA,EAAO,IAAM+D,GAAM,EAEZ/D,EDYUkG,CAAYrM,KAAK4I,KAAM5I,KAAKgO,EAAGhO,KAAKkK,GAAIlK,KAAKiO,IAC3D,MACD,IAAK,UACJjO,KAAKmG,OCZmB,SAACyC,EAAMoF,EAAG9D,EAAI+B,EAAKG,GAC9C,IAAIjG,EAAS,CAAC,GAgBd,OAdAyC,EAAO7G,EAAS6G,GAChBoF,EAAIjM,EAASiM,GACb9D,EAAKnI,EAASmI,GACd+B,EAAM/J,EAAS+J,GACfG,EAAMlK,EAASkK,GAEfjG,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,IAAU,GACvBA,EAAO,IAAM6H,GAAK,GAClB7H,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,IAAMiG,GAAO,EACpBjG,EAAO,IAAM,EACbA,EAAO,IAAM+D,GAAM,EAEZ/D,EDLUiI,CAAapO,KAAK4I,KAAM5I,KAAKgO,EAAGhO,KAAKkK,GAAIlK,KAAKiO,GAAIjO,KAAKkO,IACrE,MACD,IAAK,YACJlO,KAAKiO,IAAM,QACXjO,KAAKmG,OCoBkB,SAACyC,EAAMsB,EAAI8D,EAAG1B,GACxC,IAAInG,EAAS,CAAC,GAad,OAXAyC,EAAO7G,EAAS6G,GAChBsB,EAAKnI,EAASmI,GACd8D,EAAIjM,EAASiM,GACb1B,EAAMvK,EAASuK,GAEfnG,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,GAAQ,GACrBA,EAAO,IAAM+D,GAAM,GACnB/D,EAAO,IAAM6H,GAAK,GAClB7H,EAAO,IAAMmG,GAAO,EAEbnG,EDlCUoG,CAAYvM,KAAK4I,KAAM5I,KAAKkK,GAAIlK,KAAKgO,EAAGhO,KAAKiO,IAC3DjO,KAAKiO,GAAMhM,OAAOjC,KAAKiO,KAAO,IAAO,EACrC,MACD,QACC,MAAM,IAAIvB,MAAJ,6BAAgC1M,KAAKsK,Q,sDAI7C,MAAM,IAAIoC,MAAM,8BAA+B1M,Q,iCAG/C,IAAIiO,EAAKjO,KAAKiO,GAAK9B,MAAMnM,KAAKiO,IAAMjO,KAAKiO,GAAKjO,KAAKiO,IAAM,EAAI,GAC7D,MAAM,GAAN,OAAUjO,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkG2D,EAAlG,YAAwGjO,KAAKkO,GAAK,KAAKlO,KAAKkO,GAAK,Q,KEdpHG,G,YAlBd,cAA+B,IAAjBzF,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,KAAM0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAWxB,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IACVjB,EAAqB,cAAdhG,KAAKkB,KAAuBlB,KAAKiO,GAAIlH,EAAI/G,KAAKiO,IACzDhH,EAAIrG,GAAmB,cAAdZ,KAAKkB,KAAuB+F,EAAIrG,GAAKoF,EAAOA,M,GAvBtCsI,IC6BFC,G,YApBd,cAA+B,IAAjB3F,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,OAAQ0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAW1B,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IACVjB,EAAqB,cAAdhG,KAAKkB,KAAuBlB,KAAKiO,GAAIlH,EAAI/G,KAAKiO,IACrDjD,EAAuB,YAAdhL,KAAKkB,KAAqB6F,EAAI/G,KAAKkO,IAAM,EACtDjH,EAAIkE,KAAOnF,EACXiB,EAAIrG,GAAKoF,EAAOgF,M,GAzBCsD,IC6BJE,G,YApBd,cAA+B,IAAjB5F,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,SAAU0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAW5B,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IACVjB,EAAqB,cAAdhG,KAAKkB,KAAuBlB,KAAKiO,GAAIlH,EAAI/G,KAAKiO,IACrDjD,EAAuB,YAAdhL,KAAKkB,KAAqB6F,EAAI/G,KAAKkO,IAAM,EACtDjH,EAAIkE,KAAOnF,EACXiB,EAAIrG,GAAKoF,EAAOgF,M,GAzBGsD,IC2BNG,G,YAlBd,cAA+B,IAAjB7F,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,OAAQ0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAW1B,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IACVjB,EAAqB,cAAdhG,KAAKkB,KAAuBlB,KAAKiO,GAAIlH,EAAI/G,KAAKiO,IACzDhH,EAAIrG,GAAoB,cAAdZ,KAAKkB,KAAuB+F,EAAIrG,GAAKoF,EAAOA,M,GAvBrCsI,IC8BJI,G,YArBd,cAA+B,IAAjB9F,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,OAAQ0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAW1B,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IACVjB,EAAqB,cAAdhG,KAAKkB,KAAuBlB,KAAKiO,GAAIlH,EAAI/G,KAAKiO,IACzDlH,EAAI4H,GAAK1H,EAAIkE,KACbpE,EAAI6H,GAAK3H,EAAIrG,GACbqG,EAAIkE,KAAOnF,EACXiB,EAAIrG,GAAKoF,M,GA1BQsI,IC8BJO,G,YArBd,cAA+B,IAAjBjG,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,SAAU0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAW5B,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IACVjB,EAAqB,cAAdhG,KAAKkB,KAAuBlB,KAAKiO,GAAKlH,EAAI/G,KAAKiO,IAC1DlH,EAAI4H,GAAK1H,EAAIkE,KACbpE,EAAI6H,GAAK3H,EAAIrG,GACbqG,EAAIkE,KAAOnF,EACXiB,EAAIrG,GAAKoF,M,GA1BUsI,IC4BNQ,G,YAnBd,cAA+B,IAAjBlG,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,MAAO0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAWzB,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IAEdA,EAAIkE,KAAOpE,EAAI4H,GACf1H,EAAIrG,GAAKmG,EAAI6H,GAAK,M,GAxBFN,IC4BHS,G,YAnBd,cAA+B,IAAjBnG,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,QAAS0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAW3B,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IAEdA,EAAIkE,KAAOpE,EAAI4H,GACf1H,EAAIrG,GAAKmG,EAAI6H,GAAK,M,GAxBAN,IC8BLU,G,YArBd,cAA+B,IAAjBpG,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,OAAQ0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAW1B,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IACVjB,EAAO,WAAahG,KAAKiO,GAC7BlH,EAAIkI,GAAKhI,EAAIkE,KACbpE,EAAImI,IAAMjI,EAAIrG,GACdqG,EAAIkE,KAAOnF,EACXiB,EAAIrG,GAAKoF,M,GA1BQsI,IC4BJa,G,YAnBd,cAA+B,IAAjBvG,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,OAAQ0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAW1B,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IAEdA,EAAIkE,KAAOpE,EAAIkI,GACfhI,EAAIrG,GAAKmG,EAAImI,IAAM,M,GAxBFZ,IC4BJc,G,YAnBd,cAA+B,IAAjBxG,EAAgB,EAAhBA,KAAMqF,EAAU,EAAVA,GAAIC,EAAM,EAANA,GAAM,qEACvB,CAAE5D,KAAM,SAAU0D,EAAG,EAAG9D,GAAI,EAAMtB,OAAMqF,KAAIC,Q,wEAW5B,IAAbnH,EAAY,EAAZA,IAAKE,EAAO,EAAPA,IAEdA,EAAIkE,KAAOpE,EAAIkI,GACfhI,EAAIrG,GAAKmG,EAAImI,IAAM,M,GAxBAZ,IC2BNe,G,WAjBd,cAAgD,IAAlC/E,EAAiC,EAAjCA,KAAM1B,EAA2B,EAA3BA,KAAMoD,EAAqB,EAArBA,GAAIsD,EAAiB,EAAjBA,GAAIpO,EAAa,EAAbA,KAAMoL,EAAO,EAAPA,IAAO,oBAC9CtM,KAAKsK,KAAOA,EACZtK,KAAK4I,KAAOA,EACZ5I,KAAKgM,GAAKA,EACVhM,KAAKsP,GAAKA,EACVtP,KAAKkB,KAAOA,EACZlB,KAAKsM,IAAsB,IAAhBlK,EAASkK,GACpBtM,KAAKmG,OCtBoB,SAACyC,EAAMoD,EAAIsD,EAAIpO,EAAMoL,GAC/C,IAAInG,EAAS,CAAC,GAed,OAbAyC,EAAO7G,EAAS6G,GAChB0D,EAAMvK,EAASuK,GACfpL,EAAOa,EAASb,GAChB8K,EAAK9J,EAAS8J,GACdsD,EAAKpN,EAASoN,GAEdnJ,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,IAAW,GACxBA,EAAO,IAAM6F,GAAM,GACnB7F,EAAO,IAAMmJ,GAAM,GACnBnJ,EAAO,IAAMjF,GAAQ,EACrBiF,EAAO,IAAMmG,GAAO,EAEbnG,EDMQkG,CAAYzD,EAAMoD,EAAIsD,EAAIpO,EAAMoL,G,sDAI9C,MAAM,IAAII,MAAM,8BAA+B1M,Q,iCAG/C,MAAM,GAAN,OAAUA,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkGtK,KAAKgM,GAAvG,eAAgHhM,KAAKsP,GAArH,cAA6HtP,KAAKsM,IAAlI,S,KEKaiD,G,YApBd,cAAoC,IAAtB3G,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtCmD,EAAKzI,EAAID,EAAG,GAASyI,EAAU,GAC/BE,EAAK1I,EAAID,EAAG,GAASyI,EAAU,GAC/BG,EAAK3I,EAAID,EAAG,GAASyI,EAAU,GAC/BI,EAAK5I,EAAID,EAAG,GAASyI,EAAU,GAEnCzI,EAAI/G,KAAKgM,IAAOyD,GAAM,GAAOC,GAAM,GAAOC,GAAM,EAAKC,M,GAzBrCP,IC6BHQ,G,YApBd,cAAoC,IAAtBjH,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtCmD,EAAKzI,EAAIwI,EAAU,GACnBE,EAAK1I,EAAIwI,EAAU,GACnBG,EAAK3I,EAAIwI,EAAU,GACnBI,EAAK5I,EAAIwI,EAAU,GAEvBzI,EAAI/G,KAAKgM,IAAOyD,GAAM,GAAOC,GAAM,GAAOC,GAAM,EAAKC,M,GAzBrCP,IC6BHS,G,YApBd,cAAoC,IAAtBlH,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtCmD,EAAKzI,EAAIwI,EAAU,GACnBE,EAAK1I,EAAIwI,EAAU,GACnBG,EAAK3I,EAAIwI,EAAU,GACnBI,EAAK5I,EAAIwI,EAAU,GAEvBzI,EAAI/G,KAAKgM,IAAOyD,GAAM,GAAOC,GAAM,GAAOC,GAAM,EAAKC,M,GAzBrCP,IC6BHU,G,YApBd,cAAoC,IAAtBnH,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtCmD,EAAKzI,EAAIwI,EAAU,GACnBE,EAAK1I,EAAIwI,EAAU,GACnBG,EAAK3I,EAAIwI,EAAU,GACnBI,EAAK5I,EAAIwI,EAAU,GAEvBzI,EAAI/G,KAAKgM,IAAOyD,GAAM,GAAOC,GAAM,GAAOC,GAAM,EAAKC,M,GAzBrCP,IC2BHW,G,YAlBd,cAAoC,IAAtBpH,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtC2D,EAAKjJ,EAAID,EAAG,GAASyI,EAAU,GAC/BU,EAAKlJ,EAAID,EAAG,GAASyI,EAAU,GAEnCzI,EAAI/G,KAAKgM,KAASiE,GAAM,EAAKC,IAAO,IAAO,O,GAvB3Bb,IC2BHc,G,YAlBd,cAAoC,IAAtBvH,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtC2D,EAAKjJ,EAAIwI,EAAU,GACnBU,EAAKlJ,EAAIwI,EAAU,GAEvBzI,EAAI/G,KAAKgM,KAASiE,GAAM,EAAKC,IAAO,IAAO,O,GAvB3Bb,IC4BHe,G,YAnBd,cAAoC,IAAtBxH,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtC2D,EAAKjJ,EAAIwI,EAAU,GACnBU,EAAKlJ,EAAIwI,EAAU,GAEvBzI,EAAI/G,KAAKgM,KAASiE,GAAM,EAAKC,IAAO,IAAO,O,GAvB3Bb,IC2BHgB,G,YAlBd,cAAoC,IAAtBzH,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtC2D,EAAKjJ,EAAIwI,EAAU,GACnBU,EAAKlJ,EAAIwI,EAAU,GAEvBzI,EAAI/G,KAAKgM,KAASiE,GAAM,EAAKC,IAAO,IAAO,O,GAvB3Bb,ICwBHiB,G,YAfd,cAAoC,IAAtB1H,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACdD,EAAI/G,KAAKgM,IAAOhF,EAAID,EAAG,GAASA,EAAI/G,KAAKsP,IAAMtP,KAAKsM,MAAQ,IAAO,O,GAnBnD+C,ICuBHkB,G,YAdd,cAAoC,IAAtB3H,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,EAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACdD,EAAI/G,KAAKgM,IAAOhF,EAAID,EAAI/G,KAAKsP,IAAMtP,KAAKsM,MAAQ,IAAO,O,GAnBvC+C,ICwBHmB,G,YAdd,cAAoC,IAAtB5H,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACdD,EAAI/G,KAAKgM,IAAOhF,EAAID,EAAI/G,KAAKsP,IAAMtP,KAAKsM,MAAQ,IAAO,O,GApBvC+C,ICuBHoB,G,YAdd,cAAoC,IAAtB7H,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,MAAO1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACdD,EAAI/G,KAAKgM,IAAOhF,EAAID,EAAI/G,KAAKsP,IAAMtP,KAAKsM,MAAQ,IAAO,O,GAnBvC+C,IC2BHqB,G,YAlBd,cAAoC,IAAtB9H,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,OAAQ1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ7B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtC2D,EAAKjJ,EAAID,EAAG,GAASyI,EAAU,GAC/BU,EAAKlJ,EAAID,EAAG,GAASyI,EAAU,GAEnCzI,EAAI/G,KAAKgM,IAAOiE,GAAM,EAAKC,M,GAvBVb,IC2BJsB,G,YAlBd,cAAoC,IAAtB/H,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,OAAQ1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ7B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtC2D,EAAKjJ,EAAIwI,EAAU,GACnBU,EAAKlJ,EAAIwI,EAAU,GAEvBzI,EAAI/G,KAAKgM,IAAOiE,GAAM,EAAKC,M,GAvBVb,IC2BJuB,G,YAlBd,cAAoC,IAAtBhI,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,OAAQ1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ7B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtC2D,EAAKjJ,EAAIwI,EAAU,GACnBU,EAAKlJ,EAAIwI,EAAU,GAEvBzI,EAAI/G,KAAKgM,IAAOiE,GAAM,EAAKC,M,GAvBVb,IC2BJwB,G,YAlBd,cAAoC,IAAtBjI,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAEhC,KAAM,OAAQ1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ7B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVwI,EAAUzI,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACtC2D,EAAKjJ,EAAIwI,EAAU,GACnBU,EAAKlJ,EAAIwI,EAAU,GAEvBzI,EAAI/G,KAAKgM,IAAOiE,GAAM,EAAKC,M,GAvBVb,ICuBJyB,G,YAdd,cAAoC,IAAtBlI,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,OAAQ1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACdD,EAAI/G,KAAKgM,IAAiD,IAA3ChF,EAAID,EAAG,GAASA,EAAI/G,KAAKsP,IAAMtP,KAAKsM,S,GAnBlC+C,ICuBJ0B,G,YAdd,cAAoC,IAAtBnI,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,OAAQ1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACdD,EAAI/G,KAAKgM,IAAqC,IAA/BhF,EAAID,EAAI/G,KAAKsP,IAAMtP,KAAKsM,S,GAnBtB+C,ICuBJ2B,G,YAdd,cAAoC,IAAtBpI,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,OAAQ1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACdD,EAAI/G,KAAKgM,IAAqC,IAA/BhF,EAAID,EAAI/G,KAAKsP,IAAMtP,KAAKsM,S,GAnBtB+C,ICuBJ4B,G,YAdd,cAAoC,IAAtBrI,EAAqB,EAArBA,KAAMoD,EAAe,EAAfA,GAAIsD,EAAW,EAAXA,GAAIhD,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,OAAQ1B,OAAMoD,KAAIsD,KAAIpO,KAAM,GAASoL,S,wEAQ5B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACdD,EAAI/G,KAAKgM,IAAqC,IAA/BhF,EAAID,EAAI/G,KAAKsP,IAAMtP,KAAKsM,S,GAnBtB+C,ICyBJ6B,G,WAjBd,cAA6C,IAA/B5G,EAA8B,EAA9BA,KAAM1B,EAAwB,EAAxBA,KAAMqD,EAAkB,EAAlBA,IAAKG,EAAa,EAAbA,IAAKL,EAAQ,EAARA,KAAQ,oBAC3C/L,KAAKsK,KAAOA,EACZtK,KAAK4I,KAAOA,EACZ5I,KAAKiM,IAAMA,EACXjM,KAAKoM,IAAMA,EACXpM,KAAK+L,KAAOA,EACZ/L,KAAKmG,OCnBoB,SAACyC,EAAMqD,EAAKG,EAAKL,GAC3C,IAAI5F,EAAS,CAAC,GAcd,OAZAyC,EAAO7G,EAAS6G,GAChBmD,EAAOhK,EAASgK,GAChBE,EAAM/J,EAAS+J,GACfG,EAAMlK,EAASkK,GAEfjG,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,GAAW,GACxBA,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,IAAMiG,GAAO,EACpBjG,EAAO,IAAM,GACbA,EAAO,IAAM4F,GAAQ,EAEd5F,EDIQkG,CAAYzD,EAAMqD,EAAKG,EAAKL,G,sDAI1C,MAAM,IAAIW,MAAM,8BAA+B1M,Q,iCAI/C,MAAM,GAAN,OAAUA,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkGtK,KAAKiM,IAAvG,aAA+GjM,KAAKoM,S,KECvG+E,G,YAfd,cAAiC,IAAnBvI,EAAkB,EAAlBA,KAAMqD,EAAY,EAAZA,IAAKG,EAAO,EAAPA,IAAO,qEACzB,CAAC9B,KAAM,MAAOyB,KAAM,EAAQnD,OAAMqD,MAAKG,S,wEAQ1B,IAATrF,EAAQ,EAARA,IACVA,EAAG,GAASxD,KAAK6N,KAAKrK,EAAI/G,KAAKiM,KAAMlF,EAAI/G,KAAKoM,MAC9CrF,EAAG,GAAUA,EAAI/G,KAAKiM,KAAOlF,EAAI/G,KAAKoM,KAAzB,SAAiC,EAAG,IAAO,M,GAnBxC8E,ICuBHG,G,YAfd,cAAiC,IAAnBzI,EAAkB,EAAlBA,KAAMqD,EAAY,EAAZA,IAAKG,EAAO,EAAPA,IAAO,qEACzB,CAAC9B,KAAM,OAAQyB,KAAM,EAAQnD,OAAMqD,MAAKG,S,wEAQ3B,IAATrF,EAAQ,EAARA,IACVA,EAAG,GAASxD,KAAK6N,KAAKrK,EAAI/G,KAAKiM,KAAMlF,EAAI/G,KAAKoM,MAC9CrF,EAAG,IAAYA,EAAI/G,KAAKiM,OAAS,IAAMlF,EAAI/G,KAAKoM,OAAS,GAA5C,SAAiD,EAAG,MAAO,M,GAnBvD8E,IC8BJI,G,WArBd,cAAiD,IAAnChH,EAAkC,EAAlCA,KAAM1B,EAA4B,EAA5BA,KAAM2E,EAAsB,EAAtBA,GAAIgE,EAAkB,EAAlBA,IAAKC,EAAa,EAAbA,IAAKzF,EAAQ,EAARA,KAAQ,oBAC/C/L,KAAKsK,KAAOA,EACZtK,KAAK4I,KAAOA,EACZ5I,KAAKuN,GAAKA,EACVvN,KAAKyR,KAAkB,MAAXF,EAAI,GAChBvR,KAAK0R,KAAkB,MAAXF,EAAI,GAChBxR,KAAKuR,IAAMA,EAAII,QAAQ,IAAK,IAC5B3R,KAAKwR,IAAMA,EAAIG,QAAQ,IAAK,IAC5B3R,KAAK+L,KAAOA,EACZ/L,KAAKmG,OCvBoB,SAACyC,EAAM2E,EAAIgE,EAAKC,EAAKzF,GAC/C,IAAI5F,EAAS,CAAC,GAgBd,OAdAyC,EAAO7G,EAAS6G,GAChBmD,EAAOhK,EAASgK,GAChBwB,EAAKrL,EAASqL,GACdgE,EAAiB,MAAXA,EAAI,GAAa,EAASrP,EAASqP,GAAOrP,EAASqP,GACzDC,EAAiB,MAAXA,EAAI,GAAa,EAAStP,EAASsP,GAAOtP,EAASsP,GAEzDrL,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,GAAW,GACxBA,EAAO,IAAMoH,GAAM,GACnBpH,EAAO,IAAMoL,GAAO,GACpBpL,EAAO,IAAMqL,GAAO,EACpBrL,EAAO,IAAM,GACbA,EAAO,IAAM4F,GAAQ,EAEd5F,EDMQkG,CAAYzD,EAAM2E,EAAIgE,EAAKC,EAAKzF,G,sDAI9ClB,QAAQlE,MAAM,8BAA+B3G,Q,iCAI7C,MAAM,GAAN,OAAUA,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkGtK,KAAKuN,GAAvG,cAA+GvN,KAAKyR,KAAO,IAAM,IAAjI,OAAsIzR,KAAKuR,IAA3I,aAAmJvR,KAAK0R,KAAO,IAAM,IAArK,OAA0K1R,KAAKwR,S,KEHlKI,G,YAdd,cAAqC,IAAvBhJ,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAIgE,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAClH,KAAM,OAAQ1B,OAAM2E,KAAIgE,MAAKC,MAAKzF,KAAK,K,wEAQ3B,IAAThF,EAAQ,EAARA,IACVA,EAAI/G,KAAKuN,KAAQvN,KAAKyR,MAAQ1K,EAAI/G,KAAKuR,KAAOxK,EAAI/G,KAAKuR,OAASvR,KAAK0R,MAAQ3K,EAAI/G,KAAKwR,KAAOzK,EAAI/G,KAAKwR,MAAS,M,GAnB9FF,ICuBJO,G,YAdd,cAAqC,IAAvBjJ,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAIgE,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAClH,KAAM,OAAQ1B,OAAM2E,KAAIgE,MAAKC,MAAKzF,KAAK,M,wEAQ3B,IAAThF,EAAQ,EAARA,IACVA,EAAI/G,KAAKuN,IAAsG,IAA9FvN,KAAKyR,MAAQ1K,EAAI/G,KAAKuR,KAAOxK,EAAI/G,KAAKuR,OAASvR,KAAK0R,MAAQ3K,EAAI/G,KAAKwR,KAAOzK,EAAI/G,KAAKwR,W,GAnBrFF,ICuBJQ,G,YAdd,cAAqC,IAAvBlJ,EAAsB,EAAtBA,KAAM2E,EAAgB,EAAhBA,GAAIgE,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IAAO,qEAC7B,CAAClH,KAAM,MAAO1B,OAAM2E,KAAIgE,MAAKC,MAAKzF,KAAK,K,wEAQ1B,IAAThF,EAAQ,EAARA,IACVA,EAAI/G,KAAKuN,IAAsG,IAA9FvN,KAAKyR,MAAQ1K,EAAI/G,KAAKuR,KAAOxK,EAAI/G,KAAKuR,OAASvR,KAAK0R,MAAQ3K,EAAI/G,KAAKwR,KAAOzK,EAAI/G,KAAKwR,W,GAnBtFF,IC+BHS,G,WAxBd,cAAqC,IAAvBzH,EAAsB,EAAtBA,KAAM1B,EAAgB,EAAhBA,KAAMsB,EAAU,EAAVA,GAAI+D,EAAM,EAANA,GAAM,oBACnCjO,KAAKkB,KAAOiL,MAAM8B,GAAM,IAAM,IAC9BjO,KAAKsK,KAAOA,EACZtK,KAAK4I,KAAOA,EACZ5I,KAAKkK,GAAKA,EACVlK,KAAKiO,GAAKA,EAEQ,MAAdjO,KAAKkB,KACRlB,KAAKmG,OCpBmB,SAACyC,EAAMsB,EAAI8H,GACrC,IAAI7L,EAAS,CAAC,GAYd,OAVAyC,EAAO7G,EAAS6G,GAChBsB,EAAKnI,EAASmI,GACd8H,EAAK9P,EAAS8P,GAEd7L,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,IAAW,GACxBA,EAAO,IAAM+D,GAAM,GACnB/D,EAAO,IAAM,GAAQ,GACrBA,EAAO,IAAM6L,GAAM,GAEZ7L,EDOSkG,CAAYzD,EAAMsB,EAAI+D,IAEpCjO,KAAKiO,IAAM,OACXjO,KAAKmG,OCPmB,SAACyC,EAAMsB,EAAIoC,GACrC,IAAInG,EAAS,CAAC,GAYd,OAVAyC,EAAO7G,EAAS6G,GAChBsB,EAAKnI,EAASmI,GACdoC,EAAMvK,EAASuK,GAEfnG,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,IAAW,GACxBA,EAAO,IAAM+D,GAAM,GACnB/D,EAAO,IAAM,EACbA,EAAO,IAAMmG,GAAO,EAEbnG,EDNSoG,CAAY3D,EAAMsB,EAAI+D,I,sDAKrC,MAAM,IAAIvB,MAAM,wB,iCAIhB,MAAM,GAAN,OAAU1M,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkGtK,KAAKiO,Q,KEK1FgE,G,YAzBd,cAA2B,IAAbrJ,EAAY,EAAZA,KAAMqF,EAAM,EAANA,GAAM,qEACnB,CAAC3D,KAAM,OAAQ1B,OAAMsB,GAAI,EAAM+D,Q,wEAQpB,IAARlH,EAAO,EAAPA,IACL1E,EAAIJ,OAAqB,MAAdjC,KAAKkB,KAAe6F,EAAI/G,KAAKiO,IAAMjO,KAAKiO,IAAM,GAC7DlH,EAAG,GAASxD,KAAK2O,IAAInL,EAAG,GAAQA,EAAG,GAAS1E,O,GAlB3B0P,IC0BJI,G,YAnBd,cAA2B,IAAbvJ,EAAY,EAAZA,KAAMqF,EAAM,EAANA,GAAM,qEACnB,CAAC3D,KAAM,QAAS1B,OAAMsB,GAAI,EAAM+D,Q,wEAQrB,IAARlH,EAAO,EAAPA,IAETA,EAAG,IAAU9E,OAAOjC,KAAKiO,KAAO,EAE7BlH,EAAG,GAASA,EAAG,KACjBA,EAAG,GAASA,EAAG,Q,GArBEgL,IC4BLK,G,YArBd,cAA2B,IAAbxJ,EAAY,EAAZA,KAAMqF,EAAM,EAANA,GAAM,qEACnB,CAAC3D,KAAM,OAAQ1B,OAAMsB,GAAI,EAAM+D,Q,wEAQb,EAAflH,IAEN,IAAU9E,OAAOjC,KAAKiO,KAAO,M,GAlBf8D,ICuBJM,G,YAhBd,cAA2B,IAAbzJ,EAAY,EAAZA,KAAMqF,EAAM,EAANA,GAAM,qEACnB,CAAC3D,KAAM,SAAU1B,OAAMsB,GAAI,EAAM+D,Q,wEAQrB,IAATlH,EAAQ,EAARA,IACL1E,EAAIJ,OAAqB,MAAdjC,KAAKkB,KAAe6F,EAAI/G,KAAKiO,IAAMjO,KAAKiO,IAAM,GAC7DlH,EAAG,IAAU1E,M,GAlBM0P,IC4BNO,G,WAnBd,cAAgD,IAAlChI,EAAiC,EAAjCA,KAAM1B,EAA2B,EAA3BA,KAAM1H,EAAqB,EAArBA,KAAMoO,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,oBAC9CtM,KAAKsK,KAAOA,EACZtK,KAAK4I,KAAOA,EACZ5I,KAAKkB,KAAOA,EACZlB,KAAKsP,GAAKA,EACVtP,KAAKgS,GAAKA,EACVhS,KAAKsM,IAAsB,IAAhBlK,EAASkK,GACpBtM,KAAKmG,OCrBoB,SAACyC,EAAM1H,EAAMoO,EAAI0C,EAAIhH,GAC/C,IAAI7E,EAAS,CAAC,GAed,OAbAyC,EAAO7G,EAAS6G,GAChB1H,EAAOa,EAASb,GAChBoO,EAAKpN,EAASoN,GACd0C,EAAK9P,EAAS8P,GACdhH,EAASjJ,EAASiJ,GAElB7E,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,IAAW,GACxBA,EAAO,IAAMjF,GAAQ,GACrBiF,EAAO,IAAMmJ,GAAM,GACnBnJ,EAAO,IAAM6L,GAAM,EACnB7L,EAAO,IAAM6E,GAAU,EAEhB7E,EDKQkG,CAAYzD,EAAM1H,EAAMoO,EAAI0C,EAAI1F,G,sDAI9C,MAAM,IAAII,MAAM,8BAA+B1M,Q,iCAI/C,MAAM,GAAN,OAAUA,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,aAAmGtK,KAAKsP,GAAxG,cAAgHtP,KAAKsM,IAArH,eAA+HtM,KAAKgS,Q,KEAvHO,G,YAfd,cAAoC,IAAtB3J,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,GAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAY,EAAPC,IACHD,EAAI/G,KAAKsP,IAAOtP,KAAKsM,KACH,IAAhBvF,EAAI/G,KAAKgS,Q,GApBNM,ICwBHE,G,YAfd,cAAoC,IAAtB5J,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAY,EAAPC,IACHD,EAAI/G,KAAKsP,IAAOtP,KAAKsM,KACH,IAAhBvF,EAAI/G,KAAKgS,Q,GApBNM,ICwBHG,G,YAfd,cAAoC,IAAtB7J,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,GAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAY,EAAPC,IACHD,EAAI/G,KAAKsP,IAAOtP,KAAKsM,KACH,IAAhBvF,EAAI/G,KAAKgS,Q,GApBNM,ICwBHI,G,YAfd,cAAoC,IAAtB9J,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAY,EAAPC,IACHD,EAAG,GAASA,EAAI/G,KAAKsP,IAAOtP,KAAKsM,KACb,IAAhBvF,EAAI/G,KAAKgS,Q,GApBRM,ICyBHK,G,YAhBd,cAAoC,IAAtB/J,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVhB,EAAOe,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACvCtF,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,EAAK,IACpChL,EAAIhB,EAAK,GAAsB,IAAhBe,EAAI/G,KAAKgS,Q,GArBRM,ICyBHM,G,YAhBd,cAAoC,IAAtBhK,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVhB,EAAOe,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACvCtF,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,EAAK,IACpChL,EAAIhB,EAAK,GAAsB,IAAhBe,EAAI/G,KAAKgS,Q,GArBRM,ICyBHO,G,YAhBd,cAAoC,IAAtBjK,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVhB,EAAOe,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACvCtF,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,EAAK,IACpChL,EAAIhB,EAAK,GAAsB,IAAhBe,EAAI/G,KAAKgS,Q,GArBRM,ICyBHQ,G,YAhBd,cAAoC,IAAtBlK,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVhB,EAAOe,EAAG,GAASA,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACnDtF,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,EAAK,IACpChL,EAAIhB,EAAK,GAAsB,IAAhBe,EAAI/G,KAAKgS,Q,GArBRM,IC2BHS,G,YAlBd,cAAoC,IAAtBnK,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVhB,EAAOe,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACvCtF,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,GAAM,IACrChL,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,GAAM,IACrChL,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,EAAK,IACpChL,EAAIhB,EAAK,GAAsB,IAAhBe,EAAI/G,KAAKgS,Q,GAvBRM,IC2BHU,G,YAlBd,cAAoC,IAAtBpK,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVhB,EAAOe,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACvCtF,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,GAAM,IACrChL,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,GAAM,IACrChL,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,EAAK,IACpChL,EAAIhB,EAAK,GAAsB,IAAhBe,EAAI/G,KAAKgS,Q,GAvBRM,IC2BHW,G,YAlBd,cAAoC,IAAtBrK,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVhB,EAAOe,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACvCtF,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,GAAM,IACrChL,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,GAAM,IACrChL,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,EAAK,IACpChL,EAAIhB,EAAK,GAAsB,IAAhBe,EAAI/G,KAAKgS,Q,GAvBRM,IC2BHY,G,YAlBd,cAAoC,IAAtBtK,EAAqB,EAArBA,KAAM0G,EAAe,EAAfA,GAAI0C,EAAW,EAAXA,GAAI1F,EAAO,EAAPA,IAAO,qEAC5B,CAAChC,KAAM,MAAO1B,OAAM1H,KAAM,EAASoO,KAAI0C,KAAI1F,S,wEAQ3B,IAAbvF,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACVhB,EAAOe,EAAG,GAASA,EAAI/G,KAAKsP,KAAOtP,KAAKsM,KAAO,GACnDtF,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,GAAM,IACrChL,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,GAAM,IACrChL,EAAIhB,EAAK,GAAMe,EAAI/G,KAAKgS,KAAO,EAAK,IACpChL,EAAIhB,EAAK,GAAsB,IAAhBe,EAAI/G,KAAKgS,Q,GAvBRM,ICuDHa,G,WA1Bd,cAAuC,IAA1BvK,EAAyB,EAAzBA,KAAMoD,EAAmB,EAAnBA,GAAIC,EAAe,EAAfA,IAAKK,EAAU,EAAVA,IAAK8G,EAAK,EAALA,GAAK,oBACrCpT,KAAKsK,KAAO,QACZtK,KAAK4I,KAAOA,EACZ5I,KAAKgM,GAAKA,EACVhM,KAAKiM,IAAMA,EACXjM,KAAKsM,IAAY,GAANA,EACXtM,KAAKoT,GAAKA,EACVpT,KAAKmG,OAzCoB,SAACyC,EAAMoD,EAAIC,EAAKK,EAAK8G,GAC/C,IAAIjN,EAAS,CAAC,GAgBd,OAdAyC,EAAO7G,EAAS6G,GAChB0D,EAAMvK,EAASuK,GACfN,EAAK9J,EAAS8J,GACdC,EAAM/J,EAAS+J,GACfmH,EAAe,MAAVA,EAAG,GAAa,EAASlR,EAASkR,GAAMlR,EAASkR,GAEtDjN,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,GAAW,GACxBA,EAAO,IAAM6F,GAAM,GACnB7F,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,IAAMmG,GAAO,EACpBnG,EAAO,IAAM,GACbA,EAAO,IAAMiN,GAAM,EAEZjN,EAwBQkG,CAAYzD,EAAMoD,EAAIC,EAAKK,EAAK8G,G,uDAQ7B,IAARrM,EAAO,EAAPA,IACLsM,EAAwB,MAAfrT,KAAKoT,GAAG,MAAkD,IAAjCrM,EAAI/G,KAAKoT,GAAGzB,QAAQ,IAAI,MAAc,EAAI,EAChF5K,EAAI/G,KAAKgM,IAAOjF,EAAI/G,KAAKiM,OAAS,GAAKjM,KAAKsM,KAAS+G,GAASrT,KAAKsM,M,iCAInE,MAAM,GAAN,OAAUtM,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkGtK,KAAKgM,GAAvG,cAA+GhM,KAAKiM,IAApH,aAA4HjM,KAAKsM,IAAjI,aAAyItM,KAAKoT,Q,KCNjIE,G,WArBd,cAA6B,IAAhB1K,EAAe,EAAfA,KAAMoD,EAAS,EAATA,GAAI7C,EAAK,EAALA,GAAK,oBAC3BnJ,KAAKsK,KAAO,MACZtK,KAAK4I,KAAOA,EACZ5I,KAAKgM,GAAKA,EACVhM,KAAKmJ,GAAKA,EACVnJ,KAAKmG,OAjCoB,SAACyC,EAAMoD,EAAI7C,GACrC,IAAIhD,EAAS,CAAC,GAYd,OAVAyC,EAAO7G,EAAS6G,GAChBoD,EAAK9J,EAAS8J,GACd7C,EAAKjH,EAASiH,GAEdhD,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,GAAW,GACxBA,EAAO,IAAM6F,GAAM,GACnB7F,EAAO,IAAM,GACbA,EAAO,IAAMgD,GAAM,EAEZhD,EAoBQkG,CAAYzD,EAAMoD,EAAI7C,G,uDAQnB,IAARpC,EAAO,EAAPA,IACTA,EAAI/G,KAAKgM,IAAMjF,EAAI/G,KAAKmJ,M,iCAGxB,MAAM,GAAN,OAAUnJ,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkGtK,KAAKgM,GAAvG,cAA+GhM,KAAKmJ,Q,KCevGoK,G,WAhCd,cAA8B,IAAjB3K,EAAgB,EAAhBA,KAAMqD,EAAU,EAAVA,IAAKuH,EAAK,EAALA,GAAK,oBAC5BxT,KAAKsK,KAAO,MACZtK,KAAK4I,KAAOA,EACZ5I,KAAKiM,IAAMA,EACXjM,KAAKwT,GAAKA,EACVxT,KAAKmG,OAjCa,SAACyC,EAAMqD,EAAKuH,GAC/B,IAAIrN,EAAS,CAAC,GAYd,OAVAyC,EAAO7G,EAAS6G,GAChBqD,EAAM/J,EAAS+J,GACfuH,EAAKtR,EAASsR,GAEdrN,EAAO,IAAMyC,GAAQ,GACrBzC,EAAO,IAAM,GAAW,GACxBA,EAAO,IAAM8F,GAAO,GACpB9F,EAAO,IAAM,GACbA,EAAO,IAAMqN,GAAM,EAEZrN,EAoBQkG,CAAYzD,EAAMqD,EAAKuH,G,uDAQpB,IAARzM,EAAO,EAAPA,IACTA,EAAI/G,KAAKwT,IAAMzM,EAAI/G,KAAKiM,KACT,OAAZjM,KAAKwT,KACPzM,EAAI/G,KAAKwT,KAAO,IAChBzM,EAAG,GAAS,EACZA,EAAG,GAASA,EAAG,IAAU,EACzBA,EAAG,GAASA,EAAG,IAAU,EACzBA,EAAG,GAASA,EAAG,IAAU,EACzBA,EAAG,GAASA,EAAG,IAAU,EACzBA,EAAG,GAASA,EAAG,IAAU,EACzBA,EAAG,GAASA,EAAG,IAAU,EACzBA,EAAG,GAASA,EAAG,IAAU,K,iCAI1B,MAAM,GAAN,OAAU/G,KAAK4I,KAAL,WAA0B,EAAV5I,KAAK4I,KAAc,IAAM,GAAzC,YAAyD,EAAV5I,KAAK4I,KAApD,MAAsE,IAAhF,OAAqF5I,KAAKsK,KAA1F,YAAkGtK,KAAKwT,GAAvG,cAA+GxT,KAAKiM,S,KCvDhHwH,GAAQ,CAEb,MAAU,CAAC,qDAA2D,oBAGtE,IAAS,CAAC,wDAAiE,iBAC3E,KAAS,CAAC,wDAA8D,iBACxE,KAAS,CAAC,kDAA2D,mBACrE,MAAU,CAAC,gEAAoE,mBAC/E,IAAQ,CAAC,iCAA4C,YACrD,MAAU,CAAC,8BAA0C,OACrD,KAAS,CAAC,uCAAiD,iBAC3D,GAAO,CAAC,0BAAwC,SAChD,IAAQ,CAAC,6DAAiE,WAC1E,IAAQ,CAAC,6DAAiE,WAC1E,MAAU,CAAC,mEAAoE,uBAG/E,IAAQ,CAAC,iCAA6C,WACtD,KAAS,CAAC,uBAAsC,WAChD,MAAU,CAAC,4BAAyC,WACpD,IAAQ,CAAC,mBAAmC,SAC5C,IAAQ,CAAC,qCAA+C,YACxD,IAAQ,CAAC,qCAA+C,YACxD,GAAO,CAAC,yCAAkD,YAC1D,IAAS,CAAC,SAA0B,OACpC,KAAS,CAAC,mBAAkC,UAC5C,KAAS,CAAC,2BAAwC,YAClD,KAAS,CAAC,qBAAmC,WAQxCC,GAAW,SAACxS,GACjB,YAAiCiE,IAA7BsO,GAAMvL,GAAYhH,KAA+B,EAC9CuS,GAAMvL,GAAYhH,IAAO,IAG3ByS,GAAgB,SAACzS,GACtB,YAAiCiE,IAA7BsO,GAAMvL,GAAYhH,KAA+B,EAC/C,eAAN,OAAsBA,EAAtB,+BAAiDuS,GAAMvL,GAAYhH,IAAO,KCsf5D0S,G,WAphBd,aAAe,IAAD,gCAwMdC,WAAa,SAACC,GAGb,IAFA,IAAIC,EAAQD,EAAOnC,QAAQ,MAAO,KAAKqC,MAAM,aACzCC,EAAS,GACJjW,EAAI,EAAGA,EAAI+V,EAAMnS,SAAU5D,EAGnC,IAFA,IAAIkW,EAAOH,EAAM/V,GAAGgW,MAAM,IAAK,GAAG,GAAGG,OACjCC,EAAQF,EAAKF,MAAM,KACdK,EAAI,EAAGA,EAAID,EAAMxS,SAAUyS,EAAE,CACrC,IAAIC,EAAaF,EAAMC,GAAGlS,MAAM,UAC5B+R,IACCI,GAActW,EAAI,EAAI+V,EAAMnS,OAC/BmS,EAAM/V,EAAI,GAAKsW,EAAW,GAAK,IAAMP,EAAM/V,EAAI,IACpCsW,GAAcF,EAAMC,IAC/BJ,EAAOvP,KAAK0P,EAAMC,IAEnB,EAAKzN,OAAOqN,EAAOrS,OAAO,GAAK5D,EAAE,GAIpC,OAAOiW,GAzNPjU,KAAKW,QAAU,GACfX,KAAKuU,OAAS,GACdvU,KAAKgL,OAAS,EACdhL,KAAK2G,MAAQ,GACb3G,KAAK4G,OAAS,G,oDAId5G,KAAKW,QAAU,GACfX,KAAKuU,OAAS,GACdvU,KAAKgL,OAAS,EACdhL,KAAK2G,MAAQ,GACb3G,KAAK4G,OAAS,K,0BAIXkN,GACH9T,KAAK2J,QACL,IAAI3H,EAAQhC,KAAK6T,WAAWC,GAFjB,uBAGX,YAAiB9R,EAAjB,oDAASkS,EAAT,QACClU,KAAKwU,MAAMN,IAJD,6GAKX,YAAmBlU,KAAKW,QAAxB,+CAAiC,CAAC,IAAzBoF,EAAwB,QAC7B/F,KAAKyU,gBAAgB1O,IACvB/F,KAAK0U,cAAc3O,IAPV,kFASX,OAAO/F,KAAK2U,a,iCAKZ,IAAK,IAAI/P,KAAO5E,KAAK2G,MACpB,GAAwB,SAApB3G,KAAK2G,MAAM/B,GAAiB,OAAO,EAExC,OADA5E,KAAK2G,MAAQ,IACN,I,4BAGFuN,GAAO,IAAD,OACX,GAAG,SAAStV,KAAKsV,GAAO,OAAO,EAC/B,IAAIE,EAAQF,EAAKF,MAAM,MACnBjO,EAAS,CAAEkF,SAAS,EAAOC,KAAM,KAAMF,OAAQhL,KAAKgL,OAAQI,aAAc,GAAIE,KAAM,GACpF5F,EAAM1F,KAAKW,QAAQ+D,KAAKqB,GAAU,EAIlC6O,EAAUV,EAAK/R,MAAM,2CACzB,GAAGyS,EAKF,OAJA7O,EAAOkF,SAAU,EACjBlF,EAAOmF,KAAO,CAAChK,KAAM,OAAQb,MAAOuU,EAAQ,IACzCA,EAAQ,KAAI5U,KAAKuU,OAAOK,EAAQ,IAAMlP,GACzC1F,KAAKgL,QAAU,GACR,EAGR,GAAIoJ,EAAMxS,OAAS,EAElB,OADA5B,KAAK2G,MAAMjB,GAAO,6CACX,EAnBG,eAsBF2O,GACR,IAAIhK,EAAO+J,EAAMC,GAIblS,GAHJkI,EAAOA,EAAK8J,QAGKhS,MAAMuR,GAAS,UAChC,IAAKvR,EAEJ,OADA,EAAKwE,MAAMjB,GAAOiO,GAAc,SAC1B,CAAN,GAAO,GAER,IAAIkB,EAAQ1S,EAAM,GACd2S,EAAmB,MAAb3S,EAAM,GACZyG,EAAOzG,EAAM,GAAKF,OAAOE,EAAM,GAAG4S,cAAcpD,QAAQ,IAAK,KAAO,EACpEzQ,EAAOiB,EAAM,GAAG4S,cAKpB,GAJa,SAAT7T,IAAiBA,EAAO,OAC5BiB,EAAQkI,EAAKsH,QAAQxP,EAAM,GAAI,IAAIA,MAAMuR,GAASxS,KAG7C/C,EAAUmK,SAASpH,GAEvB,OADA,EAAKyF,MAAMjB,GAAX,UAAqBxE,EAArB,0BACM,CAAN,GAAO,GACD,IAAKiB,EAEX,OADA,EAAKwE,MAAMjB,GAAOiO,GAAczS,GAC1B,CAAN,GAAO,GAIR,GAAIqG,EAAYe,SAASpH,GAAO,CAC/B,IAAI8T,EAAQ9T,EAAKuB,cACjB,OAAQuS,GACP,IAAK,KACA/S,OAAOE,EAAM,GAAK,IACrB6S,EAAQ,SACR7S,EAAM,IAAMA,EAAM,IAElB6S,EAAQ,SAET,MACD,IAAK,MACJA,GAAUlM,GAAOR,SAASnG,EAAM,IAAO,KAAO,KAC9C6S,GAAUlM,GAAOR,SAASnG,EAAM,IAAO,IAAM,IAM/C,IAAI8S,EAAQhN,GAAc+M,GAAOrD,QAAQ,YAAY,SAACuD,EAAG7S,GAAJ,OAAUF,EAAME,MAErEnB,GADAiB,EAAQ8S,EAAM9S,MAAMuR,GAAS,WAChB,GAAGqB,cAChB5S,EAAQ8S,EAAMtD,QAAQxP,EAAM,GAAI,IAAIA,MAAMuR,GAASxS,IAIpD,IAAIlD,EAAI,CAAE4K,KAAM,CAAEuM,EAAGvM,EAAMvG,EAAGyS,GAAO5T,OAAM+I,IAAK9H,EAAMiT,MAAM,GAAIhP,SAAUiE,EAAKsH,QAAQ,QAAS,MAC5F0D,EAAe7N,EAASc,SAASpH,IAASe,OAAOjE,EAAEiM,IAAI,MAAShI,OAAOjE,EAAEiM,IAAI,IAAM,MAAU,CAAC,MAAO,QAAS,UAAU3B,SAASpH,IAGrI,GAAqB,IAAjBkT,EAAMxS,OAAc,CACvB,GAAIyT,EAEH,OADA,EAAK1O,MAAMjB,GAAO,uDACZ,CAAN,GAAO,GACD,GAAU,IAAN2O,I7FnEY,SAACnT,GAC3B,OAAOsG,EAASc,SAASpH,IAASuG,EAAUa,SAASpH,G6FkE3BoU,CAAmBpU,GAEzC,OADA,EAAKyF,MAAMjB,GAAX,UAAqBxE,EAArB,+BACM,CAAN,GAAO,GAIL2T,IAAO,EAAKN,OAAOM,GAASnP,GAChCK,EAAOqF,aAAa1G,KAAK1G,GACzB+H,EAAM,MAAYsP,EAAc,EAAI,GArErC,IAAK,IAAIhB,KAAKD,EAAO,CAAC,IAAD,IAAZC,GAAY,kCAwErB,OADArU,KAAKgL,QAAUjF,EAAM,MACd,I,sCAGQA,GACf,IAAIL,EAAMK,EAAOiF,OAAO,EAExB,GAAGjF,EAAOkF,QAAQ,CACjB,IAAIsK,EAAQxP,EAAOmF,KAAK7K,MAAM8B,MAAM,uBAEpC,GAAI8C,OAAOkD,KAAKnI,KAAKuU,QAAQjM,SAASvC,EAAOmF,KAAK7K,OACjD0F,EAAOmF,KAAK7K,MAAQL,KAAKW,QAAQX,KAAKuU,OAAOxO,EAAOmF,KAAK7K,QAAQ2K,YAC3D,GAAIuK,GAAStQ,OAAOkD,KAAKnI,KAAKuU,QAAQjM,SAASiN,EAAM,KAAOtQ,OAAOkD,KAAKnI,KAAKuU,QAAQjM,SAASiN,EAAM,IAAI,CAC9G,IAAIC,EAAKxV,KAAKW,QAAQX,KAAKuU,OAAOgB,EAAM,KAAKvK,OACzCyK,EAAKzV,KAAKW,QAAQX,KAAKuU,OAAOgB,EAAM,KAAKvK,OAC7CjF,EAAOmF,KAAK7K,MAAqB,MAAbkV,EAAM,GAAaC,EAAKC,EAAID,EAAKC,OAErD1P,EAAOmF,KAAK7K,MAAQ4B,OAAO8D,EAAOmF,KAAK7K,OAblB,2BAiBvB,YAAwB0F,EAAOqF,aAA/B,+CAA6C,CAAC,IAArClF,EAAoC,QAC5C,IAAK,IAAIlI,KAAKkI,EAAY+D,IAAK,CAC9B,IAAIC,EAAKhE,EAAY+D,IAAIjM,GACrB0X,EAAQxL,EAAG6K,cACXQ,EAAQrL,EAAG/H,MAAM,uBACrB,GAAI6G,GAAQ0M,GACXxP,EAAY+D,IAAIjM,GAAKgL,GAAQ0M,QACvB,GAAI3M,GAAUT,SAASoN,GAC7BxP,EAAY+D,IAAIjM,GAAK0X,OACf,GAAIzQ,OAAOkD,KAAKnI,KAAKuU,QAAQjM,SAAS4B,IAAQqL,GAAStQ,OAAOkD,KAAKnI,KAAKuU,QAAQjM,SAASiN,EAAM,KAAOtQ,OAAOkD,KAAKnI,KAAKuU,QAAQjM,SAASiN,EAAM,IAAM,CAC1J,IAAII,OAAM,EACV,GAAGJ,EAAM,CACR,IAAIC,EAAKxV,KAAKW,QAAQX,KAAKuU,OAAOgB,EAAM,KAAKvK,OACzCyK,EAAKzV,KAAKW,QAAQX,KAAKuU,OAAOgB,EAAM,KAAKvK,OAC7C2K,EAAsB,MAAbJ,EAAM,GAAaC,EAAKC,EAAID,EAAKC,OAE1CE,EAAS3V,KAAKW,QAAQX,KAAKuU,OAAOrK,IAAKc,OAExC,GAAGjD,EAAQO,SAASpC,EAAYhF,MAC5B,CAAC,KAAM,QAAQoH,SAASpC,EAAYhF,MACtCgF,EAAY+D,IAAIjM,GAAK4X,OAAQD,EAAO5P,EAAOiF,QAAW,GAEtD9E,EAAY+D,IAAIjM,GAAK4X,OAAOD,GAAU,QAEjC,GAAGjO,EAAUY,SAASpC,EAAYhF,MAAM,CAC9C,IAAImS,EAAQ,EACTnN,EAAYhF,KAAKoH,SAAS,KAC5B+K,EAAQ,EACDnN,EAAYhF,KAAKoH,SAAS,OACjC+K,EAAQ,GACTnN,EAAY+D,IAAIjM,GAAK4X,OAAOD,GAAUtC,QAGtCnN,EAAY+D,IAAIjM,GAAK4X,OAAOD,QAEvB,GAAIxJ,MAAMjC,GAEhB,OADAlK,KAAK2G,MAAMjB,GAAO,0BACX,IAtDa,kFA0DvB,OAAO,I,oCAkCMK,GACb,IAAK,IAAI/H,KAAK+H,EAAOqF,aAAc,CAClC,IAAIyK,OAAK,EADyB,EAER9P,EAAOqF,aAAapN,GAAxC4K,EAF4B,EAE5BA,KAAM1H,EAFsB,EAEtBA,KAAM+I,EAFgB,EAEhBA,IACd6L,EAAYlN,EAAKuM,EAAKvM,EAAKvG,GAAK,EAEhC0T,EAAc,CAAEnN,KAAMkN,EAAW9J,GAAK/B,EAAI,GAAIgC,IAAKhC,EAAI,GAAIiC,IAAKjC,EAAI,IACpE+L,EAAc,CAAEpN,KAAMkN,EAAWvI,GAAKtD,EAAI,GAAIgC,IAAKhC,EAAI,GAAIiC,IAAKjC,EAAI,IACpEgM,EAAc,CAAErN,KAAMkN,EAAW7H,GAAKhE,EAAI,GAAIiE,GAAKjE,EAAI,IACvDiM,EAAY,CAAEtN,KAAMkN,EAAW9J,GAAK/B,EAAI,GAAIqF,GAAKrF,EAAI,GAAIqC,IAAKrC,EAAI,IAClEkM,EAAW,CAAEvN,KAAMkN,EAAW7J,IAAKhC,EAAI,GAAImC,IAAKnC,EAAI,IACpDmM,EAAY,CAAExN,KAAMkN,EAAWvI,GAAKtD,EAAI,GAAIsH,IAAKtH,EAAI,GAAIuH,IAAKvH,EAAI,IAClEoM,EAAa,CAAEzN,KAAMkN,EAAW7H,GAAKhE,EAAI,IACzCqM,EAAa,CAAE1N,KAAMkN,EAAWxG,GAAKrF,EAAI,GAAIqC,IAAKrC,EAAI,GAAI+H,GAAK/H,EAAI,IACnEsM,EAAa,CAAE3N,KAAMkN,EAAW9J,GAAK/B,EAAI,GAAIgC,IAAKhC,EAAI,GAAIqC,IAAKrC,EAAI,GAAImJ,GAAInJ,EAAI,IAGnF,OAAQ/I,GAEP,IAAK,MACL,IAAK,OACL,IAAK,OACJ2U,EAAQ,IAAIlJ,GAAIoJ,GAChB,MACD,IAAK,MACL,IAAK,OACL,IAAK,OACJF,EAAQ,IAAI3I,GAAI6I,GAChB,MACD,IAAK,KACL,IAAK,MACL,IAAK,MACJF,EAAQ,IAAIzI,GAAG2I,GACf,MACD,IAAK,MACL,IAAK,OACL,IAAK,OACJF,EAAQ,IAAIxI,GAAI0I,GAChB,MACD,IAAK,MACL,IAAK,OACL,IAAK,OACJF,EAAQ,IAAI1I,GAAI4I,GAChB,MACD,IAAK,MACL,IAAK,OACJF,EAAQ,IAAIjJ,GAAImJ,GAChB,MACD,IAAK,KACL,IAAK,MACL,IAAK,MACJF,EAAQ,IAAI9I,GAAUgJ,GACtB,MACD,IAAK,KACL,IAAK,MACL,IAAK,MACJF,EAAQ,IAAI7I,GAAW+I,GACvB,MACD,IAAK,MACL,IAAK,OACL,IAAK,OACJF,EAAQ,IAAI5I,GAAqB8I,GACjC,MACD,IAAK,QACJF,EAAQ,IAAIhJ,GAASkJ,GACrB,MACD,IAAK,SACJF,EAAQ,IAAI/I,GAAUiJ,GACtB,MAGD,IAAK,QACL,IAAK,SACJF,EAAQ,IAAIrI,GAAMwI,GAClB,MACD,IAAK,QACL,IAAK,SACJH,EAAQ,IAAIpI,GAAMuI,GAClB,MACD,IAAK,QACL,IAAK,SACJH,EAAQ,IAAInI,GAAMsI,GAClB,MACD,IAAK,QACL,IAAK,SACJH,EAAQ,IAAIlI,GAAMqI,GAClB,MACD,IAAK,SACL,IAAK,UACJH,EAAQ,IAAIjI,GAAOoI,GACnB,MACD,IAAK,SACL,IAAK,UACJH,EAAQ,IAAIhI,GAAOmI,GACnB,MACD,IAAK,SACL,IAAK,UACJH,EAAQ,IAAI/H,GAAOkI,GACnB,MAGD,IAAK,MACJH,EAAQ,IAAIrF,GAAI0F,GAChB,MACD,IAAK,MACJL,EAAQ,IAAItF,GAAI2F,GAChB,MACD,IAAK,MACJL,EAAQ,IAAIpF,GAAIyF,GAChB,MACD,IAAK,MACJL,EAAQ,IAAIvF,GAAI4F,GAChB,MACD,IAAK,OACJL,EAAQ,IAAI7E,GAAKkF,GACjB,MACD,IAAK,OACJL,EAAQ,IAAI9E,GAAKmF,GACjB,MACD,IAAK,OACJL,EAAQ,IAAI5E,GAAKiF,GACjB,MACD,IAAK,OACJL,EAAQ,IAAI/E,GAAKoF,GACjB,MACD,IAAK,MACJL,EAAQ,IAAIzF,GAAI8F,GAChB,MACD,IAAK,MACJL,EAAQ,IAAI1F,GAAI+F,GAChB,MACD,IAAK,MACJL,EAAQ,IAAIxF,GAAI6F,GAChB,MACD,IAAK,MACJL,EAAQ,IAAI7F,GAAIkG,GAChB,MACD,IAAK,OACJL,EAAQ,IAAIjF,GAAKsF,GACjB,MACD,IAAK,OACJL,EAAQ,IAAIlF,GAAKuF,GACjB,MACD,IAAK,OACJL,EAAQ,IAAIhF,GAAKqF,GACjB,MACD,IAAK,OACJL,EAAQ,IAAInF,GAAKwF,GACjB,MACD,IAAK,MACJL,EAAQ,IAAI/F,GAAIoG,GAChB,MACD,IAAK,MACJL,EAAQ,IAAIhG,GAAIqG,GAChB,MACD,IAAK,MACJL,EAAQ,IAAI9F,GAAImG,GAChB,MACD,IAAK,MACJL,EAAQ,IAAItG,GAAI2G,GAChB,MAGD,IAAK,MACJL,EAAQ,IAAI1E,GAAIgF,GAChB,MACD,IAAK,OACJN,EAAQ,IAAIxE,GAAK8E,GACjB,MAGD,IAAK,OACJN,EAAQ,IAAIjE,GAAKwE,GACjB,MACD,IAAK,MACJP,EAAQ,IAAI/D,GAAIsE,GAChB,MACD,IAAK,OACJP,EAAQ,IAAIhE,GAAKuE,GACjB,MAGD,IAAK,MACJP,EAAQ,IAAItD,GAAI+D,GAChB,MACD,IAAK,MACJT,EAAQ,IAAIrD,GAAI8D,GAChB,MACD,IAAK,MACJT,EAAQ,IAAIpD,GAAI6D,GAChB,MACD,IAAK,MACJT,EAAQ,IAAInD,GAAI4D,GAChB,MACD,IAAK,MACJT,EAAQ,IAAIlD,GAAI2D,GAChB,MACD,IAAK,MACJT,EAAQ,IAAIjD,GAAI0D,GAChB,MACD,IAAK,MACJT,EAAQ,IAAIhD,GAAIyD,GAChB,MACD,IAAK,MACJT,EAAQ,IAAI/C,GAAIwD,GAChB,MACD,IAAK,MACJT,EAAQ,IAAI9C,GAAIuD,GAChB,MACD,IAAK,MACJT,EAAQ,IAAI7C,GAAIsD,GAChB,MACD,IAAK,MACJT,EAAQ,IAAI5C,GAAIqD,GAChB,MACD,IAAK,MACJT,EAAQ,IAAI3C,GAAIoD,GAChB,MAGD,IAAK,OACL,IAAK,QACJT,EAAQ,IAAI5D,GAAKoE,GACjB,MACD,IAAK,QACJR,EAAQ,IAAI1D,GAAMkE,GAClB,MACD,IAAK,OACJR,EAAQ,IAAIzD,GAAKiE,GACjB,MACD,IAAK,SACL,IAAK,UACJR,EAAQ,IAAIxD,GAAOgE,GACnB,MAGD,IAAK,KACL,IAAK,MACJR,EAAQ,IAAIxH,GAAG4H,GACf,MACD,IAAK,OACL,IAAK,QACJJ,EAAQ,IAAItH,GAAK0H,GACjB,MACD,IAAK,SACL,IAAK,UACJJ,EAAQ,IAAIrH,GAAOyH,GACnB,MACD,IAAK,OACL,IAAK,QACJJ,EAAQ,IAAIpH,GAAKwH,GACjB,MACD,IAAK,OACL,IAAK,QACJJ,EAAQ,IAAInH,GAAKuH,GACjB,MACD,IAAK,SACL,IAAK,UACJJ,EAAQ,IAAIhH,GAAOoH,GACnB,MACD,IAAK,MACJJ,EAAQ,IAAI/G,GAAImH,GAChB,MACD,IAAK,QACJJ,EAAQ,IAAI9G,GAAMkH,GAClB,MACD,IAAK,OACJJ,EAAQ,IAAI7G,GAAKiH,GACjB,MACD,IAAK,OACJJ,EAAQ,IAAI1G,GAAK8G,GACjB,MACD,IAAK,SACJJ,EAAQ,IAAIzG,GAAO6G,GACnB,MAGD,IAAK,QACJJ,EAAQ,IAAI1C,GAAMoD,GAClB,MACD,IAAK,MACJV,EAAQ,IAAIvC,GAAI,CAAE1K,KAAMA,EAAKuM,EAAKvM,EAAKvG,GAAK,EAAI2J,GAAI/B,EAAI,GAAId,GAAIc,EAAI,KACpE,MACD,IAAK,MACJ4L,EAAQ,IAAItC,GAAI,CAAE3K,KAAMA,EAAKuM,EAAKvM,EAAKvG,GAAK,EAAI4J,IAAKhC,EAAI,GAAIuJ,GAAIvJ,EAAI,KACrE,MAGD,QAEC,OADAY,QAAQC,IAAR,sBAA2B5J,EAA3B,uBACQ,EAE8B,SAApC6E,EAAOqF,aAAapN,GAAGoI,WAC1ByP,EAAM1P,OAAO,GAAK,SAClB0P,EAAMrT,SAAW,WAAO,MAAO,KAEd,IAAdP,OAAOjE,IAA2C,IAA/B+H,EAAOqF,aAAaxJ,SAC1CiU,EAAM1P,OAAO,IAAM,GAAK,IAEzBJ,EAAOqF,aAAapN,GAAGkI,YAAc2P,EAErC,IAAInQ,EAAMK,EAAOiF,OAAO,EACnBhL,KAAK2G,MAAMjB,KAAM1F,KAAK2G,MAAMjB,GAAO,a,KClc5B8Q,G,YAvFd,WAAYhX,GAAQ,IAAD,8BAClB,4CAAMA,KAKPU,aAAe,SAAC4T,GACfjJ,QAAQ4L,QACR5L,QAAQC,IAAI,iBACR,EAAK4L,EAAEC,IAAI7C,KACdjJ,QAAQC,IAAI,8BACZ,EAAK7D,IAAI2P,SAAS,EAAKF,EAAE/V,UAE1B,EAAKkW,eAba,EAgBnBC,QAAU,WACT,EAAK7P,IAAI2D,OACT,EAAKiM,eAlBa,EAqBnBE,OAAS,WACR,EAAK9P,IAAI0P,MACT,EAAKE,eAvBa,EA0BnBG,SAAW,WACV,EAAK/P,IAAI2P,SAAS,EAAKF,EAAE/V,SACzB,EAAKkW,eA5Ba,EA+BnBI,QAAU,WACT,EAAKhQ,IAAII,OACT,EAAKwP,eAjCa,EAuCnBK,QAAU,WAIT,IAHA,IAAIlQ,EAAM,EAAKC,IAAIkQ,SACfC,EAAO,IAAIC,WAAWrQ,EAAG,UAEpBhJ,EAAI,EAAGA,EAAIgJ,EAAG,SAAchJ,GAAK,EACzCoZ,EAAKpZ,GAAKgJ,EAAIhJ,GACdoZ,EAAKpZ,EAAE,GAAKgJ,EAAIhJ,EAAE,GAClBoZ,EAAKpZ,EAAE,GAAKgJ,EAAIhJ,EAAE,GAClBoZ,EAAKpZ,EAAE,GAAKgJ,EAAIhJ,EAAE,GAGnB,IAAIsZ,EAAO,IAAIC,KAAK,CAACH,GAAO,CAAClW,KAAM,6BAC/BwV,EAAIc,SAASC,cAAc,KAAMC,EAAMC,IAAIC,gBAAgBN,GAC/DZ,EAAExS,KAAOwT,EACThB,EAAEmB,SAAW,UACbL,SAASM,KAAKC,YAAYrB,GAC1BA,EAAElQ,QACFwR,YAAW,WACVR,SAASM,KAAKG,YAAYvB,GAC1BjT,OAAOkU,IAAIO,gBAAgBR,KACzB,IAzDH,EAAKzQ,IAAM,IAAIwC,GACf,EAAKiN,EAAI,IAAI9C,GAHK,E,sEAiElB,OADA4D,SAASM,KAAK1Y,MAAM+Y,UAAY,SAE/B,yBAAKhX,UAAU,aACd,kBAAC,EAAD,CACC/C,UAAW4B,KAAKiH,IAAIwE,SACpBjH,OAAQxE,KAAKiH,IAAIkQ,SACjB5V,QAASvB,KAAKiH,IAAIzI,MAAM+C,QACxBrB,aAAcF,KAAKE,aACnBY,UAAWd,KAAK8W,QAChBjW,SAAUb,KAAK+W,OACfvV,UAAWxB,KAAKiX,QAChBxV,WAAYzB,KAAKgX,SACjBlV,UAAa9B,KAAKkX,QAClBtW,GAAIZ,KAAKiH,IAAImR,QACbzX,QAASX,KAAKiH,IAAItG,QAClBgG,MAAO3G,KAAK0W,EAAE/P,MACdC,OAAQ5G,KAAK0W,EAAE9P,c,GAjFFpG,aCFlB6X,IAASC,OAAO,kBAAC,GAAD,MAASd,SAASe,eAAe,U","file":"static/js/main.ed199085.chunk.js","sourcesContent":["import CodeMirror from \"codemirror\";\r\n\r\n((mod) => {\r\n\tmod(CodeMirror);\r\n}) ((CodeMirror) => {\r\n\t//\"use strict\";\r\n\r\n\tCodeMirror.defineMode(\"patmos\", (config, parserConfig) => {\r\n\t\tlet getRegex = (w, i) => {\r\n\t\t\treturn new RegExp(\"^(?:\" + w.join(\"|\") + \")$\", i);\r\n\t\t};\r\n\r\n\t\tlet instTypes = getRegex([\r\n\t\t\t/* Normal Instructions */\r\n\t\t\t// BA\r\n\t\t\t\"add\", \"addi\", \"addl\", \"sub\", \"subi\", \"subl\", \"xor\", \"xori\", \"xorl\", \"sl\", \"sli\", \"sll\",\r\n\t\t\t\"sr\", \"sri\", \"srl\", \"sra\", \"srai\", \"sral\", \"nor\", \"norl\", \"shadd\", \"shadd2\", \"or\", \"ori\", \"orl\",\r\n\t\t\t\"and\", \"andi\", \"andl\",\r\n\t\t\t// Compare\r\n\t\t\t\"btest\", \"btesti\", \"cmpeq\", \"cmpieq\", \"cmple\", \"cmpile\", \"cmplt\", \"cmpilt\", \r\n\t\t\t\"cmpneq\", \"cmpineq\", \"cmpule\", \"cmpiule\", \"cmpult\", \"cmpiult\",\r\n\t\t\t// Load\r\n\t\t\t\"lbc\", \"lbl\", \"lbm\", \"lbs\", \"lbuc\", \"lbul\", \"lbum\", \"lbus\", \"lhc\", \"lhl\", \r\n\t\t\t\"lhm\", \"lhs\", \"lhuc\", \"lhul\", \"lhum\", \"lhus\", \"lwc\", \"lwl\", \"lwm\", \"lws\",\r\n\t\t\t// Store\r\n\t\t\t\"sbc\", \"sbl\", \"sbm\", \"sbs\", \"shc\", \"shl\", \"shm\", \"shs\", \"swc\", \"swl\", \"swm\", \"sws\",\r\n\t\t\t// Multiply\r\n\t\t\t\"mul\", \"mulu\", \r\n\t\t\t// Stack Control\r\n\t\t\t\"sens\", \"sfree\", \"sres\", \"sspill\", \t\"sspillr\", \"sensr\",\r\n\t\t\t// Predicate\r\n\t\t\t\"pand\", \"por\", \"pxor\",\r\n\t\t\t// Move types\r\n\t\t\t\"mts\", \"mfs\",\r\n\t\t\t// Control Flow\r\n\t\t\t\"callnd\", \"call\", \"brnd\", \"br\", \"brcfnd\", \"brcf\", \"trap\",\r\n\t\t\t\"retnd\", \"ret\", \"xretnd\", \"xret\", \"callndr\", \"callr\", \r\n\t\t\t\"brndr\", \"brr\", \"brcfr\", \"brcfndr\",\r\n\t\t\t// Bit copy\r\n\t\t\t\"bcopy\",\r\n\r\n\t\t\t/* Pseudo Instructions */\r\n\t\t\t\"mov\", \"clr\", \"neg\", \"not\", \"li\", \"nop\", \"isodd\", \"pmov\", \"pnot\", \"pset\", \"pclr\",\r\n\t\t], \"i\");\r\n\r\n\t\tlet registers = getRegex([\r\n\t\t// General-purpose\r\n\t\t\t\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \r\n\t\t\t\"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \r\n\t\t\t\"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\r\n\t\t\t// Predicate\r\n\t\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\r\n\t\t\t// Special-purpose\r\n\t\t\t\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \r\n\t\t\t\"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\",\r\n\t\t\t// Special names\r\n\t\t\t\"sl\", \"sh\", \"ss\", \"st\", \"srb\", \"sro\", \"sxb\", \"sxo\",\r\n\t\t], \"\");\r\n\r\n\t\tlet keywords = getRegex([\".word\"], \"i\");\r\n\r\n\t\tlet normal = (stream, state) => {\r\n\t\t\tlet ch = stream.next();\r\n\r\n\t\t\t// Eat entire comment\r\n\t\t\tif (ch === \"#\") {\r\n\t\t\t\tstream.skipToEnd();\r\n\t\t\t\treturn \"comment\";\r\n\t\t\t}\r\n\t\t\r\n\t\t\t// Eat all digits of number\r\n\t\t\tif (/\\d/.test(ch)) {\r\n\t\t\t\tstream.eatWhile(/[\\w.%]/);\r\n\t\t\t\treturn \"number\";\r\n\t\t\t}\r\n\r\n\t\t\t// Eat all characters of register / keyword\r\n\t\t\tif (/[.\\w_]/.test(ch)) {\r\n\t\t\t\tstream.eatWhile(/[\\w\\\\\\-_.]/);\r\n\t\t\t\treturn \"variable\";\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tstartState: (basecol) => {\r\n\t\t\t\treturn { basecol: basecol || 0, indentDepth: 0, cur: normal };\r\n\t\t\t},\r\n\r\n\t\t\ttoken: (stream, state) => {\r\n\t\t\t\tif (stream.eatSpace()) return null;\r\n\t\t\t\tlet style = state.cur(stream, state);\r\n\t\t\t\tlet word = stream.current();\r\n\r\n\t\t\t\t// Use different colors for types, registers and keywords\r\n\t\t\t\tif (style === \"variable\") {\r\n\t\t\t\t\tif (keywords.test(word)) style = \"keyword\";\r\n\t\t\t\t\telse if (instTypes.test(word)) style = \"builtin\";\r\n\t\t\t\t\telse if (registers.test(word)) style = \"variable-2\";\r\n\t\t\t\t}\r\n\t\t\t\treturn style;\r\n\t\t\t}\r\n\t\t};\r\n\t});\r\n\r\n\t// inspiration from codemirror.net/addon/lint/javascript-lint.js \r\n\t// let validator = (text, options) => {\r\n\t// \tif(!window.JSHINT) {\r\n\t// \t\tif (window.console) {\r\n\t// \t\t\twindow.console.error(\"Error: window. not defined, CodeMirror Patmos-mode linting cannot run.\");\r\n\t// \t\t}\r\n\t// \t\treturn [];\r\n\t// \t}\r\n\t// \tif (!options.indent) // JSHint error.character actually is a column index, this fixes underlining on lines using tabs for indentation\r\n\t// \t\toptions.indent = 1; // JSHint default value is 4\r\n\t// \tJSHINT(text, options, options.globals);\r\n\t// \tlet errors = JSHINT.data().errors, result = [];\r\n\t// \tif (errors) parseErrors(errors, result);\r\n\t// \treturn result;\r\n\t// };\r\n\r\n\t// let parseErrors = (errors, output) => {\r\n\t// \tfor ( let i = 0; i < errors.length; i++) {\r\n\t// \t\tlet error = errors[i];\r\n\t// \t\tif (error) {\r\n\t// \t\t\tif (error.line <= 0) {\r\n\t// \t\t\t\tif (window.console)\r\n\t// \t\t\t\t\twindow.console.warn(\"Cannot display JSHint error (invalid line \" + error.line + \")\", error);\r\n\t// \t\t\t\tcontinue;\r\n\t// \t\t\t}\r\n\r\n\t// \t\t\tlet start = error.character - 1, end = start + 1;\r\n\t\t\t\t\r\n\t// \t\t\tif (error.evidence) {\r\n\t// \t\t\t\tlet index = error.evidence.substring(start).search(/.\\b/);\r\n\t// \t\t\t\tif (index > -1) end += index;\r\n\t// \t\t\t}\r\n\r\n\t// \t\t\t// Convert to format expected by validation service\r\n\t// \t\t\toutput.push({\r\n\t// \t\t\t\tmessage: error.reason,\r\n\t// \t\t\t\tseverity: error.code ? (error.code.startsWith('W') ? \"warning\" : \"error\") : \"error\",\r\n\t// \t\t\t\tfrom: CodeMirror.Pos(error.line - 1, start),\r\n\t// \t\t\t\tto: CodeMirror.Pos(error.line - 1, end)\r\n\t// \t\t\t});\r\n\t// \t\t}\r\n\t// \t}\r\n\t// };\r\n\r\n\t// CodeMirror.registerHelper(\"lint\", \"patmos\", validator);\r\n});\r\n  ","import React, { Component } from \"react\";\r\nimport CodeMirror from \"react-codemirror\";\r\nimport PropTypes from \"prop-types\";\r\nimport \"../../node_modules/codemirror/lib/codemirror.css\";\r\nimport \"./patmos-mode\";\r\n//import \"../../node_modules/codemirror/mode/patmos/patmos\";\r\n\r\nclass Editor extends Component{\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\tcode: \"\",\r\n\t\t\treadOnly: false,\r\n\t\t\tmode: \"patmos\",\r\n\t\t\tlint: true,\r\n\t\t};\r\n\r\n\t\tthis.updateCode = this.updateCode.bind(this);\r\n\t}\r\n\r\n\tupdateCode (newCode) {\r\n\t\tthis.setState({\r\n\t\t\tcode: newCode,\r\n\t\t});\r\n\t\tthis.props.editorUpdate(newCode);\r\n\t}\r\n\r\n\trender() {\r\n\t\tlet options = {\r\n\t\t\tmode: this.state.mode,\r\n\t\t\tlineNumbers: true,\r\n\t\t};\r\n\t\treturn(\r\n\t\t\t<div><CodeMirror value={this.state.code} onChange={this.updateCode} options={options} autoFocus={true}/></div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nEditor.propTypes = {\r\n\teditorUpdate : PropTypes.func\r\n};\r\n\r\nexport default Editor;\r\n","import React, { Fragment } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport \"../../CSS/Buttons.css\";\r\n\r\nconst buttonCSS = [\r\n\t\"btn button run col-2\", \r\n\t\"btn button step col-2\", \r\n\t\"btn button prev col-2\",\r\n\t\"btn button reset col-2\",\r\n\t\"btn button dump col-2\",\r\n];\r\n\r\n/**\r\n * DisplayButtons: Handles display of buttons and returns clicks of buttons.\r\n * @param {object} \tprops.bundles\t\t- Object consisting of all instruction bundles from editor\r\n * @param {number}\tprops.pc\t\t\t- Current CPU program counter\r\n * @param {func}\tprops.runClick\t\t- Button run clicked handler\r\n * @param {func}\tprops.stepClick\t\t- Button step clicked handler\r\n * @param {func}\tprops.prevClick\t\t- Button prev clicked handler\r\n * @param {func}\tprops.resetClick\t- Button reset clicked handler\r\n */\r\nconst DisplayButtons = (props) => {\r\n\treturn (\r\n\t\t<div className=\"button-container\">\r\n\t\t\t{forwardBtn(props.bundles, props.pc, props.runClick, props.stepClick)}\r\n\t\t\t{backwardsBtn(props.history, props.prevClick, props.resetClick)}\r\n\t\t\t<button type =\"button\" className={buttonCSS[4]} onClick = {props.dumpClick}>Dump</button>\r\n\t\t</div>  \r\n\t);\r\n};\r\n\r\n/**\r\n * fowardBtn: Handles the two buttons \"Run\" and \"Step\".\r\n * Disables the buttons if no instructions left in queue.\r\n * @param {Object} \tbundles \t- Object consisting of all instruction bundles from editor\r\n * @param {number} \tpc \t\t\t- Current CPU program counter\r\n * @param {func} \trunClick \t- Button run clicked handler\r\n * @param {func} \tstepClick \t- Button step clicked handler\r\n */\r\nconst forwardBtn = (bundles, pc, runClick, stepClick) => {\r\n\tlet tooltipRun = \"Run all remaining instructions in queue\";\r\n\tlet tooltipStep = \"Step next instruction in queue\";\r\n\r\n\tif (!bundles[pc]) {\r\n\t\ttooltipRun = \"No instructions to run\";\r\n\t\ttooltipStep = \"No instructions to step\";\r\n\t\treturn (\r\n\t\t\t<Fragment>\r\n\t\t\t\t<button title={tooltipRun} type=\"button\" className={buttonCSS[0]} disabled>Run</button>\r\n\t\t\t\t<button title={tooltipStep} type=\"button\" className={buttonCSS[1]} disabled>Step</button>\r\n\t\t\t</Fragment>\r\n\t\t);\r\n\t}\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<button title={tooltipRun} type=\"button\" className={buttonCSS[0]} onClick={runClick}  >Run</button>\r\n\t\t\t<button title={tooltipStep} type=\"button\" className={buttonCSS[1]} onClick={stepClick} >Step</button>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n\r\n/**\r\n * backwardsBtn: Handles the two buttons \"Prev\" and \"Reset\".\r\n * Disables the buttons if no instructions has been executed yet.\r\n * @param {} \t\thistory\t\t- Current CPU program counter\r\n * @param {func} \tprevClick \t- Button prev clicked handler\r\n * @param {func} \tresetClick \t- Button reset clicked handler\r\n */\r\nconst backwardsBtn = (history, prevClick, resetClick) => {\r\n\tlet tooltipPrev = \"Steps one instruction back (decrement program count)\";\r\n\tlet tooltipReset = \"Reset registers & memory and jump to first instruction\";\r\n\r\n\tif (history.length === 0) {\r\n\t\ttooltipReset = \"No instructions run yet\";\r\n\t\ttooltipPrev = \"No instructions run yet\";\r\n\t\treturn (\r\n\t\t\t<Fragment>\r\n\t\t\t\t<button title={tooltipPrev} type=\"button\" className={buttonCSS[2]} disabled>Prev</button>\r\n\t\t\t\t<button title={tooltipReset} type=\"button\" className={buttonCSS[3]} disabled>Reset</button>\r\n\t\t\t</Fragment>\r\n\t\t);\r\n\t}\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<button title={tooltipPrev} type=\"button\" className={buttonCSS[2]} onClick={prevClick}  >Prev</button>\r\n\t\t\t<button title={tooltipReset} type=\"button\" className={buttonCSS[3]} onClick={resetClick}>Reset</button>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n\r\nDisplayButtons.propTypes = {\r\n\thistory     : PropTypes.array,\r\n\tbundles \t: PropTypes.object,\r\n\tpc \t\t\t: PropTypes.number,\r\n\trunClick \t: PropTypes.func,\r\n\tstepClick\t: PropTypes.func,\r\n\tprevClick \t: PropTypes.func,\r\n\tresetClick \t: PropTypes.func,\r\n\tdumpClick\t: PropTypes.func,\r\n};\r\n\r\n\r\nexport default DisplayButtons;\r\n","export const parseNum = (input) => typeof input == \"number\" ? input : Number(input);\r\nexport const parseReg = (input) => typeof input == \"number\" ? input : Number(input.match(/\\d+/i)[0]);\r\nexport const toUint32 = (n) => n >>> 0;\r\nexport const toInt32 = (n) => n | 0;\r\nexport const intToHex = (integer, length) => {\r\n\tinteger = Number(integer);\r\n\r\n\tif (integer < 0) {\r\n\t\tinteger = 0xFFFFFFFF + integer + 1;\r\n\t}\r\n\treturn integer.toString(16).toUpperCase().padStart(length, \"0\");\r\n};\r\nexport const intToHexStr = (integer, length) => {\r\n\treturn `0x${intToHex(integer, length)}`;\r\n};\r\n","import React, { Component } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { intToHex, intToHexStr } from \"../../Helpers/misc\";\r\nimport \"../../CSS/Simulator.css\";\r\nimport \"../../CSS/Buttons.css\";\r\nimport \"../../CSS/App.css\";\r\n\r\nconst tableCSS = \"table table-hover table-sm col-12\";\r\nconst maxSize = 0x00200000;\r\n\r\nclass DisplayStorage extends Component {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\tpagenumber\t: 1,\r\n\t\t\tpageRows \t: 0,\r\n\t\t\tmaxPage \t: 0,\r\n\t\t\thex\t\t\t: false,\r\n\t\t};\r\n\r\n\t\tthis.incPage = this.incPage.bind(this);\r\n\t\tthis.decPage = this.decPage.bind(this);\r\n\t\tthis.jumpPage = this.jumpPage.bind(this);\r\n\t\tthis.updateDimensions = this.updateDimensions.bind(this);\r\n\t\tthis.toggleHex = this.toggleHex.bind(this);\r\n\t}\r\n\r\n\tupdateDimensions() {\r\n\t\tlet pageRows = Math.floor((window.innerHeight - 220) / 35); // row 34.6\r\n\t\tthis.setState({ \r\n\t\t\tpageRows\t: pageRows,\r\n\t\t\tmaxPage\t\t: Math.ceil(maxSize / (pageRows*4)),\r\n\t\t});\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tthis.updateDimensions();\r\n\t\twindow.addEventListener(\"resize\", this.updateDimensions);\r\n\t}\r\n\t\r\n\tcomponentWillUnmount() {\r\n\t\twindow.removeEventListener(\"resize\", this.updateDimensions);\r\n\t}\r\n\r\n\tincPage() {\r\n\t\tif ((this.state.pagenumber+1) <= this.state.maxPage)\r\n\t\t\tthis.setState((prevState) => ({ pagenumber: prevState.pagenumber + 1 }));\r\n\t}\r\n\r\n\tdecPage() {\r\n\t\tif (this.state.pagenumber > 1)\r\n\t\t\tthis.setState((prevState) => ({ pagenumber: prevState.pagenumber - 1 }));\r\n\t}\r\n\r\n\tjumpPage() {\r\n\t\tlet des = parseInt(Number(prompt(\"What address do you want to jump to? Both hexadecimal and decimal numbers accepted.\")), 10) / (this.state.pageRows*4);\r\n\t\tif (des <= this.state.maxPage) \r\n\t\t\tthis.setState(() => ({ pagenumber: Math.floor(des)+1 }));\r\n\t}\r\n\r\n\ttoggleHex() {\r\n\t\tthis.setState((prevState) => ({ hex : prevState.hex ? false : true }));\r\n\t}\r\n\r\n\trender() {\r\n\t\treturn(\r\n\t\t\t<div>\r\n\t\t\t\t<ul className =\"nav nav-tabs justify-content-center\">\r\n\t\t\t\t\t<li className=\"nav-item\">\r\n\t\t\t\t\t\t<a href=\"#registers\" className=\"nav-link active\" data-toggle=\"tab\" role=\"tab\">Registers</a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t\t<li className=\"nav-item\">\r\n\t\t\t\t\t\t<a href=\"#gm\" className=\"nav-link\" data-toggle=\"tab\" role=\"tab\">Memory</a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\r\n\t\t\t\t<div className=\"tab-content\">\r\n\t\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane active table-scrolling\" id=\"registers\">\r\n\t\t\t\t\t\t{RenderRegTable(this.props.registers)}\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane\" id=\"gm\">\r\n\t\t\t\t\t\t{RenderMemoryTable(this.props.memory, this.state.pagenumber, this.state.pageRows, this.state.hex)}\r\n\t\t\t\t\t\t<div>\r\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-4\" onClick={this.decPage}>Prev</button>\r\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-4\" onClick={this.incPage}>Next</button>\r\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-4\" onClick={this.jumpPage}>Jump</button>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t<div>\r\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-12\" onClick={this.toggleHex}>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tthis.state.hex ? \"Change to decimal\" : \"Change to hexadecimal\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\t\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * RenderRegTable: Returns the register table with columns Register, Decimal, Hexadecimal\r\n * @param {Object} registers - Object containing all register values with the reg as key. r0-r31, p0-p7, s0-s15\r\n */\r\nconst RenderRegTable = (registers) => {\r\n\tvar rows = [];\r\n\r\n\t// Generate rows: 32 r-, 16 s-, and 8 p-rows.\r\n\tfor (let i = 0; i < 32; i++) {\r\n\t\trows.push(RegRow(\"r\", i, registers));\r\n\t}\r\n\tfor (let i = 0; i < 16; i++) {\r\n\t\trows.push(RegRow(\"s\", i, registers));\r\n\t}\r\n\tfor (let i = 0; i < 8; i++) {\r\n\t\trows.push(RegRow(\"p\", i, registers));\r\n\t}\r\n\r\n\t// This row overflows when scrolled all the way down. \r\n\trows.push(\r\n\t\t<tr key={\"bottom\"}>\r\n\t\t\t<th>---</th>\r\n\t\t\t<td>---</td>\r\n\t\t\t<td>---</td>\r\n\t\t</tr>\r\n\t);\r\n\r\n\t// Return table\r\n\treturn (\r\n\t\t<table className={tableCSS}>\r\n\t\t\t<thead className=\"header-stick\">\r\n\t\t\t\t<tr className=\"header-stick\">\r\n\t\t\t\t\t<th className=\"header-stick\" scope=\"col\">Register</th>\r\n\t\t\t\t\t<th className=\"header-stick\" scope=\"col\">Decimal</th>\r\n\t\t\t\t\t<th className=\"header-stick\" scope=\"col\">Hexadecimal</th>\r\n\t\t\t\t</tr>\r\n\t\t\t</thead>\r\n\t\t\t<tbody>\r\n\t\t\t\t{rows}\t\r\n\t\t\t</tbody>\r\n\t\t</table>\r\n\t);\r\n};\r\n\r\n/**\r\n * RenderMemoryTable: Returns the memory table with columns Address, +0, +1, +2, +3\r\n * @param {Object} props.memory\t\t- Object containing the memory of the program. \r\n */\r\nconst RenderMemoryTable = (memory, pagenumber, pageRows, hex) => {\r\n\tlet gm_temp, rows = [];\r\n\r\n\tlet startAddr = (pagenumber-1)*pageRows*4;\r\n\tlet endAddr = pagenumber*pageRows*4;\r\n\r\n\t// We don't want to display these fields:\r\n\tgm_temp = Object.assign({}, memory);\r\n\tdelete gm_temp[\"BASE_ADDR\"];\r\n\tdelete gm_temp[\"MAX_SIZE\"];\r\n\tdelete gm_temp[\"TEXT_END\"];\r\n\r\n\tfor (let i = startAddr; i < endAddr; i+= 4) {\r\n\t\tif (i <= maxSize) {\r\n\t\t\tif (gm_temp[i] === undefined && gm_temp[i+1] === undefined && gm_temp[i+2] === undefined && gm_temp[i+3] === undefined) {\r\n\t\t\t\trows.push(zeroRow(i, hex));\r\n\t\t\t} else {\r\n\t\t\t\thex ? rows.push(MemoryRowHex(gm_temp, i)) : rows.push(MemoryRowDec(gm_temp, i));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\trows.push(emptyRow(i));\r\n\t\t}\r\n\t}\r\n\r\n\t// Return table\r\n\treturn (\r\n\t\t<table className={tableCSS}>\r\n\t\t\t<thead>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<th scope=\"col\">Address</th>\r\n\t\t\t\t\t<th scope=\"col\">+0</th>\r\n\t\t\t\t\t<th scope=\"col\">+1</th>\r\n\t\t\t\t\t<th scope=\"col\">+2</th>\r\n\t\t\t\t\t<th scope=\"col\">+3</th>\r\n\t\t\t\t</tr>\r\n\t\t\t</thead>\r\n\t\t\t<tbody>\r\n\t\t\t\t{rows}\r\n\t\t\t</tbody>\r\n\t\t</table>\r\n\t);\r\n};\r\n\r\n/**\r\n * emtpyRow: Returns an empty row in the memory table\r\n * @param {number} key \t- The start byte address of the memory row\r\n */\r\nconst emptyRow = (key) => {\r\n\treturn(\r\n\t\t<tr key={key}>\r\n\t\t\t<td>----------</td>\r\n\t\t\t<td>---</td>\r\n\t\t\t<td>---</td>\r\n\t\t\t<td>---</td>\r\n\t\t\t<td>---</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\n/**\r\n * emtpyRow: Returns a row with zeros in the memory table\r\n * @param {number} key \t- The start byte address of the memory row\r\n * @param {boolean} hex - Wheter to display in hexadecimal or not\r\n */\r\nconst zeroRow = (key, hex) => {\r\n\treturn(\r\n\t\t<tr key={key}>\r\n\t\t\t<td>{intToHexStr(key, 8)}</td>\r\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\r\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\r\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\r\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\n/**\r\n * MemoryRow: Returns one row of the memory table.\r\n * @param {Object} memory - Object containing the global memory of the program. \r\n */\r\nconst MemoryRowDec = (memory, key) => {\r\n\tlet row = [\r\n\t\tmemory[`${key}`] === undefined ? 0 : memory[`${key}`], \r\n\t\tmemory[`${key+1}`] === undefined ? 0 : memory[`${key+1}`], \r\n\t\tmemory[`${key+2}`] === undefined ? 0 : memory[`${key+2}`], \r\n\t\tmemory[`${key+3}`] === undefined ? 0 : memory[`${key+3}`], \r\n\t];\r\n\r\n\treturn(\r\n\t\t<tr key={key}>\r\n\t\t\t<td>{intToHexStr(key, 8)}</td>\r\n\t\t\t<td>{row[0]}</td>\r\n\t\t\t<td>{row[1]}</td>\r\n\t\t\t<td>{row[2]}</td>\r\n\t\t\t<td>{row[3]}</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\n/**\r\n * MemoryRow: Returns one row of the memory table in hexadecimal.\r\n * @param {Object} memory - Object containing the global memory of the program. \r\n */\r\nconst MemoryRowHex = (memory, key) => {\r\n\tlet row = [\r\n\t\tmemory[`${key}`] === undefined ? 0 : memory[`${key}`], \r\n\t\tmemory[`${key+1}`] === undefined ? 0 : memory[`${key+1}`], \r\n\t\tmemory[`${key+2}`] === undefined ? 0 : memory[`${key+2}`], \r\n\t\tmemory[`${key+3}`] === undefined ? 0 : memory[`${key+3}`], \r\n\t];\r\n\r\n\treturn(\r\n\t\t<tr key={key}>\r\n\t\t\t<td>{intToHexStr(key, 8)}</td>\r\n\t\t\t<td>{intToHex(row[0], 2)}</td>\r\n\t\t\t<td>{intToHex(row[1], 2)}</td>\r\n\t\t\t<td>{intToHex(row[2], 2)}</td>\r\n\t\t\t<td>{intToHex(row[3], 2)}</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\n/**\r\n * RegRow: Returns one row of the register table.\r\n * @param {string} letter \t\t- Either r, p or s\r\n * @param {number} idx \t\t\t- Current idx of the register\r\n * @param {Object} registers \t- Object containing all register values with the reg as key. r0-r31, p0-p7, s0-s15\r\n */\r\nconst RegRow = (letter, idx, registers) => {\r\n\tlet val = registers[`${letter}${idx}`];\r\n\r\n\treturn(\r\n\t\t<tr key={`${letter}${idx}`}>\r\n\t\t\t<td>{letter}{idx}</td>\r\n\t\t\t<td>{val}</td>\r\n\t\t\t<td>{intToHexStr(val, 8)}</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\nDisplayStorage.propTypes = {\r\n\tregisters \t: PropTypes.object,\r\n\tmemory \t\t: PropTypes.object,\r\n};\r\n\r\nexport default DisplayStorage;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { intToHexStr } from \"../../Helpers/misc\";\r\nimport \"../../CSS/Simulator.css\";\r\n\r\n/**\r\n * DisplayCode: Displays all the instructions in the instruction queue as machine, basic and original code.\r\n * @param {number}\tprops.pc\t\t- Current CPU program counter\r\n * @param {Object}\tprops.bundles\t- Object consisting of all instruction bundles from editor\r\n */\r\nconst DisplayCode = (props) => {\r\n\treturn (\r\n\t\t<div className=\"code-container\">\r\n\t\t\t<table className=\"table table-hover table-sm\" id=\"displaycode\">\r\n\t\t\t\t<thead>\r\n\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t<th scope=\"col\">Machine Code</th>\r\n\t\t\t\t\t\t<th scope=\"col\">Basic Code</th>\r\n\t\t\t\t\t\t<th scope=\"col\">Original Code</th>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t</thead>\r\n\t\t\t\t<tbody>\r\n\t\t\t\t\t{GenMachineRows(props.pc, props.bundles)}\r\n\t\t\t\t</tbody>\r\n\t\t\t</table>\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\n/**\r\n * GenMachineRows: Generates all code table rows. \r\n * Done by calling MachineRow on each bundle in bundles. \r\n * @param {Object}\tprops.bundles\t- Object consisting of all instruction bundles from editor\r\n * @param {number}\tpc\t\t\t\t- Current CPU program counter\r\n */\r\nconst GenMachineRows = (pc, bundles) => {\r\n\tlet rows = [];\r\n\tfor (let o in bundles){\r\n\t\trows.push(MachineRow(bundles[o], pc, o));\r\n\t}\r\n\treturn rows;\r\n};\r\n\r\n/**\r\n * MachineRow: Generates one row of the table: Binary | Basic Code | Original code\r\n * Highlights row if current row is the same as program counter (i = pc).\r\n * @param {Object}\tbundles\t- Object consisting of all instruction bundles from editor\r\n * @param {number}\tpc\t\t- Current CPU program counter\r\n * @param {number} \taddr\t- Current bundle address \r\n */\r\nconst MachineRow = (bundle, pc, addr) => {\r\n\tlet idx = 0;\r\n\tlet color = pc === Number(addr) ? \"current-inst\" : \"\";\r\n\tlet rows = [];\r\n\t\r\n\tfor(let i of bundle){\r\n\t\trows.push(\r\n\t\t\t<tr key={idx} className={color} >\r\n\t\t\t\t<td>{intToHexStr(i.instruction.binary[0], 8)}</td>\r\n\t\t\t\t<td>{i.instruction.toString()}</td>\r\n\t\t\t\t<td>{i.original}</td>\r\n\t\t\t</tr>\r\n\t\t);\r\n\t\tidx++;\r\n\t}\r\n\treturn rows;\r\n};\r\n\r\nDisplayCode.propTypes = {\r\n\tpc \t\t\t\t: PropTypes.number,\r\n\tbundles\t\t\t: PropTypes.object,\r\n};\r\n\r\nexport default DisplayCode;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport DisplayButtons from \"./DisplayButtons\";\r\nimport DisplayStorage from \"./DisplayStorage\";\r\nimport DisplayCode from \"./DisplayCode\";\r\nimport \"../../CSS/Simulator.css\";\r\n\r\n/**\r\n * Simulator: Handles all the displaying under the \"Simulator\" tab.\r\n * @param {number}\tprops.pc\t\t\t- Current CPU program counter\r\n * @param {func}\tprops.runClick\t\t- Button run clicked handler\r\n * @param {func}\tprops.stepClick\t\t- Button step clicked handler\r\n * @param {func}\tprops.prevClick\t\t- Button prev clicked handler\r\n * @param {func}\tprops.resetClick\t- Button reset clicked handler\r\n * @param {Object}\tprops.bundles \t\t- Object containing all instruction bundles from editor\r\n * @param {Object} \tprops.registers \t- Object containing all register values with the reg as key. r0-r31, p0-p7, s0-s15\r\n * @param {Object} \tprops.memory\t\t- Object containing the global memory of the program\r\n * @param {string} \tprops.consoleOutput - The output string to console\r\n */\r\nconst Simulator = (props) => {\r\n\treturn(\r\n\t\t<div className=\"sim\">\r\n\t\t\t<div className=\"col-8 col-xl-9 sim-child\">\r\n\t\t\t\t<DisplayButtons \r\n\t\t\t\t\thistory = {props.history}\r\n\t\t\t\t\tstepClick = {props.stepClick} \r\n\t\t\t\t\trunClick = {props.runClick}\r\n\t\t\t\t\tprevClick = {props.prevClick}\r\n\t\t\t\t\tresetClick = {props.resetClick}\r\n\t\t\t\t\tdumpClick = {props.dumpClick}\r\n\t\t\t\t\tpc = {props.pc}\r\n\t\t\t\t\tbundles = {props.bundles}\r\n\t\t\t\t/>\r\n\t\t\t\t<DisplayCode\r\n\t\t\t\t\tpc = {props.pc}\r\n\t\t\t\t\tbundles = {props.bundles}\r\n\t\t\t\t/>\r\n\t\t\t</div>\r\n\r\n\t\t\t<div className=\"col-4 col-xl-3 reg-container sim-child\">\r\n\t\t\t\t<DisplayStorage\r\n\t\t\t\t\tregisters = {props.registers}\r\n\t\t\t\t\tmemory = {props.memory}\r\n\t\t\t\t/>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\nSimulator.propTypes = {\r\n\thistory         : PropTypes.array,\r\n\tpc \t\t\t\t: PropTypes.number,\r\n\trunClick \t\t: PropTypes.func,\r\n\tstepClick\t\t: PropTypes.func,\r\n\tprevClick \t\t: PropTypes.func,\r\n\tresetClick \t\t: PropTypes.func,\r\n\tdumpClick\t\t: PropTypes.func,\r\n\tbundles\t\t\t: PropTypes.object,\r\n\tregisters \t\t: PropTypes.object,\r\n\tmemory \t\t\t: PropTypes.object,\r\n};\r\n\r\nexport default Simulator;\r\n","import React, { Fragment } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport Editor from \"./Editor\";\r\nimport Simulator from \"./Simulator/Simulator\";\r\n\r\n/**\r\n * FrontEnd: Handles the entire front end of Chora. Splits into two tabs: Editor and Simulator.\r\n */\r\nconst FrontEnd = (props) => {\r\n\tlet click, toggle = \"tab\", errMes = \"\";\r\n\r\n\t// fix it so it displays correct line number instead of\r\n\tif (props.error.length) { \r\n\t\tfor (let i in props.error) errMes += props.error[i] === \"fine\" ? \"\" : `L${props.numMap[i]}: ` + props.error[i] + \"\\n\";\r\n\t\tclick = () => { alert(errMes); };\r\n\t\ttoggle = \"\";\r\n\t}\r\n\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<ul className =\"nav nav-tabs justify-content-center\">\r\n\t\t\t\t<li className=\"nav-item\">\r\n\t\t\t\t\t<a href=\"#editor\" className=\"nav-link active\" data-toggle=\"tab\" role=\"tab\">Editor</a>\r\n\t\t\t\t</li>\r\n\t\t\t\t<li className=\"nav-item \">\r\n\t\t\t\t\t<a href=\"#simulator\" className=\"nav-link\" onClick={click} data-toggle={toggle} role=\"tab\">Simulator</a>\r\n\t\t\t\t</li>\r\n\t\t\t</ul>\r\n\r\n\t\t\t<div className=\"tab-content no-scroll\">\r\n\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane active\" id=\"editor\">\r\n\t\t\t\t\t<Editor\r\n\t\t\t\t\t\teditorUpdate = {props.editorUpdate}\r\n\t\t\t\t\t/>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane\" id=\"simulator\">\r\n\t\t\t\t\t<Simulator\r\n\t\t\t\t\t\thistory = {props.history}\r\n\t\t\t\t\t\tmemory = {props.memory}\r\n\t\t\t\t\t\tstepClick = {props.stepClick}\r\n\t\t\t\t\t\trunClick = {props.runClick}\r\n\t\t\t\t\t\tprevClick = {props.prevClick}\r\n\t\t\t\t\t\tresetClick = {props.resetClick}\r\n\t\t\t\t\t\tdumpClick = {props.dumpClick}\r\n\t\t\t\t\t\tregisters = {props.registers}\r\n\t\t\t\t\t\tpc = {props.pc}\r\n\t\t\t\t\t\tbundles = {props.bundles}\r\n\t\t\t\t\t/>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n\r\nFrontEnd.propTypes = {\r\n\thistory         : PropTypes.array,\r\n\teditorUpdate \t: PropTypes.func,\r\n\tpc \t\t\t\t: PropTypes.number,\r\n\trunClick \t\t: PropTypes.func,\r\n\tstepClick\t\t: PropTypes.func,\r\n\tprevClick \t\t: PropTypes.func,\r\n\tresetClick \t\t: PropTypes.func,\r\n\tdumpClick\t\t: PropTypes.func,\r\n\tbundles\t\t\t: PropTypes.object,\r\n\tregisters \t\t: PropTypes.object,\r\n\tmemory \t\t\t: PropTypes.object,\r\n\terror\t\t\t: PropTypes.arrayOf(String),\r\n\tnumMap\t\t\t: PropTypes.array,\r\n};\r\n\r\nexport default FrontEnd;\r\n","class ProcessorState {\r\n\tconstructor() {\r\n\t\tthis.history = [];\r\n\t\tthis.reg = {\r\n\t\t\t// General-purpose registers\r\n\t\t\t\"r0\" : 0,\r\n\t\t\t\"r1\" : 0, \"r2\" : 0, \"r3\" : 0, \"r4\" : 0, \"r5\" : 0,\r\n\t\t\t\"r6\" : 0, \"r7\" : 0, \"r8\" : 0, \"r9\" : 0, \"r10\" : 0, \r\n\t\t\t\"r11\" : 0, \"r12\" : 0, \"r13\" : 0, \"r14\" : 0, \"r15\" : 0,\r\n\t\t\t\"r16\" : 0, \"r17\" : 0, \"r18\" : 0, \"r19\" : 0, \"r20\" : 0, \r\n\t\t\t\"r21\" : 0, \"r22\" : 0, \"r23\" : 0, \"r24\" : 0, \"r25\" : 0,\r\n\t\t\t\"r26\" : 0, \"r27\" : 0, \"r28\" : 0, \"r29\" : 0, \"r30\" : 0, \r\n\t\t\t\"r31\" : 0,\r\n\t\t\t// Special-purpose registers\r\n\t\t\t\"s0\" : 1, \"s1\" : 0, \"s2\" : 0, \"s3\" : 0, \"s4\" : 0, \"s5\" : 0,\r\n\t\t\t\"s6\" : 0, \"s7\" : 0, \"s8\" : 0, \"s9\" : 0, \"s10\" : 0,\r\n\t\t\t\"s11\" : 0, \"s12\" : 0, \"s13\" : 0, \"s14\" : 0, \"s15\" : 0,\r\n\t\t\t// Predicate registers\r\n\t\t\t\"p0\": 1, \"p1\": 0, \"p2\" : 0, \"p3\" : 0, \"p4\" : 0, \"p5\" : 0,\r\n\t\t\t\"p6\" : 0, \"p7\" : 0\r\n\t\t};\r\n\t\tthis.mem = {\r\n\t\t\t\"TEXT_END\" \t: 0,\r\n\t\t\t\"BASE_ADDR\"\t: 0x0,\r\n\t\t\t\"MAX_SIZE\"\t: 0x00200000 // 2MiB\r\n\t\t};\r\n\t\tthis.cpu = {\r\n\t\t\t\"base\": 0,\r\n\t\t\t\"pc\": 0\r\n\t\t};\r\n\t}\r\n\t\r\n\treset() {\r\n\t\tthis.history = [];\r\n\t\tthis.mem = {\r\n\t\t\t\"TEXT_END\" \t: 0,\r\n\t\t\t\"BASE_ADDR\"\t: 0x0,\r\n\t\t\t\"MAX_SIZE\"\t: 0x00200000 // 2MiB\r\n\t\t};\r\n\t\tthis.reg = {\r\n\t\t\t// General-purpose registers\r\n\t\t\t\"r0\" : 0,\r\n\t\t\t\"r1\" : 0, \"r2\" : 0, \"r3\" : 0, \"r4\" : 0, \"r5\" : 0,\r\n\t\t\t\"r6\" : 0, \"r7\" : 0, \"r8\" : 0, \"r9\" : 0, \"r10\" : 0, \r\n\t\t\t\"r11\" : 0, \"r12\" : 0, \"r13\" : 0, \"r14\" : 0, \"r15\" : 0,\r\n\t\t\t\"r16\" : 0, \"r17\" : 0, \"r18\" : 0, \"r19\" : 0, \"r20\" : 0, \r\n\t\t\t\"r21\" : 0, \"r22\" : 0, \"r23\" : 0, \"r24\" : 0, \"r25\" : 0,\r\n\t\t\t\"r26\" : 0, \"r27\" : 0, \"r28\" : 0, \"r29\" : 0, \"r30\" : 0, \r\n\t\t\t\"r31\" : 0,\r\n\t\t\t// Special-purpose registers\r\n\t\t\t\"s0\" : 1, \"s1\" : 0, \"s2\" : 0, \"s3\" : 0, \"s4\" : 0, \"s5\" : 0,\r\n\t\t\t\"s6\" : 0, \"s7\" : 0, \"s8\" : 0, \"s9\" : 0, \"s10\" : 0,\r\n\t\t\t\"s11\" : 0, \"s12\" : 0, \"s13\" : 0, \"s14\" : 0, \"s15\" : 0,\r\n\t\t\t// Predicate registers\r\n\t\t\t\"p0\": 1, \"p1\": 0, \"p2\" : 0, \"p3\" : 0, \"p4\" : 0, \"p5\" : 0,\r\n\t\t\t\"p6\" : 0, \"p7\" : 0\r\n\t\t};\r\n\t\tthis.cpu = {\r\n\t\t\t\"base\": 0,\r\n\t\t\t\"pc\": 0\r\n\t\t};\r\n\t}\r\n\t\r\n\tgetMemory() {\r\n\t\treturn this.mem;\r\n\t}\r\n\r\n\tgetReg() {\r\n\t\treturn this.reg; \r\n\t}\r\n\r\n\tupdateHistory(){\r\n\t\tlet r, m, c;\r\n\t\tr = Object.assign({}, this.reg);\r\n\t\tm = Object.assign({}, this.mem);\r\n\t\tc = Object.assign({}, this.cpu);\r\n\t\tthis.history.push({reg: r, mem: m, cpu: c});\r\n\t}\r\n\t\r\n\trewindOnce(){\r\n\t\tlet prev = this.history.pop();\r\n\t\tif(!prev)\r\n\t\t\treturn false;\r\n\t\tthis.reg = prev.reg;\r\n\t\tthis.mem = prev.mem;\r\n\t\tthis.cpu = prev.cpu;\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nexport default ProcessorState;\r\n","const pseudoTypes = [\r\n\t\"mov\", \"clr\", \"neg\", \"not\", \"li\", \"nop\", \"isodd\", \"pmov\", \"pnot\", \"pset\", \"pclr\"\r\n];\r\nconst binTypes = [\r\n\t\"add\", \"addi\", \"addl\", \"sub\", \"subi\", \"subl\", \"xor\", \"xori\", \"xorl\", \"sl\", \"sli\", \"sll\",\r\n\t\"sr\", \"sri\", \"srl\", \"sra\", \"srai\", \"sral\", \"nor\", \"norl\", \"shadd\", \"shadd2\", \"or\", \"ori\", \"orl\",\r\n\t\"and\", \"andi\", \"andl\",\r\n];\r\nconst compTypes = [\r\n\t\"btest\", \"btesti\", \"cmpeq\", \"cmpieq\", \"cmple\", \"cmpile\", \"cmplt\", \"cmpilt\", \r\n\t\"cmpneq\", \"cmpineq\", \"cmpule\", \"cmpiule\", \"cmpult\", \"cmpiult\"\r\n];\r\nconst loadTypes = [\r\n\t\"lbc\", \"lbl\", \"lbm\", \"lbs\", \"lbuc\", \"lbul\", \"lbum\", \"lbus\", \"lhc\", \"lhl\", \r\n\t\"lhm\", \"lhs\", \"lhuc\", \"lhul\", \"lhum\", \"lhus\", \"lwc\", \"lwl\", \"lwm\", \"lws\" \r\n];\r\nconst storeTypes = [\r\n\t\"sbc\", \"sbl\", \"sbm\", \"sbs\", \"shc\", \"shl\", \"shm\", \"shs\", \"swc\", \"swl\", \"swm\", \"sws\" \r\n];\r\nconst mulTypes = [\r\n\t\"mul\", \"mulu\"\t\r\n];\r\nconst stackTypes = [\r\n\t\"sens\", \"sfree\", \"sres\", \"sspill\",\r\n\t\"sspillr\", \"sensr\",\r\n];\r\nconst predTypes = [\r\n\t\"pand\", \"por\", \"pxor\"\r\n];\r\nconst moveTypes = [\r\n\t\"mts\", \"mfs\"\r\n];\r\nconst cfTypes = [\r\n\t\"callnd\", \"call\", \"brnd\", \"br\", \"brcfnd\", \"brcf\", \"trap\",\r\n\t\"retnd\", \"ret\", \"xretnd\", \"xret\",\r\n\r\n\t// Single reg\r\n\t\"callndr\", \"callr\", \"brndr\", \"brr\",\r\n\r\n\t// Two reg\r\n\t\"brcfr\", \"brcfndr\"\r\n];\r\nconst bitCopyTypes = [\r\n\t\"bcopy\"\r\n];\r\n\r\nconst instTypes = [].concat(\r\n\tpseudoTypes, binTypes, compTypes, loadTypes, storeTypes, \r\n\tmulTypes, stackTypes, predTypes, moveTypes, cfTypes, bitCopyTypes\r\n);\r\n\r\nconst pseudoMapping = {\r\n\t\"MOV_RR\" \t: \"add {1} = {2}, 0\",  \t\t// add \r\n\t\"CLR\" \t\t: \"add {1} = r0, 0\", \t\t// add\r\n\t\"NEG\" \t\t: \"sub {1} = r0, {2}\",\t\t// sub\r\n\t\"NOT\" \t\t: \"nor {1} = {2}, r0\",\t\t// nor\r\n\t\"LI_POS\" \t: \"add {1} = r0, {2}\",\t\t// add\r\n\t\"LI_NEG\" \t: \"sub {1} = r0, {2}\",\t\t// sub\r\n\t\"NOP\"\t\t: \"sub r0 = r0, 0\", \t\t// sub\r\n\t\"ISODD\" \t: \"btest {1} = {2}, r0\",\t// btest\r\n\t\"MOV_PR\" \t: \"cmpneq {1} = {2}, r0\",\t// cmpneq\r\n\t\"PMOV\" \t\t: \"por {1} = {2}, {2}\",\t\t// por\r\n\t\"PNOT\" \t\t: \"pxor {1} = {2}, p0\",\t\t// pxor\r\n\t\"PSET\" \t\t: \"por {1} = p0, p0\",\t\t// por\r\n\t\"PCLR\"\t\t: \"pxor {1} = p0, p0\",\t\t// pxor\r\n\t\"MOV_RP\" \t: \"bcopy {1} = r0, 0, {2}\" \t// bcopy\r\n};\r\n\r\n// Checks if type is allowed in pipeline two. \r\nconst allowedPipelineTwo = (type) => {\r\n\treturn binTypes.includes(type) || compTypes.includes(type);\r\n};\r\n\r\nconst getInstType = (type) => {\r\n\tlet idx, key, keys;\r\n\r\n\tlet instTypeStr = {\r\n\t\tbin \t: binTypes.includes(type),\r\n\t\tcomp \t: compTypes.includes(type),\r\n\t\tload\t: loadTypes.includes(type),\r\n\t\tstore \t: storeTypes.includes(type),\r\n\t\tmul\t\t: mulTypes.includes(type),\r\n\t\tstack\t: stackTypes.includes(type),\r\n\t\tpred \t: predTypes.includes(type),\r\n\t\tcf \t\t: cfTypes.includes(type),\r\n\t};\r\n\t\r\n\tkeys = Object.keys(instTypeStr);\r\n\t\r\n\tfor (idx in keys) {\r\n\t\tkey = keys[idx];\r\n\t\tif (instTypeStr[key]) return key;\r\n\t}\r\n\treturn type;\r\n};\r\n\r\n\r\nexport { instTypes, binTypes, compTypes, loadTypes, storeTypes, mulTypes, \r\n\tstackTypes, predTypes, moveTypes, cfTypes, getInstType, allowedPipelineTwo,\r\n\tpseudoTypes, pseudoMapping };\r\n","// Arrays of register strings\r\nconst regStr = [\r\n\t\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \r\n\t\"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \r\n\t\"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\"\r\n];\r\nconst pregStr = [\r\n\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\r\n\t\"!p0\", \"!p1\", \"!p2\", \"!p3\", \"!p4\", \"!p5\", \"!p6\", \"!p7\",\r\n];\r\nconst sregStr = [\r\n\t\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \r\n\t\"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\"\r\n];\r\nconst allRegStr = [].concat(\r\n\tregStr, pregStr, sregStr\r\n);\r\n\r\nconst sregMap = {\r\n\tsl : \"s2\",\r\n\tsh : \"s3\",\r\n\tss : \"s5\",\r\n\tst : \"s6\",\r\n\tsrb : \"s7\",\r\n\tsro : \"s8\",\r\n\tsxb : \"s9\",\r\n\tsxo : \"s10\",\r\n};\r\n\r\nexport { regStr, pregStr, sregStr, allRegStr, sregMap };\r\n","import ProcessorState from \"./ProcessorState\";\r\nimport { binTypes, cfTypes } from \"../../Helpers/typeStrings\";\r\nimport { allRegStr } from \"../../Helpers/regStrings\";\r\n\r\nclass CPU {\r\n\tconstructor() {\r\n\t\tthis.state = new ProcessorState();\r\n\t\tthis.history = [];\r\n\t\tthis.bundles = {};\r\n\t\tthis.pending_branch = null;\r\n\t\twindow.state = this.state;\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.state.reset();\r\n\t\tthis.history = [];\r\n\t\tthis.bundles = {};\r\n\t\tthis.pending_branch = null;\r\n\t}\r\n\r\n\tgetPC() {\r\n\t\treturn this.state.cpu[\"pc\"];\r\n\t}\r\n\r\n\tstep() {\r\n\t\tlet bundle = this.bundles[this.state.cpu.pc];\r\n\t\tif(!bundle) return false;\r\n\t\tthis.state.updateHistory();\r\n\t\tbundle.length === 2 ? this.dualIssue(bundle) : this.execute(bundle[0].instruction);\r\n\t\tif (this.pending_branch) this.handlePendingBranch();\r\n\t\treturn true;\r\n\t}\r\n\r\n\tdualIssue(bundle) {\r\n\t\t// slight spaghetti to ensure that bundles like (p0) addi r1 = r0, 5 || (p0) addi r2 = r1, 5; work\r\n\t\tlet pc = this.state.cpu.pc;\r\n\t\tlet conflicts = {};\r\n\t\tfor(let op of bundle[0].ops){\r\n\t\t\tif(allRegStr.includes(op) && bundle[1].ops.includes(op)){\r\n\t\t\t\tconflicts[op] = {};\r\n\t\t\t}\r\n\t\t}\r\n\t\t// store original values\r\n\t\tfor(let conflict in conflicts){\r\n\t\t\tconflicts[conflict].prev = this.state.reg[conflict];\r\n\t\t}\r\n\t\t// execute\r\n\t\tthis.execute(bundle[0].instruction);\r\n\t\t// store and reset\r\n\t\tfor(let conflict in conflicts){\r\n\t\t\tif(conflicts[conflict].prev !== this.state.reg[conflict]){\r\n\t\t\t\tconflicts[conflict].next = this.state.reg[conflict];\r\n\t\t\t\tthis.state.reg[conflict] = conflicts[conflict].prev;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// execute\r\n\t\tthis.execute(bundle[1].instruction);\r\n\t\t// recover\r\n\t\tfor(let conflict in conflicts){\r\n\t\t\tif(conflicts[conflict].next) \r\n\t\t\t\tthis.state.reg[conflict] = conflicts[conflict].next;\r\n\t\t}\r\n\r\n\t\tthis.state.cpu.pc = pc + 8;\r\n\t}\r\n\r\n\thandlePendingBranch() {\r\n\t\tif(this.pending_branch.delay !== 0){\r\n\t\t\tthis.pending_branch.delay--;\r\n\t\t} else {\r\n\t\t\tif(this.pending_branch.inst.name === \"br\"){\r\n\t\t\t\tthis.state.cpu.pc = this.pending_branch.pc;\r\n\t\t\t} else {\r\n\t\t\t\tthis.state.cpu.pc -= 4;\r\n\t\t\t}\r\n\t\t\tthis.pending_branch.inst.execute(this.state);\r\n\t\t\tthis.pending_branch = null;\r\n\t\t}\r\n\t}\r\n\r\n\t// Step one instruction backwards in queue\r\n\tprev() {\r\n\t\tthis.state.rewindOnce();\r\n\t}\r\n\r\n\t// Run all instructions.\r\n\trun() {\r\n\t\tlet n = 0;\r\n\t\tlet start, end;\r\n\t\tstart = performance.now();\r\n\t\twhile(this.bundles[this.state.cpu.pc]){\r\n\t\t\tthis.step();\r\n\t\t\tn++;\r\n\t\t}\r\n\t\tend = performance.now();\r\n\t\tconsole.log(n, \"bundles executed in\", end-start, \"ms.\");\r\n\t\tconsole.log(n/((end-start)/1000), \"bundles pr. second.\");\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Map bundle array to corresponding offsets\r\n\t * @param {Object[]} bundles - An array of bundle objects.\r\n\t */\r\n\tpopulate(bundles){\r\n\t\tthis.reset();\r\n\t\tlet bundle, addr, base_set = false;\r\n\r\n\t\tfor(bundle of bundles){\r\n\t\t\taddr = bundle.offset;\r\n\t\t\tif(bundle.is_data){\r\n\t\t\t\tswitch(bundle.data.type){\r\n\t\t\t\t\tcase \"word\":\r\n\t\t\t\t\t\tthis.state.mem[addr + 3] = bundle.data.value & 0xFF;\r\n\t\t\t\t\t\tthis.state.mem[addr + 2] = (bundle.data.value >> 8) & 0xFF;\r\n\t\t\t\t\t\tthis.state.mem[addr + 1] = (bundle.data.value >> 16) & 0xFF;\r\n\t\t\t\t\t\tthis.state.mem[addr + 0] = (bundle.data.value >> 24) & 0xFF;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif(!base_set){\r\n\t\t\t\t\tthis.state.cpu.base = addr;\r\n\t\t\t\t\tthis.state.cpu.pc = addr;\r\n\t\t\t\t\tbase_set = true;\r\n\t\t\t\t}\r\n\t\t\t\tthis.bundles[addr] = bundle.instructions;\r\n\t\t\t\tthis.setMem(addr, bundle);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (bundle === undefined)\r\n\t\t\treturn false;\r\n\r\n\t\tthis.state.mem[\"TEXT_END\"] = Number(addr) + bundle.size;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tsetMem(addr, bundle){\r\n\t\tlet o = 0;\r\n\t\tfor(let inst of bundle.instructions){\r\n\t\t\tfor(let int of inst.instruction.binary){\r\n\t\t\t\tthis.state.mem[addr + o + 3] = int & 0xFF;\r\n\t\t\t\tthis.state.mem[addr + o + 2] = (int >> 8) & 0xFF;\r\n\t\t\t\tthis.state.mem[addr + o + 1] = (int >> 16) & 0xFF;\r\n\t\t\t\tthis.state.mem[addr + o + 0] = (int >> 24) & 0xFF;\r\n\t\t\t\to += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n \t* @param {Object} inst - Instruction object\r\n\t*/\r\n\texecute(inst) {\r\n\t\tif ( ((inst.pred & 0b1000) >>> 3) !== this.state.reg[`p${inst.pred & 0b0111}`] ) {\r\n\t\t\tif(!cfTypes.includes(inst.name) || inst.name.includes(\"nd\")){\r\n\t\t\t\tinst.execute(this.state);\r\n\t\t\t} else {\r\n\t\t\t\tlet delay = 0;\r\n\t\t\t\tswitch(inst.name){\r\n\t\t\t\t\tcase \"br\":\r\n\t\t\t\t\t\tdelay = 2;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tdelay = 3;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tthis.pending_branch = { delay, inst, pc: this.state.cpu.pc };\r\n\t\t\t\tthis.state.cpu.pc += 4;\r\n\t\t\t}\r\n\t\t} else if (cfTypes.includes(inst.name)){\r\n\t\t\tthis.state.cpu.pc += 4;\r\n\t\t}\r\n\r\n\t\tif(binTypes.includes(inst.name) && inst.type === \"l\") {\r\n\t\t\tthis.state.cpu.pc += 8;\r\n\t\t} else if(!cfTypes.includes(inst.name)){\r\n\t\t\tthis.state.cpu.pc += 4;\r\n\t\t}\r\n\t\tthis.setReadReg();\r\n\t}\r\n\r\n\tgetReg() {\r\n\t\treturn this.state.getReg();\r\n\t}\r\n\r\n\tgetMem() {\r\n\t\treturn this.state.getMemory();\r\n\t}\r\n\r\n\tsetReadReg() {\r\n\t\tthis.state.reg.r0 = 0;\r\n\t\tthis.state.reg.p0 = 1;\r\n\t\tthis.state.reg.s0 = 0;\r\n\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\tthis.state.reg.s0 |= this.state.reg[`p${i}`] << i;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default CPU;\r\n","import { compile_reg, compile_imm, compile_long } from \"./compilers\";\r\n\r\n/** \r\n * Represents a BinaryArithmetics instruction. Sets common fields. \r\n */\r\nclass BinaryArithmetics {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {number}          fields.func - Instruction function\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ name, func, pred, rd, rs1, op2 }) {\r\n\t\tthis.type = isNaN(op2) ? \"r\" : (Number(op2) > 0x0FFF ? \"l\" : \"i\");\r\n\t\tthis.pred = pred;\r\n\t\tthis.rd = rd;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.op2 = op2;\r\n\t\tthis.name = name;\r\n\t\tthis.func = func;\r\n        \r\n\t\t// nor, shadd, shadd2 does not have an immediate format\r\n\t\tif([0b1011, 0b1100, 0b1101].includes(func) && this.type === \"i\"){\r\n\t\t\tthis.type = \"l\";\r\n\t\t}\r\n\r\n\t\tswitch (this.type) {\r\n\t\t\tcase \"r\":\r\n\t\t\t\tthis.binary = compile_reg(pred, rd, rs1, op2, func);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"i\":\r\n\t\t\t\tthis.op2 &= 0xFFF;\r\n\t\t\t\tthis.binary = compile_imm(pred, func, rd, rs1, op2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"l\":\r\n\t\t\t\tthis.binary = compile_long(pred, rd, rs1, func, op2);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unexpected type in ${this.name}`);\r\n\t\t}\r\n\t}\r\n    \r\n\texecute(){\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = ${this.rs1}, ${this.op2}`;\r\n\t}\r\n}\r\n\r\nexport default BinaryArithmetics;","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rd, rs1, rs2, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\trd = parseReg(rd);\r\n\trs1 = parseReg(rs1);\r\n\trs2 = parseReg(rs2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= rs2 << 7;\r\n\tbinary[0] |= func << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_imm = (pred, func, rd, rs1, imm) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\timm = parseNum(imm);\r\n\trd = parseReg(rd);\r\n\trs1 = parseReg(rs1);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= (func & 0x7) << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= imm << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_long = (pred, rd, rs1, func, long) => {\r\n\tlet binary = [0, 0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\tlong = parseNum(long);\r\n\trd = parseReg(rd);\r\n\trs1 = parseReg(rs1);\r\n\r\n\tbinary[0] |= 1 << 31;\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b11111 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= func;\r\n\tbinary[1] = long & 0xFFFFFFFF;\r\n    \r\n\treturn binary;\r\n};\r\n","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Addition instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Add extends BinaryArithmetics {\r\n\t/**\r\n     * Create Add instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"add\", func: 0, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] + (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default Add;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Negated Bitwise OR instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Nor extends BinaryArithmetics {\r\n\t/**\r\n     * Create Nor instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"nor\", func: 11, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = ~((reg[this.rs1] | (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0);\r\n\t}\r\n}\r\n\r\nexport default Nor;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift-by-1-then-Add instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftAdd extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftAdd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"shadd\", func: 12, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = ((reg[this.rs1] << 1) + (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftAdd;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift-by-2-then-Add instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftAdd2 extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftAdd2 instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"shadd2\", func: 13, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = ((reg[this.rs1] << 2) + (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftAdd2;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift left instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftLeft extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftLeft instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"sl\", func: 3, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] << (this.type === \"r\" ? reg[this.op2] & 0x1F : Number(this.op2) & 0x1F)) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftLeft;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift right instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftRight extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftRight instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"sr\", func: 4, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] >>> (this.type === \"r\" ? reg[this.op2] & 0x1F : Number(this.op2) & 0x1F)) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftRight;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift right arithmetic instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftRightArithmetic extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftRightArithmetic instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"sra\", func: 5, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] >> (this.type === \"r\" ? reg[this.op2] & 0x1F : Number(this.op2) & 0x1F)) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftRightArithmetic;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Subtraction instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Sub extends BinaryArithmetics {\r\n\t/**\r\n     * Create Sub instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"sub\", func: 1, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] - (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default Sub;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Bitwise Exclusive OR instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Xor extends BinaryArithmetics {\r\n\t/**\r\n     * Create Xor instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"xor\", func: 2, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] ^ (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default Xor;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Or instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Or extends BinaryArithmetics {\r\n\t/**\r\n     * Create Or instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"or\", func: 6, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = reg[this.rs1] | (this.type === \"r\" ? reg[this.op2] : Number(this.op2));\r\n\t}\r\n}\r\n\r\nexport default Or;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * And instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass And extends BinaryArithmetics {\r\n\t/**\r\n     * Create And instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"and\", func: 7, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = reg[this.rs1] & (this.type === \"r\" ? reg[this.op2] : Number(this.op2));\r\n\t}\r\n}\r\n\r\nexport default And;","import { compile_reg, compile_imm } from \"./compilers\";\r\n\r\n/** \r\n * Represents a Compare instruction. Sets common fields. \r\n */\r\nclass Compare {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {number}          fields.func - Instruction function\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ name, pred, pd, rs1, op2, func }) {\r\n\t\tthis.type = isNaN(op2) ? \"r\" : \"i\";\r\n\t\tthis.pred = pred;\r\n\t\tthis.pd = pd;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.op2 = op2;\r\n\t\tthis.name = name;\r\n\t\tthis.func = func;\r\n\r\n\t\tswitch (this.type) {\r\n\t\t\tcase \"r\":\r\n\t\t\t\tthis.binary = compile_reg(pred, pd, rs1, op2, func);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"i\":\r\n\t\t\t\tthis.op2 &= 0x1F;\r\n\t\t\t\tthis.binary = compile_imm(pred, pd, rs1, op2, func);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unexpected type in ${this.name}`);\r\n\t\t}\r\n\t}\r\n    \r\n\texecute(){\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.pd} = ${this.rs1}, ${this.op2}`;\r\n\t}\r\n}\r\n\r\nexport default Compare;","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, pd, rs1, rs2, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\tpd = parseReg(pd);\r\n\trs1 = parseReg(rs1);\r\n\trs2 = parseReg(rs2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= pd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= rs2 << 7;\r\n\tbinary[0] |= 0b011 << 4;\r\n\tbinary[0] |= func << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_imm = (pred, pd, rs1, imm, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\timm = parseNum(imm);\r\n\tpd = parseReg(pd);\r\n\trs1 = parseReg(rs1);\r\n    \r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= pd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= ((imm & 0x1F) << 7);\r\n\tbinary[0] |= 0b110 << 4;\r\n\tbinary[0] |= func << 0;\r\n    \r\n\treturn binary;\r\n};\r\n\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Btest instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Btest extends Compare {\r\n\t/**\r\n     * Create Btest instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"btest\", func: 0b0110, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number((reg[this.rs1] & ( 1 << (this.type === \"r\" ? reg[this.op2] : Number(this.op2) & 0x1F ))) !== 0);\r\n\t}\r\n}\r\n\r\nexport default Btest;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmpeq instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmpeq extends Compare {\r\n\t/**\r\n     * Create Cmpeq instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmpeq\", func: 0b0000, pred, pd, rs1, op2});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number(reg[this.rs1] === (this.type === \"r\" ? \r\n\t\t\treg[this.op2] : ((Number(this.op2) << 27) >> 27)));\r\n\t}\r\n}\r\n\r\nexport default Cmpeq;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Btest instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmple extends Compare {\r\n\t/**\r\n     * Create Cmple instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmple\", func: 0b0011, pred, pd, rs1, op2});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number(reg[this.rs1] <= (this.type === \"r\" ? \r\n\t\t\treg[this.op2] : (Number(this.op2) << 27) >> 27));\r\n\t}\r\n}\r\n\r\nexport default Cmple;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmplt instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmplt extends Compare {\r\n\t/**\r\n     * Create Cmplt instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmplt\", func: 0b0010, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number(reg[this.rs1] < (this.type === \"r\" ? \r\n\t\t\treg[this.op2] : (Number(this.op2) << 27) >> 27));\r\n\t}\r\n}\r\n\r\nexport default Cmplt;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmpneq instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmpneq extends Compare {\r\n\t/**\r\n     * Create Cmpneq instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmpneq\", func: 0b0001, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number(reg[this.rs1] !== (this.type === \"r\" ? \r\n\t\t\treg[this.op2] : (Number(this.op2) << 27) >> 27));\r\n\t}\r\n}\r\n\r\nexport default Cmpneq;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmpule instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmpule extends Compare {\r\n\t/**\r\n     * Create Cmpule instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmpule\", func: 0b0101, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number((reg[this.rs1] >>> 0) <= ((this.type === \"r\" ? \r\n\t\t\treg[this.op2] : Number(this.op2)) >>> 0));\r\n\t}\r\n}\r\n\r\nexport default Cmpule;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmpult instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmpult extends Compare {\r\n\t/**\r\n     * Create Cmpult instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmpult\", func: 0b0100, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */   execute( { reg } ) {\r\n\t\treg[this.pd] = \r\n\t\t\tNumber((reg[this.rs1] >>> 0) < ((this.type === \"r\" ? \r\n\t\t\t\treg[this.op2] : Number(this.op2))) >>> 0);\r\n\t}\r\n}\r\n\r\nexport default Cmpult;\r\n","import { compile_reg, compile_reg2, compile_ireg, compile_imm } from \"./compilers\";\r\n\r\n/** \r\n * Represents a ControlFlow instruction. Sets common fields. \r\n */\r\nclass ControlFLow {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.op   - Type of control\r\n\t * @param {string}          fields.s1   - Either source register or immediate value\r\n\t * @param {string}          fields.s2   - Source register 2.\r\n     */\r\n\tconstructor({ name, pred, d, op, s1, s2 }) {\r\n\t\tthis.type = (!s1 && !s2) ? \"implicit\" : (isNaN(s1) ? (!s2 ? \"single_reg\" : \"two_reg\") : \"immediate\");\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.d = d;\r\n\t\tthis.op = op;\r\n\t\tthis.s1 = s1;\r\n\t\tthis.s2 = s2;\r\n\r\n\t\tswitch(this.type){\r\n\t\t\tcase \"implicit\":\r\n\t\t\t\tthis.binary = compile_ireg(this.pred, this.d, this.op);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"single_reg\":\r\n\t\t\t\tthis.binary = compile_reg(this.pred, this.d, this.op, this.s1);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"two_reg\":\r\n\t\t\t\tthis.binary = compile_reg2(this.pred, this.d, this.op, this.s1, this.s2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"immediate\":\r\n\t\t\t\tthis.s1 &= 0x3FFFFF;\r\n\t\t\t\tthis.binary = compile_imm(this.pred, this.op, this.d, this.s1);\r\n\t\t\t\tthis.s1 = (Number(this.s1) << 10) >> 8;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unexpected type in ${this.name}`);\r\n\t\t}\r\n\t}\r\n\texecute(){\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\ttoString(){\r\n\t\tlet s1 = this.s1 ? isNaN(this.s1) ? this.s1 : this.s1 >> 2 : \"\";\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${s1} ${this.s2 ? \", \"+this.s2 : \"\"}`;\r\n\t}\r\n}\r\n\r\nexport default ControlFLow;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, d, op, rs1) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\td = parseNum(d);\r\n\top = parseNum(op);\r\n\trs1 = parseReg(rs1);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b1100 << 23;\r\n\tbinary[0] |= d << 22;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= 0b01 << 2;\r\n\tbinary[0] |= op << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_reg2 = (pred, d, op, rs1, rs2) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\td = parseNum(d);\r\n\top = parseNum(op);\r\n\trs1 = parseReg(rs1);\r\n\trs2 = parseReg(rs2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b1100 << 23;\r\n\tbinary[0] |= d << 22;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= rs2 << 7;\r\n\tbinary[0] |= 0b10 << 2;\r\n\tbinary[0] |= op << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_ireg = (pred, d, op) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\td = parseNum(d);\r\n\top = parseNum(op);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b1100 << 23;\r\n\tbinary[0] |= d << 22;\r\n\tbinary[0] |= 0b00 << 2;\r\n\tbinary[0] |= op << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_imm = (pred, op, d, imm) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\top = parseNum(op);\r\n\td = parseNum(d); \r\n\timm = parseNum(imm);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b10 << 25;\r\n\tbinary[0] |= op << 23;\r\n\tbinary[0] |= d << 22;\r\n\tbinary[0] |= imm << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Br instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Br extends ControlFlow {\r\n\t/**\r\n     * Create Br instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"br\", d: 1, op: 0b01, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\tcpu.pc = this.type === \"immediate\" ? cpu.pc + addr : addr;\r\n\t}\r\n}\r\n\r\nexport default Br;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Br instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Brcf extends ControlFlow {\r\n\t/**\r\n     * Create Brcf instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"brcf\", d: 1, op: 0b10, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\tlet offset = this.type === \"two_reg\" ? reg[this.s2] : 0;\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr + offset;\r\n\t}\r\n}\r\n\r\nexport default Brcf;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Br instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Brcfnd extends ControlFlow {\r\n\t/**\r\n     * Create Brcfnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"brcfnd\", d: 0, op: 0b10, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\tlet offset = this.type === \"two_reg\" ? reg[this.s2] : 0;\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr + offset;\r\n\t}\r\n}\r\n\r\nexport default Brcfnd;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Brnd instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Brnd extends ControlFlow {\r\n\t/**\r\n     * Create Brnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"brnd\", d: 0, op: 0b01, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\tcpu.pc = (this.type === \"immediate\" ? cpu.pc + addr : addr);\r\n\t}\r\n}\r\n\r\nexport default Brnd;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Call instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Call extends ControlFlow {\r\n\t/**\r\n     * Create Call instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"call\", d: 1, op: 0b00, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\treg.s7 = cpu.base; \t// srb\r\n\t\treg.s8 = cpu.pc;\t// sro\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr; \t\t// should be offset(addr) but as we have no cache...\r\n\t}\r\n}\r\n\r\nexport default Call;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Call instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Callnd extends ControlFlow {\r\n\t/**\r\n     * Create Callnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"callnd\", d: 0, op: 0b00, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1 : reg[this.s1];\r\n\t\treg.s7 = cpu.base;\t// srb\r\n\t\treg.s8 = cpu.pc;\t// sro\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr; \t\t// should be offset(addr) but as we have no cache...\r\n\t}\r\n}\r\n\r\nexport default Callnd;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Ret instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Ret extends ControlFlow {\r\n\t/**\r\n     * Create Ret instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"ret\", d: 1, op: 0b00, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\t//srb s7, sro s8\r\n\t\tcpu.base = reg.s7;\r\n\t\tcpu.pc = reg.s8 + 4; //should be offset(srb) + sro, but as we don't have cache. Also +4 is to set it to the next instruction.\r\n\t}\r\n}\r\n\r\nexport default Ret;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Retnd instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Retnd extends ControlFlow {\r\n\t/**\r\n     * Create Retnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"retnd\", d: 0, op: 0b00, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\t//srb s7, sro s8\r\n\t\tcpu.base = reg.s7;\r\n\t\tcpu.pc = reg.s8 + 4; //should be offset(sxb) + sxo, but as we don't have cache.\r\n\t}\r\n}\r\n\r\nexport default Retnd;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Trap instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Trap extends ControlFlow {\r\n\t/**\r\n     * Create Trap instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"trap\", d: 0, op: 0b11, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = 0xf0010080 + this.s1;\t//exception table base addr: 0xF0010080\r\n\t\treg.s9 = cpu.base; \t\t\t\t\t// sxb\r\n\t\treg.s10 = cpu.pc;\t\t\t\t\t// sxo\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr; \t\t\t\t\t\t// should be offset(addr) but as we have no cache...\r\n\t}\r\n}\r\n\r\nexport default Trap;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Xret instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Xret extends ControlFlow {\r\n\t/**\r\n     * Create Xret instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"xret\", d: 1, op: 0b01, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\t//sxb s9, sxo s10\r\n\t\tcpu.base = reg.s9;\r\n\t\tcpu.pc = reg.s10 + 4; //should be offset(sxb) + sxo, but as we don't have cache.\r\n\t}\r\n}\r\n\r\nexport default Xret;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Xretnd instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Xretnd extends ControlFlow {\r\n\t/**\r\n     * Create Xretnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"xretnd\", d: 0, op: 0b01, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\t//sxb s9, sxo s10\r\n\t\tcpu.base = reg.s9;\r\n\t\tcpu.pc = reg.s10 + 4; //should be offset(sxb) + sxo, but as we don't have cache.\r\n\t}\r\n}\r\n\r\nexport default Xretnd;","import { compile_reg } from \"./compilers\";\r\nimport { toUint32 } from \"../../../Helpers/misc\";\r\n\r\n/** \r\n * Represents a LoadTyped instruction. Sets common fields. \r\n */\r\nclass LoadTyped {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n     * @param {string}   \t\tfields.type - Instruction type\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ name, pred, rd, ra, type, imm }) {\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.rd = rd;\r\n\t\tthis.ra = ra;\r\n\t\tthis.type = type;\r\n\t\tthis.imm = toUint32(imm) & 0x7F;\t// Imm is interpreted unsigned\r\n\t\tthis.binary = compile_reg(pred, rd, ra, type, imm);\r\n\t}\r\n\r\n\texecute() {\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = [${this.ra} + ${this.imm}]`;\r\n\t}\r\n}\r\nexport default LoadTyped;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rd, ra, type, imm) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\timm = parseNum(imm);\r\n\ttype = parseNum(type);\r\n\trd = parseReg(rd);\r\n\tra = parseReg(ra);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01010 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= ra << 12;\r\n\tbinary[0] |= type << 7;\r\n\tbinary[0] |= imm << 0;\r\n\r\n\treturn binary;\r\n};\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lws instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lws extends LoadTyped {\r\n\t/**\r\n     * Create Lws instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lws\", pred, rd, ra, type: 0b00000, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 2);\r\n\t\tlet hh = mem[reg[\"s6\"] + address + 0];\r\n\t\tlet hl = mem[reg[\"s6\"] + address + 1];\r\n\t\tlet lh = mem[reg[\"s6\"] + address + 2];\r\n\t\tlet ll = mem[reg[\"s6\"] + address + 3];\r\n\r\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\r\n\t}\r\n}\r\n\r\nexport default Lws;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lwl instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lwl extends LoadTyped{\r\n\t/**\r\n     * Create Lwl instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lwl\", pred, rd, ra, type: 0b00001, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 2);\r\n\t\tlet hh = mem[address + 0];\r\n\t\tlet hl = mem[address + 1];\r\n\t\tlet lh = mem[address + 2];\r\n\t\tlet ll = mem[address + 3];\r\n\r\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\r\n\t}\r\n}\r\n\r\nexport default Lwl;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lwc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lwc extends LoadTyped {\r\n\t/**\r\n     * Create Lwc instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lwc\", pred, rd, ra, type: 0b00010, imm });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 2);\r\n\t\tlet hh = mem[address + 0];\r\n\t\tlet hl = mem[address + 1];\r\n\t\tlet lh = mem[address + 2];\r\n\t\tlet ll = mem[address + 3];\r\n\r\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\r\n\t}\r\n}\r\n\r\nexport default Lwc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lwm instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lwm extends LoadTyped {\r\n\t/**\r\n   * Create Lwm instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lwm\", pred, rd, ra, type: 0b00011, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 2);\r\n\t\tlet hh = mem[address + 0];\r\n\t\tlet hl = mem[address + 1];\r\n\t\tlet lh = mem[address + 2];\r\n\t\tlet ll = mem[address + 3];\r\n\r\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\r\n\t}\r\n}\r\n\r\nexport default Lwm;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhs instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhs extends LoadTyped {\r\n\t/**\r\n   * Create Lhs instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhs\", pred, rd, ra, type: 0b00100, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[reg[\"s6\"] + address + 0];\r\n\t\tlet lo = mem[reg[\"s6\"] + address + 1];\r\n\t\r\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16;\r\n\t}\r\n}\r\n\r\nexport default Lhs;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhl instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhl extends LoadTyped{\r\n\t/**\r\n     * Create Lhl instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lhl\", pred, rd, ra, type: 0b00101, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16; \r\n\t}\r\n}\r\n\r\nexport default Lhl;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhc extends LoadTyped{\r\n\t/**\r\n     * Create Lhc instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lhc\", pred, rd, ra, type: 0b00110, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16; \r\n\t}\r\n\r\n}\r\n\r\nexport default Lhc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhm instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhm extends LoadTyped{\r\n\t/**\r\n     * Create Lhm instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lhm\", pred, rd, ra, type: 0b00111, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16; \r\n\t}\r\n}\r\n\r\nexport default Lhm;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbs instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbs extends LoadTyped {\r\n\t/**\r\n\t * Create Lbs instruction.\r\n\t * @param {Object}          fields      - Fields to set \r\n\t * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}          fields.rd   - Destination register\r\n\t * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n\t */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lbs\", pred, rd, ra, type: 0b01000, imm });\r\n\t}\r\n\r\n\t/**\r\n\t * Executes the instruction\r\n\t * @param {Object}                  state        - Processor state\r\n\t * @param {Object.<string, number>} state.reg    - Registers\r\n\t */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = (mem[reg[\"s6\"] + reg[this.ra] + this.imm] << 24) >> 24;\r\n\t}\r\n\r\n}\r\n\r\nexport default Lbs;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbl instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbl extends LoadTyped {\r\n\t/**\r\n     * Create Lbl instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lbl\", pred, rd, ra, type: 0b01001, imm });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = (mem[reg[this.ra] + this.imm] << 24) >> 24;\r\n\t}\r\n}\r\n\r\nexport default Lbl;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbc extends LoadTyped {\r\n\t/**\r\n     * Create Lbc instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n     * @param {string}   \t\tfields.type - Second operand. Can be a second source register or immediate value.\r\n     * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lbc\", pred, rd, ra, type: 0b01010, imm });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = (mem[reg[this.ra] + this.imm] << 24) >> 24;\r\n\t}\r\n}\r\n\r\nexport default Lbc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbm instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbm extends LoadTyped {\r\n\t/**\r\n\t * Create Lbm instruction.\r\n\t * @param {Object}          fields      - Fields to set \r\n\t * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}          fields.rd   - Destination register\r\n\t * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n\t */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lbm\", pred, rd, ra, type: 0b01011, imm });\r\n\t}\r\n\r\n\t/**\r\n\t * Executes the instruction\r\n\t * @param {Object}                  state        - Processor state\r\n\t * @param {Object.<string, number>} state.reg    - Registers\r\n\t */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = (mem[reg[this.ra] + this.imm] << 24) >> 24;\r\n\t}\r\n}\r\n\r\nexport default Lbm;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhus instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhus extends LoadTyped {\r\n\t/**\r\n   * Create Lhus instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhus\", pred, rd, ra, type: 0b01100, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[reg[\"s6\"] + address + 0];\r\n\t\tlet lo = mem[reg[\"s6\"] + address + 1];\r\n\r\n\t\treg[this.rd] = (hi << 8) | lo;\r\n\t}\r\n}\r\n\r\nexport default Lhus;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhul instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhul extends LoadTyped {\r\n\t/**\r\n   * Create Lhul instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhul\", pred, rd, ra, type: 0b01101, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\t\r\n\t\treg[this.rd] = (hi << 8) | lo;\r\n\t}\r\n}\r\n\r\nexport default Lhul;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhuc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhuc extends LoadTyped {\r\n\t/**\r\n   * Create Lhuc instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhuc\", pred, rd, ra, type: 0b01110, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (hi << 8) | lo;\r\n\t}\r\n}\r\n\r\nexport default Lhuc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhum instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhum extends LoadTyped {\r\n\t/**\r\n   * Create Lhum instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhum\", pred, rd, ra, type: 0b01111, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (hi << 8) | lo;\r\n\t}\r\n}\r\n\r\nexport default Lhum;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbus instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbus extends LoadTyped{\r\n\t/**\r\n     * Create Lbus instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lbus\", pred, rd, ra, type: 0b10000, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = mem[reg[\"s6\"] + reg[this.ra] + this.imm] & 0xFF; \r\n\t}\r\n}\r\n\r\nexport default Lbus;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbul instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbul extends LoadTyped{\r\n\t/**\r\n     * Create Lbul instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lbul\", pred, rd, ra, type: 0b10001, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = mem[reg[this.ra] + this.imm] & 0xFF; \r\n\t}\r\n}\r\n\r\nexport default Lbul;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbuc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbuc extends LoadTyped{\r\n\t/**\r\n     * Create Lbuc instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lbuc\", pred, rd, ra, type: 0b10010, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = mem[reg[this.ra] + this.imm] & 0xFF; \r\n\t}\r\n}\r\n\r\nexport default Lbuc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbum instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbum extends LoadTyped{\r\n\t/**\r\n     * Create Lbum instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lbum\", pred, rd, ra, type: 0b10011, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = mem[reg[this.ra] + this.imm] & 0xFF; \r\n\t}\r\n}\r\n\r\nexport default Lbum;\r\n","import { compile_reg } from \"./compilers\";\r\n\r\n/** \r\n * Represents a Multiply instruction. Sets common fields. \r\n */\r\nclass Multiply {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string}          fields.rs2  - Second source register\r\n     * @param {number}          fields.func - Instruction function\r\n     */\r\n\tconstructor({ name, pred, rs1, rs2, func }) {\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.rs2 = rs2;\r\n\t\tthis.func = func; \r\n\t\tthis.binary = compile_reg(pred, rs1, rs2, func);\r\n\t}\r\n    \r\n\texecute(){\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rs1}, ${this.rs2}`;\r\n\t}\r\n}\r\nexport default Multiply;","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rs1, rs2, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\trs1 = parseReg(rs1);\r\n\trs2 = parseReg(rs2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= rs2 << 7;\r\n\tbinary[0] |= 0b010 << 4;\r\n\tbinary[0] |= func << 0;\r\n\r\n\treturn binary;\r\n};\r\n","import Multiply from \"./Multiply\";\r\n\r\n/** \r\n * Mul instruction class. \r\n * @extends Multiply\r\n * @category Multiply\r\n */\r\nclass Mul extends Multiply {\r\n\t/**\r\n     * Create Mul instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string}          fields.rs2  - Second source register\r\n     */\r\n\tconstructor({ pred, rs1, rs2 }) {\r\n\t\tsuper({name: \"mul\", func: 0b0000, pred, rs1, rs2});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[\"s2\"] = Math.imul(reg[this.rs1], reg[this.rs2]);\r\n\t\treg[\"s3\"] = (reg[this.rs1] * reg[this.rs2] / (2**32)) | 0;\r\n\t}\r\n}\r\n\r\nexport default Mul;\r\n","import Multiply from \"./Multiply\";\r\n\r\n/** \r\n * Mulu instruction class. \r\n * @extends Multiply\r\n * @category Multiply\r\n */\r\nclass Mulu extends Multiply {\r\n\t/**\r\n     * Create Mulu instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string}          fields.rs2  - Second source register\r\n     */\r\n\tconstructor({ pred, rs1, rs2 }) {\r\n\t\tsuper({name: \"mulu\", func: 0b0001, pred, rs1, rs2});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[\"s2\"] = Math.imul(reg[this.rs1], reg[this.rs2]);\r\n\t\treg[\"s3\"] = (((reg[this.rs1] >>> 0) * (reg[this.rs2] >>> 0))/(2**32))>>>0;\r\n\t}\r\n}\r\n\r\nexport default Mulu;\r\n","import { compile_reg } from \"./compilers\";\r\n\r\n/** \r\n * Represents a Predicate instruction. Sets common fields. \r\n */\r\nclass Predicate {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}\t\t\tfields.pd \t- Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string}          fields.rs2  - Second source register\r\n     * @param {number}          fields.func - Instruction function\r\n     */\r\n\tconstructor({ name, pred, pd, ps1, ps2, func }) {\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.pd = pd;\r\n\t\tthis.neg1 = ps1[0] === \"!\";\r\n\t\tthis.neg2 = ps2[0] === \"!\";\r\n\t\tthis.ps1 = ps1.replace(\"!\", \"\");\r\n\t\tthis.ps2 = ps2.replace(\"!\", \"\");\r\n\t\tthis.func = func; \r\n\t\tthis.binary = compile_reg(pred, pd, ps1, ps2, func);\r\n\t}\r\n    \r\n\texecute(){\r\n\t\tconsole.error(\"Missing execute handler for\", this);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.pd} = ${this.neg1 ? \"!\" : \"\"}${this.ps1}, ${this.neg2 ? \"!\" : \"\"}${this.ps2}`;\r\n\t}\r\n}\r\n\r\nexport default Predicate;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, pd, ps1, ps2, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\tpd = parseReg(pd);\r\n\tps1 = ps1[0] === \"!\" ? 0b1000 | parseReg(ps1) : parseReg(ps1);\r\n\tps2 = ps2[0] === \"!\" ? 0b1000 | parseReg(ps2) : parseReg(ps2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= pd << 17;\r\n\tbinary[0] |= ps1 << 12;\r\n\tbinary[0] |= ps2 << 7;\r\n\tbinary[0] |= 0b100 << 4;\r\n\tbinary[0] |= func << 0;\r\n\r\n\treturn binary;\r\n};\r\n","import Predicate from \"./Predicate\";\r\n\r\n/** \r\n * Pand instruction class. \r\n * @extends Predicate\r\n * @category Predicate\r\n */\r\nclass Pand extends Predicate {\r\n\t/**\r\n     * Create Pand instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}\t\t\tfields.pd \t- Destination register\r\n     * @param {string}          fields.ps1  - First predicate register\r\n     * @param {string}          fields.ps2  - Second predicate register\r\n     */\r\n\tconstructor({ pred, pd, ps1, ps2 }) {\r\n\t\tsuper({name: \"pand\", pred, pd, ps1, ps2, func:0b0111});\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = ((this.neg1 ? ~reg[this.ps1] : reg[this.ps1]) & (this.neg2 ? ~reg[this.ps2] : reg[this.ps2])) & 0x1;\r\n\t}\r\n}\r\n\r\nexport default Pand;\r\n","import Predicate from \"./Predicate\";\r\n\r\n/** \r\n * Pand instruction class. \r\n * @extends Predicate\r\n * @category Predicate\r\n */\r\nclass Pxor extends Predicate {\r\n\t/**\r\n     * Create Pxor instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}\t\t\tfields.pd \t- Destination register\r\n     * @param {string}          fields.ps1  - First predicate register\r\n     * @param {string}          fields.ps2  - Second predicate register\r\n     */\r\n\tconstructor({ pred, pd, ps1, ps2 }) {\r\n\t\tsuper({name: \"pxor\", pred, pd, ps1, ps2, func:0b1010});\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = ((this.neg1 ? ~reg[this.ps1] : reg[this.ps1]) ^ (this.neg2 ? ~reg[this.ps2] : reg[this.ps2])) & 0x1;\r\n\t}\r\n}\r\n\r\nexport default Pxor;\r\n","import Predicate from \"./Predicate\";\r\n\r\n/** \r\n * Pand instruction class. \r\n * @extends Predicate\r\n * @category Predicate\r\n */\r\nclass Por extends Predicate {\r\n\t/**\r\n     * Create Por instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}\t\t\tfields.pd \t- Destination register\r\n     * @param {string}          fields.ps1  - First predicate register\r\n     * @param {string}          fields.ps2  - Second predicate register\r\n     */\r\n\tconstructor({ pred, pd, ps1, ps2 }) {\r\n\t\tsuper({name: \"por\", pred, pd, ps1, ps2, func:0b0110});\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = ((this.neg1 ? ~reg[this.ps1] : reg[this.ps1]) | (this.neg2 ? ~reg[this.ps2] : reg[this.ps2])) & 0x1;\r\n\t}\r\n}\r\n\r\nexport default Por;\r\n","import { compile_reg, compile_imm } from \"./compilers\";\r\n\r\n/** \r\n * Represents a StackControl instruction. Sets common fields. \r\n */\r\nclass StackControl {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.op   - Type of control\r\n\t * @param {string}          fields.s1   - Either source register or immediate value\r\n     */\r\n\tconstructor({ name, pred, op, s1 }) {\r\n\t\tthis.type = isNaN(s1) ? \"r\" : \"i\";\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.op = op;\r\n\t\tthis.s1 = s1;\r\n\r\n\t\tif (this.type === \"r\") {\r\n\t\t\tthis.binary = compile_reg(pred, op, s1);\r\n\t\t} else {\r\n\t\t\tthis.s1 &= 0x3FFFF;\r\n\t\t\tthis.binary = compile_imm(pred, op, s1);\r\n\t\t}\r\n\t}\r\n\t\r\n\texecute(){\r\n\t\tthrow new Error(\"No execute handler\");\r\n\t}\r\n\t\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.s1}`;\r\n\t}\r\n}\r\n\r\nexport default StackControl;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, op, rs) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\top = parseNum(op);\r\n\trs = parseReg(rs);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01100 << 22;\r\n\tbinary[0] |= op << 20;\r\n\tbinary[0] |= 0b01 << 18;\r\n\tbinary[0] |= rs << 12;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_imm = (pred, op, imm) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\top = parseNum(op);\r\n\timm = parseNum(imm);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01100 << 22;\r\n\tbinary[0] |= op << 20;\r\n\tbinary[0] |= 0b00 << 18;\r\n\tbinary[0] |= imm << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n","import StackControl from \"./StackControl\";\r\n\r\n/** \r\n * Sres instruction class. \r\n * @extends StackControl\r\n * @category StackControl\r\n */\r\nclass Sens extends StackControl {\r\n\t/**\r\n     * Create Sens instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {number}\t\t\tfields.s1\t- Immediate value \r\n     */\r\n\tconstructor({ pred, s1 }) {\r\n\t\tsuper({name: \"sens\", pred, op: 0b01, s1});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\tlet n = Number(this.type === \"r\" ? reg[this.s1] : this.s1 << 2); // Word size to byte size\r\n\t\treg[\"s5\"] = Math.max(reg[\"s5\"], reg[\"s6\"] + n);\r\n        \r\n\t\t/*\r\n        let nfill;\r\n        nfill = n - (reg[\"s5\"] - reg[\"s6\"]); // n - (m_top - sc_top)\r\n        for (let i = 0; i < nfill; ++i){\r\n            // We aren't actually implementing a stack cache and thus no copying is needed.\r\n            //sc[reg[\"s5\"]] = gm[reg[\"s5\"]];\r\n            reg[\"s5\"] += 1;\r\n        }\r\n        */\r\n\t}\r\n}\r\n\r\nexport default Sens;\r\n","import StackControl from \"./StackControl\";\r\n\r\n/** \r\n * Sfree instruction class. \r\n * @extends StackControl\r\n * @category StackControl\r\n */\r\nclass Sfree extends StackControl {\r\n\t/**\r\n     * Create Sfree instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {number}\t\t\tfields.s1\t- Immediate value \r\n     */\r\n\tconstructor({ pred, s1 }) {\r\n\t\tsuper({name: \"sfree\", pred, op: 0b10, s1});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\t// Increment st by n words.\r\n\t\treg[\"s6\"] += Number(this.s1) << 2;\r\n\t\t// If st > ss, set ss = st\r\n\t\tif(reg[\"s6\"] > reg[\"s5\"]){\r\n\t\t\treg[\"s5\"] = reg[\"s6\"];\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default Sfree;\r\n","import StackControl from \"./StackControl\";\r\n\r\n/** \r\n * Sres instruction class. \r\n * @extends StackControl\r\n * @category StackControl\r\n */\r\nclass Sres extends StackControl {\r\n\t/**\r\n     * Create Sres instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.s1   - Immediate value\r\n     */\r\n\tconstructor({ pred, s1 }) {\r\n\t\tsuper({name: \"sres\", pred, op: 0b00, s1});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg/*, sc*/ }) {\r\n\t\t//let nspill;\r\n\t\treg[\"s6\"] -= Number(this.s1) << 2; // Words to bytes.\r\n\t\t/*nspill = reg[\"s5\"] - reg[\"s6\"]; //- sc[\"MAX_SIZE\"]; // max_size of our imaginary cache as 0 would be boring :)\r\n\t\tfor(let i = 0; i < nspill; ++i){\r\n\t\t\treg[\"s5\"] -= 1;\r\n\t\t\t// Copying not needed as we have no actual cache.\r\n\t\t\t//gm[reg[\"s5\"]] = sc[reg[\"s5\"]]; // No masking, just keep the keys identical between sc and gm.\r\n\t\t}*/\r\n\t}\r\n}\r\n\r\nexport default Sres;\r\n","import StackControl from \"./StackControl\";\r\n\r\n/** \r\n * Sspill instruction class. \r\n * @extends StackControl\r\n * @category StackControl\r\n */\r\nclass Sspill extends StackControl {\r\n\t/**\r\n     * Create Sspill instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {number}\t\t\tfields.s1\t- Immediate value \r\n     */\r\n\tconstructor({ pred, s1 }) {\r\n\t\tsuper({name: \"sspill\", pred, op: 0b11, s1});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg  }) {\r\n\t\tlet n = Number(this.type === \"r\" ? reg[this.s1] : this.s1 << 2);\r\n\t\treg[\"s5\"] -= n;\r\n\t\t// not emulating the actual spill from cache to mem.\r\n\t}\r\n}\r\n\r\nexport default Sspill;\r\n","import {compile_reg} from \"./compilers\";\r\nimport { toUint32 } from \"../../../Helpers/misc\";\r\n\r\n/** \r\n * Represents a StoreTyped instruction. Sets common fields. \r\n */\r\nclass StoreTyped {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {number}   \t\tfields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ name, pred, type, ra, rs, imm }) {\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.type = type;\r\n\t\tthis.ra = ra;\r\n\t\tthis.rs = rs;\r\n\t\tthis.imm = toUint32(imm) & 0x7F;\r\n\t\tthis.binary = compile_reg(pred, type, ra, rs, imm);\r\n\t}\r\n\r\n\texecute() {\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} [${this.ra} + ${this.imm}] = ${this.rs}`;\r\n\t}\r\n}\r\n\r\nexport default StoreTyped;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, type, ra, rs, offset) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\ttype = parseNum(type);\r\n\tra = parseReg(ra);\r\n\trs = parseReg(rs);\r\n\toffset = parseNum(offset);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01011 << 22;\r\n\tbinary[0] |= type << 17;\r\n\tbinary[0] |= ra << 12;\r\n\tbinary[0] |= rs << 7;\r\n\tbinary[0] |= offset << 0;\r\n\r\n\treturn binary;\r\n};\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sbc instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sbc extends StoreTyped {\r\n\t/**\r\n     * Create Sbc instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sbc\", pred, type: 0b01010, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm);\r\n\t\tmem[addr] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sbc;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sbl instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sbl extends StoreTyped {\r\n\t/**\r\n     * Create Sbl instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sbl\", pred, type: 0b01001, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm);\r\n\t\tmem[addr] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sbl;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sbm instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sbm extends StoreTyped {\r\n\t/**\r\n     * Create Sbm instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sbm\", pred, type: 0b01011, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm);\r\n\t\tmem[addr] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sbm;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sbs instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sbs extends StoreTyped {\r\n\t/**\r\n     * Create Sbs instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sbs\", pred, type: 0b01000, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[\"s6\"] + reg[this.ra] + (this.imm);\r\n\t\tmem[addr]   = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sbs;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Shc instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Shc extends StoreTyped {\r\n\t/**\r\n     * Create Shc instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"shc\", pred, type: 0b00110, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 1);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Shc;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Shl instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Shl extends StoreTyped {\r\n\t/**\r\n     * Create Shl instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"shl\", pred, type: 0b00101, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 1);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Shl;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Shm instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Shm extends StoreTyped {\r\n\t/**\r\n     * Create Shm instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"shm\", pred, type: 0b00111, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 1);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Shm;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Shs instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Shs extends StoreTyped {\r\n\t/**\r\n     * Create Shs instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"shs\", pred, type: 0b00100, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[\"s6\"] + reg[this.ra] + (this.imm << 1);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Shs;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Swc instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Swc extends StoreTyped {\r\n\t/**\r\n     * Create Swc instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"swc\", pred, type: 0b00010, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 2);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\r\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Swc;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Swl instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Swl extends StoreTyped {\r\n\t/**\r\n     * Create Swl instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"swl\", pred, type: 0b00001, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 2);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\r\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Swl;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Swm instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Swm extends StoreTyped {\r\n\t/**\r\n     * Create Swm instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"swm\", pred, type: 0b00011, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 2);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\r\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Swm;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sws instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sws extends StoreTyped {\r\n\t/**\r\n     * Create Sws instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sws\", pred, type: 0b00000, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[\"s6\"] + reg[this.ra] + (this.imm << 2);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\r\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sws;\r\n","import { parseNum, parseReg } from \"../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rd, rs1, imm, ps) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\timm = parseNum(imm);\r\n\trd = parseReg(rd);\r\n\trs1 = parseReg(rs1);\r\n\tps = ps[0] === \"!\" ? 0b1000 | parseReg(ps) : parseReg(ps);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= imm << 7;\r\n\tbinary[0] |= 0b101 << 4;\r\n\tbinary[0] |= ps << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n/** \r\n * Bitcopy instruction class. \r\n * @category Bitcopy\r\n */\r\nclass Bcopy {\r\n\t/**\r\n     * Create Bcopy instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {number}          fields.imm  - Second operand, immediate value.\r\n     * @param {string}          fields.ps   - Predicate register. (can be negated)\r\n     */\r\n\tconstructor({pred, rd, rs1, imm, ps}) {\r\n\t\tthis.name = \"bcopy\";\r\n\t\tthis.pred = pred;\r\n\t\tthis.rd = rd;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.imm = imm & 0x1F;\r\n\t\tthis.ps = ps; \r\n\t\tthis.binary = compile_reg(pred, rd, rs1, imm, ps); \r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\tlet shift = (this.ps[0] === \"!\") === (reg[this.ps.replace(\"!\",\"\")] === 1) ? 0 : 1; // Handle negation of p-register\r\n\t\treg[this.rd] = (reg[this.rs1] & ~(1 << this.imm)) | (shift << this.imm);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = ${this.rs1}, ${this.imm}, ${this.ps}`;\r\n\t}\r\n\r\n}\r\n\r\nexport default Bcopy;\r\n","import { parseNum, parseReg } from \"../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rd, ss) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\trd = parseReg(rd);\r\n\tss = parseReg(ss); \r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01001 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= 0b011 << 4;\r\n\tbinary[0] |= ss << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n/** \r\n * Move from special instruction class. \r\n * @category MoveFromSpecial\r\n */\r\nclass Mfs {\r\n\t/**\r\n     * Create Mfs instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n\t * @param {string}\t\t\tfields.ss\t- Special source register\r\n     */\r\n\tconstructor({pred, rd, ss}) {\r\n\t\tthis.name = \"mfs\";\r\n\t\tthis.pred = pred;\r\n\t\tthis.rd = rd;\r\n\t\tthis.ss = ss;\r\n\t\tthis.binary = compile_reg(pred, rd, ss);\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = reg[this.ss];\r\n\t}\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = ${this.ss}`;\r\n\t}\r\n}\r\n\r\nexport default Mfs;\r\n","import { parseNum, parseReg } from \"../../Helpers/misc\";\r\n\r\nconst compile_reg = (pred, rs1, sd) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\trs1 = parseReg(rs1);\r\n\tsd = parseReg(sd); \r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01001 << 22;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= 0b010 << 4;\r\n\tbinary[0] |= sd << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n/** \r\n * Move to special instruction class. \r\n * @category MoveToSpecial\r\n */\r\nclass Mts {\r\n\t/**\r\n     * Create Mts instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rs1  - Source register\r\n     * @param {string}          fields.sd   - Special destination register\r\n     */\r\n\tconstructor({pred, rs1, sd}) {\r\n\t\tthis.name = \"mts\";\r\n\t\tthis.pred = pred;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.sd = sd;\r\n\t\tthis.binary = compile_reg(pred, rs1, sd);\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.sd] = reg[this.rs1];\r\n\t\tif(this.sd === \"s0\"){\r\n\t\t\treg[this.sd] &= 0xFF;\r\n\t\t\treg[\"p0\"] = 1;\r\n\t\t\treg[\"p1\"] = reg[\"s0\"] >> 1;\r\n\t\t\treg[\"p2\"] = reg[\"s0\"] >> 2;\r\n\t\t\treg[\"p3\"] = reg[\"s0\"] >> 3;\r\n\t\t\treg[\"p4\"] = reg[\"s0\"] >> 4;\r\n\t\t\treg[\"p5\"] = reg[\"s0\"] >> 5;\r\n\t\t\treg[\"p6\"] = reg[\"s0\"] >> 6;\r\n\t\t\treg[\"p7\"] = reg[\"s0\"] >> 7;\r\n\t\t}\r\n\t}\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.sd} = ${this.rs1}`;\r\n\t}\r\n}\r\n\r\nexport default Mts;\r\n","import { getInstType } from \"./typeStrings\";\r\n\r\n// All instruction regular expressions\r\nconst regEx = {\r\n\t// Label, pred, type\r\n\t\"first\" : [/^(?!#)(?:(\\w+):\\s*)?(?:\\((!?)(p\\d)\\)\\s+)?(\\w+)\\s*/i,\t\t\t\t\t\t\"label: (ps) type\"],\r\n\r\n\t// Normal instructions (new)\r\n\t\"bin\" \t: [/^(r\\d{1,2})\\s*=\\s*(r\\d{1,2})\\s*,\\s*\\(?([^()\\s]+)\\)?$/i, \t\t\t\t\t\t\t\t\"rd = rs1, op2\"],\r\n\t\"comp\"\t: [/^(p\\d)\\s*=\\s*(r\\d{1,2})\\s*,\\s*(r?(?:0x)?(?:0b)?\\d+)$/i,\t\t\t\t\t\t\"pd = rs1, op2\"],\r\n\t\"load\"\t: [/^(r\\d{1,2})\\s*=\\s*\\[(r\\d{1,2})\\s*\\+\\s*(\\w+)\\]$/i,  \t\t\t\t\t\t\t\"rd = [rs + imm]\"],\r\n\t\"store\"\t: [/^\\[(r\\d{1,2})\\s*\\+\\s*((?:0x)?(?:0b)?\\d+)\\]\\s*=\\s*(r\\d{1,2})$/i,\t\t\t\t\"[rd + imm] = rs\"],\r\n\t\"mul\"\t: [/^(r\\d{1,2})\\s*,\\s*(r\\d{1,2})$/i,\t\t\t\t\t\t\t\t\t\t\t\"rs1, rs2\"],\r\n\t\"stack\"\t: [/^(r?(?:0x)?(?:0b)?\\d+)\\s?$/i,\t\t\t\t\t\t\t\t\t\t\t\t\"op2\"],\r\n\t\"pred\"\t: [/^(p\\d)\\s*=\\s*(!?p\\d)\\s*,\\s*(!?p\\d)$/i,\t\t\t\t\t\t\t\t\t\t\"pd = ps1, ps2\"],\r\n\t\"cf\"\t: [/^\\s*(-?\\w*),?\\s*(\\w*)$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"label\"],\r\n\t\"mts\"\t: [/^(sro|srb|sxo|sxb|sl|sh|ss|st|s\\d{1,2})\\s*=\\s*(r\\d{1,2})$/i,\t\t\t\t\"sd = rs\"],\r\n\t\"mfs\"\t: [/^(r\\d{1,2})\\s*=\\s*(sro|srb|sxo|sxb|sl|sh|ss|st|s\\d{1,2})$/i,\t\t\t\t\"rd = ss\"],\t\t\r\n\t\"bcopy\"\t: [/^(r\\d{1,2})\\s*=\\s*(r\\d{1,2}),\\s*((?:0x)?(?:0b)?\\d+),\\s*(!?p\\d)$/i,\t\"rd = rs, imm, [!]ps\"],\r\n\r\n\t// Pseudo instructions\r\n\t\"mov\"\t: [/^(r\\d{1,2})\\s*=\\s*(r\\d{1,2})$/i, \t\t\t\t\t\t\t\t\t\t\t\"rd = rs\"],\r\n\t\"pmov\"\t: [/^(p\\d)\\s*=\\s*(p\\d)$/i, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = ps\"],\r\n\t\"isodd\"\t: [/^(p\\d)\\s*=\\s*(r\\d{1,2})$/i, \t\t\t\t\t\t\t\t\t\t\t\t\"pd = rs\"],\r\n\t\"clr\"\t: [/^([rp]\\d{1,2})$/i, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rd/pd\"],\r\n\t\"neg\"\t: [/^(r\\d{1,2})\\s*=\\s*-\\s*(r\\d{1,2})$/i,\t\t\t\t\t\t\t\t\t\t\"rd = -rs\"],\r\n\t\"not\"\t: [/^(r\\d{1,2})\\s*=\\s*!\\s*(r\\d{1,2})$/i,\t\t\t\t\t\t\t\t\t\t\"rd = !rs\"],\r\n\t\"li\"\t: [/^(r\\d{1,2})\\s*=\\s*(\\(?([^()\\s]+)\\)?)$/i,\t\t\t\t\t\t\t\t\t\"rd = imm\"],\r\n\t\"nop\" \t: [/^\\s*$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"nop\"],\r\n\t\"pset\"\t: [/^(p\\d)\\s*=\\s*1$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = 1\"],\r\n\t\"pnot\"\t: [/^(p\\d)\\s*=\\s*!\\s*(p\\d)$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = !ps\"],\r\n\t\"pclr\"\t: [/^(p\\d)\\s*=\\s*(0)$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = 0\"],\r\n};\r\n\r\n/**\r\n * Gets regular expression from type\r\n * @param {string} \ttype  - Instruction type\r\n * @returns a regular expression\r\n */\r\nconst getRegEx = (type) => {\r\n\tif (regEx[getInstType(type)] === undefined) {return -1; }\r\n\treturn regEx[getInstType(type)][0];\r\n};\r\n\r\nconst getRegExError = (type) => {\r\n\tif (regEx[getInstType(type)] === undefined) {return -1; }\r\n\treturn `Instruction ${type} should be on form: ${regEx[getInstType(type)][1]}`;\r\n};\r\n\r\nexport { getRegEx, getRegExError };\r\n","import { Add, Sub, Xor, Nor, ShiftLeft, ShiftRight, Or, And, ShiftRightArithmetic, ShiftAdd, ShiftAdd2 } from \"../Instructions/Binary Arithmetics/index\";\r\nimport { Btest, Cmpeq, Cmple, Cmplt, Cmpneq, Cmpule, Cmpult } from \"../Instructions/Compare/index\";\r\nimport { Br, Brcf, Brcfnd, Brnd, Call, Callnd, Ret, Retnd, Trap, Xret, Xretnd } from \"../Instructions/Control Flow/index\";\r\nimport { Lws, Lwl, Lwc, Lwm, Lhs, Lhl, Lhc, Lhm, Lbs, Lbl, Lbc, Lbm, Lhus, Lhul, Lhuc, Lhum, Lbus, Lbul, Lbuc, Lbum } from \"../Instructions/Load Typed/index\";\r\nimport { Mul, Mulu } from \"../Instructions/Multiply/index\";\r\nimport { Pand, Pxor, Por } from \"../Instructions/Predicate/index\";\r\nimport { Sens, Sfree, Sres, Sspill } from \"../Instructions/Stack Control/index\";\r\nimport { Sbc, Sbl, Sbm, Sbs, Shc, Shl, Shm, Shs, Swc, Swl, Swm, Sws } from \"../Instructions/Store Typed/index\";\r\nimport Bcopy from \"../Instructions/Bcopy\";\r\nimport Mfs from \"../Instructions/Mfs\";\r\nimport Mts from \"../Instructions/Mts\";\r\nimport { instTypes, binTypes, allowedPipelineTwo, pseudoTypes, pseudoMapping, cfTypes, loadTypes } from \"../../Helpers/typeStrings\";\r\nimport { regStr, allRegStr, sregMap } from \"../../Helpers/regStrings\";\r\nimport { getRegEx, getRegExError } from \"../../Helpers/regEx\";\r\n\r\nclass Assembler {\r\n\tconstructor() {\r\n\t\tthis.bundles = [];\r\n\t\tthis.labels = {};\r\n\t\tthis.offset = 0;\r\n\t\tthis.error = [];\r\n\t\tthis.numMap = [];\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.bundles = [];\r\n\t\tthis.labels = {};\r\n\t\tthis.offset = 0;\r\n\t\tthis.error = [];\r\n\t\tthis.numMap = [];\r\n\t}\r\n\r\n\t// should add debouncing :)\r\n\trun(editor) {\r\n\t\tthis.reset();\r\n\t\tlet input = this.cleanInput(editor);\r\n\t\tfor (let line of input)\r\n\t\t\tthis.parse(line);\r\n\t\tfor (let bundle of this.bundles) {\r\n\t\t\tif(this.resolveOperands(bundle))\r\n\t\t\t\tthis.compileBundle(bundle);\r\n\t\t}\r\n\t\treturn this.checkErr();\r\n\t}\r\n\r\n\t// if no errors, erase error array\r\n\tcheckErr() {\r\n\t\tfor (let key in this.error)\r\n\t\t\tif (this.error[key] !== \"fine\") return false;\r\n\t\tthis.error = [];\r\n\t\treturn true;\r\n\t}\r\n\r\n\tparse(line) {\r\n\t\tif(/^\\s*$/i.test(line)) return true;\r\n\t\tlet insts = line.split(\"||\");\r\n\t\tlet bundle = { is_data: false, data: null, offset: this.offset, instructions: [], size: 0 };\r\n\t\tlet idx = this.bundles.push(bundle) - 1;\r\n\t\t\r\n\t\t/* Perhaps change to is_data and and different regex for .word, .string etc. */\r\n\t\t//Figure out how to handle base and pc when a .word n+4 is injected into the asm as that indicates a code block that is n bytes...\r\n\t\tlet is_word = line.match(/^(?:(\\w+):)?(?:\\s+)?\\.word\\s+([^\\s]+)$/i);\r\n\t\tif(is_word) {\r\n\t\t\tbundle.is_data = true;\r\n\t\t\tbundle.data = {type: \"word\", value: is_word[2]};\r\n\t\t\tif(is_word[1]) this.labels[is_word[1]] = idx;\r\n\t\t\tthis.offset += 4;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (insts.length > 2) {\r\n\t\t\tthis.error[idx] = \"Only two instructions per bundle allowed!\";\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\t\r\n\t\tfor (let j in insts) {\r\n\t\t\tlet inst = insts[j];\r\n\t\t\tinst = inst.trim();\r\n\t\t\t\r\n\t\t\t// Get instruction match\r\n\t\t\tlet match = inst.match(getRegEx(\"first\"));\r\n\t\t\tif (!match) { \r\n\t\t\t\tthis.error[idx] = getRegExError(\"first\"); \r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\t\t\tlet label = match[1];\r\n\t\t\tlet neg = match[2] === \"!\";\r\n\t\t\tlet pred = match[3] ? Number(match[3].toLowerCase().replace(\"p\", \"\")) : 0;\r\n\t\t\tlet type = match[4].toLowerCase();\r\n\t\t\tif (type === \"halt\") type = \"nop\";\r\n\t\t\tmatch = inst.replace(match[0], \"\").match(getRegEx(type));\r\n\t\t\t\r\n\t\t\t// Check if inst is a proper instruction\r\n\t\t\tif (!instTypes.includes(type)) {\r\n\t\t\t\tthis.error[idx] = `${type} is not an instruction`;\r\n\t\t\t\treturn false; \r\n\t\t\t} else if (!match){\r\n\t\t\t\tthis.error[idx] = getRegExError(type); \r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\r\n\t\t\t// Re-write pseudo instruction into its corresponding instruction\r\n\t\t\tif (pseudoTypes.includes(type)) {\r\n\t\t\t\tlet ptype = type.toUpperCase();\r\n\t\t\t\tswitch (ptype) {\r\n\t\t\t\t\tcase \"LI\":\r\n\t\t\t\t\t\tif (Number(match[2] < 0)) {\r\n\t\t\t\t\t\t\tptype = \"LI_NEG\";\r\n\t\t\t\t\t\t\tmatch[2] = -match[2];\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tptype = \"LI_POS\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"MOV\":\r\n\t\t\t\t\t\tptype += (regStr.includes(match[1])) ? \"_R\" : \"_P\";\r\n\t\t\t\t\t\tptype += (regStr.includes(match[2])) ? \"R\" : \"P\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: break;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get the original instruction and get its match\r\n\t\t\t\tlet basic = pseudoMapping[ptype].replace(/{(\\d+)}/g, (_, n) => match[n]);\r\n\t\t\t\tmatch = basic.match(getRegEx(\"first\"));\r\n\t\t\t\ttype = match[4].toLowerCase();\r\n\t\t\t\tmatch = basic.replace(match[0], \"\").match(getRegEx(type));\r\n\t\t\t}\r\n\r\n\t\t\t// Define the instruction\r\n\t\t\tlet i = { pred: { p: pred, n: neg }, type, ops: match.slice(1), original: inst.replace(/\\s+/gi, \" \") };\r\n\t\t\tlet is_long_imm = (binTypes.includes(type) && Number(i.ops[2]) && ((Number(i.ops[2]) > 0xFFF) || [\"nor\", \"shadd\", \"shadd2\"].includes(type)));\r\n\t\t\t\r\n\t\t\t// Check if pipelined/bundled correctly\r\n\t\t\tif (insts.length === 2) {\r\n\t\t\t\tif (is_long_imm) {\r\n\t\t\t\t\tthis.error[idx] = \"Can't bundle a 64-bit instruction with anything else\";\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} else if (j === 1 && !allowedPipelineTwo(type)) {\r\n\t\t\t\t\tthis.error[idx] = `${type} can't run in pipeline two.`;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (label) this.labels[label] = idx;\r\n\t\t\tbundle.instructions.push(i);\r\n\t\t\tbundle[\"size\"] += is_long_imm ? 8 : 4;\r\n\t\t}\r\n\t\tthis.offset += bundle[\"size\"];\r\n\t\treturn true;\r\n\t}\r\n\r\n\tresolveOperands(bundle) {\r\n\t\tlet idx = bundle.offset/4;\r\n\r\n\t\tif(bundle.is_data){\r\n\t\t\tlet multi = bundle.data.value.match(/^(\\S+)([+-])(\\S+)$/i);\r\n\t\t\t\r\n\t\t\tif (Object.keys(this.labels).includes(bundle.data.value)){\r\n\t\t\t\tbundle.data.value = this.bundles[this.labels[bundle.data.value]].offset;\r\n\t\t\t} else if (multi && Object.keys(this.labels).includes(multi[1]) && Object.keys(this.labels).includes(multi[3])){\r\n\t\t\t\tlet t1 = this.bundles[this.labels[multi[1]]].offset;\r\n\t\t\t\tlet t2 = this.bundles[this.labels[multi[3]]].offset;\r\n\t\t\t\tbundle.data.value = multi[2] === \"+\" ? t1 + t2: t1 - t2 ;\r\n\t\t\t} else {\r\n\t\t\t\tbundle.data.value = Number(bundle.data.value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let instruction of bundle.instructions) {\r\n\t\t\tfor (let i in instruction.ops) {\r\n\t\t\t\tlet op = instruction.ops[i];\r\n\t\t\t\tlet op_lc = op.toLowerCase();\r\n\t\t\t\tlet multi = op.match(/^(\\S+)([+-])(\\S+)$/i);\r\n\t\t\t\tif (sregMap[op_lc]) {\r\n\t\t\t\t\tinstruction.ops[i] = sregMap[op_lc];\r\n\t\t\t\t} else if (allRegStr.includes(op_lc)) {\r\n\t\t\t\t\tinstruction.ops[i] = op_lc;\r\n\t\t\t\t} else if (Object.keys(this.labels).includes(op) || (multi && Object.keys(this.labels).includes(multi[1]) && Object.keys(this.labels).includes(multi[3]))) {\r\n\t\t\t\t\tlet target;\r\n\t\t\t\t\tif(multi){\r\n\t\t\t\t\t\tlet t1 = this.bundles[this.labels[multi[1]]].offset;\r\n\t\t\t\t\t\tlet t2 = this.bundles[this.labels[multi[3]]].offset;\r\n\t\t\t\t\t\ttarget = multi[2] === \"+\" ? t1 + t2: t1 - t2 ;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget = this.bundles[this.labels[op]].offset;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(cfTypes.includes(instruction.type)){\r\n\t\t\t\t\t\tif([\"br\", \"brnd\"].includes(instruction.type)){\r\n\t\t\t\t\t\t\tinstruction.ops[i] = String((target-bundle.offset) >> 2);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tinstruction.ops[i] = String(target >> 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if(loadTypes.includes(instruction.type)){\r\n\t\t\t\t\t\tlet shift = 0;\r\n\t\t\t\t\t\tif(instruction.type.includes(\"w\"))\r\n\t\t\t\t\t\t\tshift = 2;\r\n\t\t\t\t\t\telse if(instruction.type.includes(\"h\"))\r\n\t\t\t\t\t\t\tshift = 1;\r\n\t\t\t\t\t\tinstruction.ops[i] = String(target >> shift);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tinstruction.ops[i] = String(target);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (isNaN(op)) {\r\n\t\t\t\t\tthis.error[idx] = \"Can't resolve operands\";\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes empty lines and comments\r\n\t * @param \t{string} \teditor \t\t- User input editor \r\n\t * @returns {array}\t\toutput\t\t- Array of lines that are not empty or comments\r\n\t */\r\n\tcleanInput = (editor) => {\r\n\t\tlet lines = editor.replace(/~/gi, \"!\").split(/(?:\\r?\\n)/);\r\n\t\tlet output = [];\r\n\t\tfor (let i = 0; i < lines.length; ++i) {\r\n\t\t\tlet line = lines[i].split(\"#\", 1)[0].trim(); // Remove comments\r\n\t\t\tlet insts = line.split(\";\");\r\n\t\t\tfor (let j = 0; j < insts.length; ++j){\r\n\t\t\t\tlet only_label = insts[j].match(/^\\w+:$/);\r\n\t\t\t\tif (line) {\r\n\t\t\t\t\tif (only_label && i + 1 < lines.length) {\r\n\t\t\t\t\t\tlines[i + 1] = only_label[0] + \" \" + lines[i + 1];\r\n\t\t\t\t\t} else if (!only_label && insts[j]) {\r\n\t\t\t\t\t\toutput.push(insts[j]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.numMap[output.length-1] = i+1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn output;\r\n\t};\r\n\t\r\n\t/**\r\n\t * compileBundle creates a new instance of an instruction class for every instruction in\r\n\t * the input bundle (one or two instructions). Also sets the binary field of the Object\r\n\t * @param {*} bundle - One or two instructions.\r\n\t */\r\n\tcompileBundle(bundle) {\r\n\t\tfor (let i in bundle.instructions) {\r\n\t\t\tlet cInst;\r\n\t\t\tlet { pred, type, ops } = bundle.instructions[i];\r\n\t\t\tlet predicate = pred.p | (pred.n << 3);\r\n\r\n\t\t\tlet BinaryInst \t= { pred: predicate, rd:  ops[0], rs1: ops[1], op2: ops[2] };\r\n\t\t\tlet CompareInst = { pred: predicate, pd:  ops[0], rs1: ops[1], op2: ops[2] };\r\n\t\t\tlet ControlInst = { pred: predicate, s1:  ops[0], s2 : ops[1] };\r\n\t\t\tlet LoadInst \t= { pred: predicate, rd:  ops[0], ra:  ops[1], imm: ops[2] };\r\n\t\t\tlet MulInst \t= { pred: predicate, rs1: ops[0], rs2: ops[1] };\r\n\t\t\tlet PredInst \t= { pred: predicate, pd:  ops[0], ps1: ops[1], ps2: ops[2] };\r\n\t\t\tlet StackInst \t= { pred: predicate, s1:  ops[0] };\r\n\t\t\tlet StoreInst \t= { pred: predicate, ra:  ops[0], imm: ops[1], rs:  ops[2] };\r\n\t\t\tlet BcopyInst \t= { pred: predicate, rd:  ops[0], rs1: ops[1], imm: ops[2], ps: ops[3] };\r\n\r\n\t\t\t// Pick inst from its name/type\r\n\t\t\tswitch (type) {\r\n\t\t\t\t// BinaryArithmetics\r\n\t\t\t\tcase \"add\":\r\n\t\t\t\tcase \"addi\":\r\n\t\t\t\tcase \"addl\":\r\n\t\t\t\t\tcInst = new Add(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sub\":\r\n\t\t\t\tcase \"subi\":\r\n\t\t\t\tcase \"subl\":\r\n\t\t\t\t\tcInst = new Sub(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"or\":\r\n\t\t\t\tcase \"ori\":\r\n\t\t\t\tcase \"orl\":\r\n\t\t\t\t\tcInst = new Or(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"and\":\r\n\t\t\t\tcase \"andi\":\r\n\t\t\t\tcase \"andl\":\r\n\t\t\t\t\tcInst = new And(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"xor\":\r\n\t\t\t\tcase \"xori\":\r\n\t\t\t\tcase \"xorl\":\r\n\t\t\t\t\tcInst = new Xor(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"nor\":\r\n\t\t\t\tcase \"norl\":\r\n\t\t\t\t\tcInst = new Nor(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sl\":\r\n\t\t\t\tcase \"sli\":\r\n\t\t\t\tcase \"sll\":\r\n\t\t\t\t\tcInst = new ShiftLeft(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sr\":\r\n\t\t\t\tcase \"sri\":\r\n\t\t\t\tcase \"srl\":\r\n\t\t\t\t\tcInst = new ShiftRight(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sra\":\r\n\t\t\t\tcase \"srai\":\r\n\t\t\t\tcase \"sral\":\r\n\t\t\t\t\tcInst = new ShiftRightArithmetic(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shadd\":\r\n\t\t\t\t\tcInst = new ShiftAdd(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shadd2\":\r\n\t\t\t\t\tcInst = new ShiftAdd2(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Compare\r\n\t\t\t\tcase \"btest\":\r\n\t\t\t\tcase \"btesti\":\r\n\t\t\t\t\tcInst = new Btest(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmpeq\":\r\n\t\t\t\tcase \"cmpieq\":\r\n\t\t\t\t\tcInst = new Cmpeq(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmple\":\r\n\t\t\t\tcase \"cmpile\":\r\n\t\t\t\t\tcInst = new Cmple(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmplt\":\r\n\t\t\t\tcase \"cmpilt\":\r\n\t\t\t\t\tcInst = new Cmplt(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmpneq\":\r\n\t\t\t\tcase \"cmpineq\":\r\n\t\t\t\t\tcInst = new Cmpneq(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmpule\":\r\n\t\t\t\tcase \"cmpiule\":\r\n\t\t\t\t\tcInst = new Cmpule(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmpult\":\r\n\t\t\t\tcase \"cmpiult\":\r\n\t\t\t\t\tcInst = new Cmpult(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// LoadType \r\n\t\t\t\tcase \"lbc\":\r\n\t\t\t\t\tcInst = new Lbc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbl\":\r\n\t\t\t\t\tcInst = new Lbl(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbm\":\r\n\t\t\t\t\tcInst = new Lbm(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbs\":\r\n\t\t\t\t\tcInst = new Lbs(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbuc\":\r\n\t\t\t\t\tcInst = new Lbuc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbul\":\r\n\t\t\t\t\tcInst = new Lbul(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbum\":\r\n\t\t\t\t\tcInst = new Lbum(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbus\":\r\n\t\t\t\t\tcInst = new Lbus(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhc\":\r\n\t\t\t\t\tcInst = new Lhc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhl\":\r\n\t\t\t\t\tcInst = new Lhl(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhm\":\r\n\t\t\t\t\tcInst = new Lhm(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhs\":\r\n\t\t\t\t\tcInst = new Lhs(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhuc\":\r\n\t\t\t\t\tcInst = new Lhuc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhul\":\r\n\t\t\t\t\tcInst = new Lhul(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhum\":\r\n\t\t\t\t\tcInst = new Lhum(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhus\":\r\n\t\t\t\t\tcInst = new Lhus(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lwc\":\r\n\t\t\t\t\tcInst = new Lwc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lwl\":\r\n\t\t\t\t\tcInst = new Lwl(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lwm\":\r\n\t\t\t\t\tcInst = new Lwm(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lws\":\r\n\t\t\t\t\tcInst = new Lws(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Multiply \r\n\t\t\t\tcase \"mul\":\r\n\t\t\t\t\tcInst = new Mul(MulInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"mulu\":\r\n\t\t\t\t\tcInst = new Mulu(MulInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Predicate\r\n\t\t\t\tcase \"pand\":\r\n\t\t\t\t\tcInst = new Pand(PredInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"por\":\r\n\t\t\t\t\tcInst = new Por(PredInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"pxor\":\r\n\t\t\t\t\tcInst = new Pxor(PredInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// StoreTyped\r\n\t\t\t\tcase \"sbc\":\r\n\t\t\t\t\tcInst = new Sbc(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sbl\":\r\n\t\t\t\t\tcInst = new Sbl(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sbm\":\r\n\t\t\t\t\tcInst = new Sbm(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sbs\":\r\n\t\t\t\t\tcInst = new Sbs(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shc\":\r\n\t\t\t\t\tcInst = new Shc(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shl\":\r\n\t\t\t\t\tcInst = new Shl(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shm\":\r\n\t\t\t\t\tcInst = new Shm(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shs\":\r\n\t\t\t\t\tcInst = new Shs(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"swc\":\r\n\t\t\t\t\tcInst = new Swc(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"swl\":\r\n\t\t\t\t\tcInst = new Swl(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"swm\":\r\n\t\t\t\t\tcInst = new Swm(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sws\":\r\n\t\t\t\t\tcInst = new Sws(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Stack Control\r\n\t\t\t\tcase \"sens\":\r\n\t\t\t\tcase \"sensr\":\r\n\t\t\t\t\tcInst = new Sens(StackInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sfree\":\r\n\t\t\t\t\tcInst = new Sfree(StackInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sres\":\r\n\t\t\t\t\tcInst = new Sres(StackInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sspill\":\r\n\t\t\t\tcase \"sspillr\":\r\n\t\t\t\t\tcInst = new Sspill(StackInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Control Flow \r\n\t\t\t\tcase \"br\":\r\n\t\t\t\tcase \"brr\":\r\n\t\t\t\t\tcInst = new Br(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"brcf\":\r\n\t\t\t\tcase \"brcfr\":\r\n\t\t\t\t\tcInst = new Brcf(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"brcfnd\":\r\n\t\t\t\tcase \"brcfndr\":\r\n\t\t\t\t\tcInst = new Brcfnd(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"brnd\":\r\n\t\t\t\tcase \"brndr\":\r\n\t\t\t\t\tcInst = new Brnd(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"call\":\r\n\t\t\t\tcase \"callr\":\r\n\t\t\t\t\tcInst = new Call(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"callnd\":\r\n\t\t\t\tcase \"callndr\":\r\n\t\t\t\t\tcInst = new Callnd(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"ret\":\r\n\t\t\t\t\tcInst = new Ret(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"retnd\":\r\n\t\t\t\t\tcInst = new Retnd(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"trap\":\r\n\t\t\t\t\tcInst = new Trap(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"xret\":\r\n\t\t\t\t\tcInst = new Xret(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"xretnd\":\r\n\t\t\t\t\tcInst = new Xretnd(ControlInst);\r\n\t\t\t\t\tbreak; \r\n\r\n\t\t\t\t// Rest\r\n\t\t\t\tcase \"bcopy\":\r\n\t\t\t\t\tcInst = new Bcopy(BcopyInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"mfs\":\r\n\t\t\t\t\tcInst = new Mfs({ pred: pred.p | (pred.n << 3), rd: ops[0], ss: ops[1] });\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"mts\":\r\n\t\t\t\t\tcInst = new Mts({ pred: pred.p | (pred.n << 3), rs1: ops[1], sd: ops[0] });\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Not implemented\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tconsole.log(`Instruction ${type} not implemented.`);\r\n\t\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\tif (bundle.instructions[i].original === \"halt\") {\r\n\t\t\t\tcInst.binary[0] = 0x05400000;\r\n\t\t\t\tcInst.toString = () => {return \"\"; };\r\n\t\t\t}\r\n\t\t\tif (Number(i) === 0 && bundle.instructions.length === 2) {\r\n\t\t\t\tcInst.binary[0] |= 1 << 31;\r\n\t\t\t}\r\n\t\t\tbundle.instructions[i].instruction = cInst;\r\n\r\n\t\t\tlet idx = bundle.offset/4;\r\n\t\t\tif (!this.error[idx]) this.error[idx] = \"fine\";\r\n\t\t}\r\n\t}\r\n}\r\nexport default Assembler;\r\n","import React, { Component } from \"react\";\r\nimport FrontEnd from \"./Front End/FrontEnd\";\r\nimport CPU from \"./Work Logic/Processor/CPU\";\r\nimport Assembler from \"./Work Logic/Processor/Assembler\";\r\nimport \"./CSS/App.css\";\r\n\r\nclass App extends Component {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.cpu = new CPU();\r\n\t\tthis.a = new Assembler();\r\n\t}\r\n\r\n\teditorUpdate = (editor) => {\r\n\t\tconsole.clear();\r\n\t\tconsole.log(\"Run Assembler\");\r\n\t\tif (this.a.run(editor)) {\r\n\t\t\tconsole.log(\"Assembler ran successfully\");\r\n\t\t\tthis.cpu.populate(this.a.bundles);\r\n\t\t}\r\n\t\tthis.forceUpdate();\r\n\t}\r\n\r\n\tstepBtn = () => {\r\n\t\tthis.cpu.step();\r\n\t\tthis.forceUpdate(); // To re-render\r\n\t}\r\n\r\n\trunBtn = () => {\r\n\t\tthis.cpu.run();\r\n\t\tthis.forceUpdate(); // To re-render\r\n\t}\r\n\r\n\tresetBtn = () => {\r\n\t\tthis.cpu.populate(this.a.bundles);\r\n\t\tthis.forceUpdate(); // To re-render\r\n\t}\r\n\r\n\tprevBtn = () => {\r\n\t\tthis.cpu.prev();\r\n\t\tthis.forceUpdate(); // To re-render\r\n\t}\r\n\r\n\t/**\r\n\t * Dump button pressed. Saves the binary stream to a file.\r\n\t */\r\n\tdumpBtn = () => {\r\n\t\tlet mem = this.cpu.getMem();\r\n\t\tlet dump = new Uint8Array(mem[\"TEXT_END\"]);\r\n\t\t\r\n\t\tfor (let i = 0; i < mem[\"TEXT_END\"]; i += 4) {\r\n\t\t\tdump[i] = mem[i];\r\n\t\t\tdump[i+1] = mem[i+1];\r\n\t\t\tdump[i+2] = mem[i+2];\r\n\t\t\tdump[i+3] = mem[i+3];\t\r\n\t\t}\r\n\r\n\t\tlet file = new Blob([dump], {type: \"application/octet-stream\"});\r\n\t\tlet a = document.createElement(\"a\"), url = URL.createObjectURL(file);\r\n\t\ta.href = url;\r\n\t\ta.download = \"chora.o\";\r\n\t\tdocument.body.appendChild(a);\r\n\t\ta.click();\r\n\t\tsetTimeout(function() {\r\n\t\t\tdocument.body.removeChild(a);\r\n\t\t\twindow.URL.revokeObjectURL(url);  \r\n\t\t}, 0); \r\n\t\t\r\n\t}\r\n\r\n\trender() {\r\n\t\tdocument.body.style.overflowY = \"hidden\";\r\n\t\treturn (\r\n\t\t\t<div className=\"no-scroll\">\r\n\t\t\t\t<FrontEnd\r\n\t\t\t\t\tregisters={this.cpu.getReg()}\r\n\t\t\t\t\tmemory={this.cpu.getMem()}\r\n\t\t\t\t\thistory={this.cpu.state.history}\r\n\t\t\t\t\teditorUpdate={this.editorUpdate}\r\n\t\t\t\t\tstepClick={this.stepBtn}\r\n\t\t\t\t\trunClick={this.runBtn}\r\n\t\t\t\t\tprevClick={this.prevBtn}\r\n\t\t\t\t\tresetClick={this.resetBtn}\r\n\t\t\t\t\tdumpClick = {this.dumpBtn}\r\n\t\t\t\t\tpc={this.cpu.getPC()}\r\n\t\t\t\t\tbundles={this.cpu.bundles}\r\n\t\t\t\t\terror={this.a.error}\r\n\t\t\t\t\tnumMap={this.a.numMap}\r\n\t\t\t\t/>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\"; \r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}