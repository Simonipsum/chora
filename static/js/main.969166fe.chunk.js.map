{"version":3,"sources":["Front End/patmos-mode.js","Front End/Editor.js","Front End/Simulator/DisplayButtons.js","Helpers/misc.js","Front End/Simulator/DisplayStorage.js","Front End/Simulator/DisplayCode.js","Front End/Simulator/Simulator.js","Front End/FrontEnd.js","Work Logic/Processor/ProcessorState.js","Helpers/typeStrings.js","Helpers/regStrings.js","Work Logic/Processor/CPU.js","Work Logic/Instructions/Binary Arithmetics/BinaryArithmetics.js","Work Logic/Instructions/Binary Arithmetics/compilers.js","Work Logic/Instructions/Binary Arithmetics/Add.js","Work Logic/Instructions/Binary Arithmetics/Nor.js","Work Logic/Instructions/Binary Arithmetics/ShiftAdd.js","Work Logic/Instructions/Binary Arithmetics/ShiftAdd2.js","Work Logic/Instructions/Binary Arithmetics/ShiftLeft.js","Work Logic/Instructions/Binary Arithmetics/ShiftRight.js","Work Logic/Instructions/Binary Arithmetics/ShiftRightArithmetic.js","Work Logic/Instructions/Binary Arithmetics/Sub.js","Work Logic/Instructions/Binary Arithmetics/Xor.js","Work Logic/Instructions/Binary Arithmetics/Or.js","Work Logic/Instructions/Binary Arithmetics/And.js","Work Logic/Instructions/Compare/Compare.js","Work Logic/Instructions/Compare/compilers.js","Work Logic/Instructions/Compare/Btest.js","Work Logic/Instructions/Compare/Cmpeq.js","Work Logic/Instructions/Compare/Cmple.js","Work Logic/Instructions/Compare/Cmplt.js","Work Logic/Instructions/Compare/Cmpneq.js","Work Logic/Instructions/Compare/Cmpule.js","Work Logic/Instructions/Compare/Cmpult.js","Work Logic/Instructions/Control Flow/ControlFlow.js","Work Logic/Instructions/Control Flow/compilers.js","Work Logic/Instructions/Control Flow/Br.js","Work Logic/Instructions/Control Flow/Brcf.js","Work Logic/Instructions/Control Flow/Brcfnd.js","Work Logic/Instructions/Control Flow/Brnd.js","Work Logic/Instructions/Control Flow/Call.js","Work Logic/Instructions/Control Flow/Callnd.js","Work Logic/Instructions/Control Flow/Ret.js","Work Logic/Instructions/Control Flow/Retnd.js","Work Logic/Instructions/Control Flow/Trap.js","Work Logic/Instructions/Control Flow/Xret.js","Work Logic/Instructions/Control Flow/Xretnd.js","Work Logic/Instructions/Load Typed/LoadTyped.js","Work Logic/Instructions/Load Typed/compilers.js","Work Logic/Instructions/Load Typed/Lws.js","Work Logic/Instructions/Load Typed/Lwl.js","Work Logic/Instructions/Load Typed/Lwc.js","Work Logic/Instructions/Load Typed/Lwm.js","Work Logic/Instructions/Load Typed/Lhs.js","Work Logic/Instructions/Load Typed/Lhl.js","Work Logic/Instructions/Load Typed/Lhc.js","Work Logic/Instructions/Load Typed/Lhm.js","Work Logic/Instructions/Load Typed/Lbs.js","Work Logic/Instructions/Load Typed/Lbl.js","Work Logic/Instructions/Load Typed/Lbc.js","Work Logic/Instructions/Load Typed/Lbm.js","Work Logic/Instructions/Load Typed/Lhus.js","Work Logic/Instructions/Load Typed/Lhul.js","Work Logic/Instructions/Load Typed/Lhuc.js","Work Logic/Instructions/Load Typed/Lhum.js","Work Logic/Instructions/Load Typed/Lbus.js","Work Logic/Instructions/Load Typed/Lbul.js","Work Logic/Instructions/Load Typed/Lbuc.js","Work Logic/Instructions/Load Typed/Lbum.js","Work Logic/Instructions/Multiply/Multiply.js","Work Logic/Instructions/Multiply/compilers.js","Work Logic/Instructions/Multiply/Mul.js","Work Logic/Instructions/Multiply/Mulu.js","Work Logic/Instructions/Predicate/Predicate.js","Work Logic/Instructions/Predicate/compilers.js","Work Logic/Instructions/Predicate/Pand.js","Work Logic/Instructions/Predicate/Pxor.js","Work Logic/Instructions/Predicate/Por.js","Work Logic/Instructions/Stack Control/StackControl.js","Work Logic/Instructions/Stack Control/compilers.js","Work Logic/Instructions/Stack Control/Sens.js","Work Logic/Instructions/Stack Control/Sfree.js","Work Logic/Instructions/Stack Control/Sres.js","Work Logic/Instructions/Stack Control/Sspill.js","Work Logic/Instructions/Store Typed/StoreTyped.js","Work Logic/Instructions/Store Typed/compilers.js","Work Logic/Instructions/Store Typed/Sbc.js","Work Logic/Instructions/Store Typed/Sbl.js","Work Logic/Instructions/Store Typed/Sbm.js","Work Logic/Instructions/Store Typed/Sbs.js","Work Logic/Instructions/Store Typed/Shc.js","Work Logic/Instructions/Store Typed/Shl.js","Work Logic/Instructions/Store Typed/Shm.js","Work Logic/Instructions/Store Typed/Shs.js","Work Logic/Instructions/Store Typed/Swc.js","Work Logic/Instructions/Store Typed/Swl.js","Work Logic/Instructions/Store Typed/Swm.js","Work Logic/Instructions/Store Typed/Sws.js","Work Logic/Instructions/Bcopy.js","Work Logic/Instructions/Mfs.js","Work Logic/Instructions/Mts.js","Helpers/regEx.js","Work Logic/Processor/Assembler.js","App.js","index.js"],"names":["CodeMirror","defineMode","config","parserConfig","getRegex","w","i","RegExp","join","instTypes","registers","keywords","normal","stream","state","ch","next","skipToEnd","test","eatWhile","startState","basecol","indentDepth","cur","token","eatSpace","style","word","current","Editor","props","code","readOnly","mode","lint","updateCode","bind","newCode","this","setState","editorUpdate","options","lineNumbers","value","onChange","autoFocus","Component","buttonCSS","forwardBtn","bundles","pc","runClick","stepClick","tooltipRun","tooltipStep","title","type","className","onClick","disabled","backwardsBtn","history","prevClick","resetClick","tooltipPrev","tooltipReset","length","DisplayButtons","dumpClick","parseNum","input","Number","parseReg","match","toUint32","n","intToHex","integer","toString","toUpperCase","padStart","intToHexStr","tableCSS","DisplayStorage","pagenumber","pageRows","maxPage","hex","incPage","decPage","jumpPage","updateDimensions","toggleHex","Math","floor","window","innerHeight","ceil","addEventListener","removeEventListener","prevState","des","parseInt","prompt","href","data-toggle","role","id","RenderRegTable","RenderMemoryTable","memory","rows","push","RegRow","key","scope","gm_temp","startAddr","endAddr","Object","assign","undefined","zeroRow","MemoryRowHex","MemoryRowDec","emptyRow","letter","idx","val","GenMachineRows","o","MachineRow","bundle","addr","color","instruction","binary","original","DisplayCode","Simulator","FrontEnd","click","toggle","errMes","error","numMap","alert","ProcessorState","reg","mem","cpu","r","m","c","prev","pop","pseudoTypes","binTypes","compTypes","loadTypes","storeTypes","mulTypes","stackTypes","predTypes","cfTypes","concat","pseudoMapping","getInstType","keys","instTypeStr","bin","includes","comp","load","store","mul","stack","pred","cf","p1","regStr","allRegStr","sregMap","sl","sh","ss","st","srb","sro","sxb","sxo","CPU","pending_branch","reset","updateHistory","dualIssue","execute","handlePendingBranch","conflicts","ops","op","conflict","delay","inst","name","rewindOnce","console","time","step","timeEnd","base_set","offset","is_data","data","base","instructions","setMem","size","int","setReadReg","getReg","getMemory","r0","p0","s0","BinaryArithmetics","func","rd","rs1","op2","isNaN","rs2","compile_reg","imm","compile_imm","long","compile_long","Error","Add","Nor","ShiftAdd","ShiftAdd2","ShiftLeft","ShiftRight","ShiftRightArithmetic","Sub","Xor","Or","And","Compare","pd","Btest","Cmpeq","Cmple","Cmplt","Cmpneq","Cmpule","Cmpult","ControlFLow","d","s1","s2","compile_ireg","compile_reg2","Br","ControlFlow","Brcf","Brcfnd","Brnd","Call","s7","s8","Callnd","Ret","Retnd","Trap","s9","s10","Xret","Xretnd","LoadTyped","ra","Lws","address","hh","hl","lh","ll","Lwl","Lwc","Lwm","Lhs","hi","lo","Lhl","Lhc","Lhm","Lbs","Lbl","Lbc","Lbm","Lhus","Lhul","Lhuc","Lhum","Lbus","Lbul","Lbuc","Lbum","Multiply","Mul","imul","Mulu","Predicate","ps1","ps2","neg1","neg2","replace","Pand","Pxor","Por","StackControl","rs","Sens","max","Sfree","Sres","Sspill","StoreTyped","Sbc","Sbl","Sbm","Sbs","Shc","Shl","Shm","Shs","Swc","Swl","Swm","Sws","Bcopy","ps","shift","Mfs","Mts","sd","regEx","getRegEx","getRegExError","Assembler","cleanInput","editor","lines","split","output","line","trim","insts","j","only_label","labels","parse","resolveOperands","compileBundle","checkErr","is_word","label","neg","toLowerCase","ptype","basic","_","p","slice","is_long_imm","allowedPipelineTwo","multi","t1","t2","op_lc","target","String","cInst","predicate","BinaryInst","CompareInst","ControlInst","LoadInst","MulInst","PredInst","StackInst","StoreInst","BcopyInst","log","App","clear","a","run","populate","forceUpdate","stepBtn","runBtn","resetBtn","prevBtn","dumpBtn","getMem","dump","Uint8Array","file","Blob","document","createElement","url","URL","createObjectURL","download","body","appendChild","setTimeout","removeChild","revokeObjectURL","overflowY","getPC","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.969166fe.chunk.js","sourcesContent":["import CodeMirror from \"codemirror\";\r\n\r\n((mod) => {\r\n\tmod(CodeMirror);\r\n}) ((CodeMirror) => {\r\n\t//\"use strict\";\r\n\r\n\tCodeMirror.defineMode(\"patmos\", (config, parserConfig) => {\r\n\t\tlet getRegex = (w, i) => {\r\n\t\t\treturn new RegExp(\"^(?:\" + w.join(\"|\") + \")$\", i);\r\n\t\t};\r\n\r\n\t\tlet instTypes = getRegex([\r\n\t\t\t/* Normal Instructions */\r\n\t\t\t// BA\r\n\t\t\t\"add\", \"addi\", \"addl\", \"sub\", \"subi\", \"subl\", \"xor\", \"xori\", \"xorl\", \"sl\", \"sli\", \"sll\",\r\n\t\t\t\"sr\", \"sri\", \"srl\", \"sra\", \"srai\", \"sral\", \"nor\", \"norl\", \"shadd\", \"shadd2\", \"or\", \"ori\", \"orl\",\r\n\t\t\t\"and\", \"andi\", \"andl\",\r\n\t\t\t// Compare\r\n\t\t\t\"btest\", \"btesti\", \"cmpeq\", \"cmpieq\", \"cmple\", \"cmpile\", \"cmplt\", \"cmpilt\", \r\n\t\t\t\"cmpneq\", \"cmpineq\", \"cmpule\", \"cmpiule\", \"cmpult\", \"cmpiult\",\r\n\t\t\t// Load\r\n\t\t\t\"lbc\", \"lbl\", \"lbm\", \"lbs\", \"lbuc\", \"lbul\", \"lbum\", \"lbus\", \"lhc\", \"lhl\", \r\n\t\t\t\"lhm\", \"lhs\", \"lhuc\", \"lhul\", \"lhum\", \"lhus\", \"lwc\", \"lwl\", \"lwm\", \"lws\",\r\n\t\t\t// Store\r\n\t\t\t\"sbc\", \"sbl\", \"sbm\", \"sbs\", \"shc\", \"shl\", \"shm\", \"shs\", \"swc\", \"swl\", \"swm\", \"sws\",\r\n\t\t\t// Multiply\r\n\t\t\t\"mul\", \"mulu\", \r\n\t\t\t// Stack Control\r\n\t\t\t\"sens\", \"sfree\", \"sres\", \"sspill\", \t\"sspillr\", \"sensr\",\r\n\t\t\t// Predicate\r\n\t\t\t\"pand\", \"por\", \"pxor\",\r\n\t\t\t// Move types\r\n\t\t\t\"mts\", \"mfs\",\r\n\t\t\t// Control Flow\r\n\t\t\t\"callnd\", \"call\", \"brnd\", \"br\", \"brcfnd\", \"brcf\", \"trap\",\r\n\t\t\t\"retnd\", \"ret\", \"xretnd\", \"xret\", \"callndr\", \"callr\", \r\n\t\t\t\"brndr\", \"brr\", \"brcfr\", \"brcfndr\",\r\n\t\t\t// Bit copy\r\n\t\t\t\"bcopy\",\r\n\r\n\t\t\t/* Pseudo Instructions */\r\n\t\t\t\"mov\", \"clr\", \"neg\", \"not\", \"li\", \"nop\", \"isodd\", \"pmov\", \"pnot\", \"pset\", \"pclr\",\r\n\t\t], \"i\");\r\n\r\n\t\tlet registers = getRegex([\r\n\t\t// General-purpose\r\n\t\t\t\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \r\n\t\t\t\"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \r\n\t\t\t\"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\r\n\t\t\t// Predicate\r\n\t\t\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\r\n\t\t\t// Special-purpose\r\n\t\t\t\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \r\n\t\t\t\"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\",\r\n\t\t\t// Special names\r\n\t\t\t\"sl\", \"sh\", \"ss\", \"st\", \"srb\", \"sro\", \"sxb\", \"sxo\",\r\n\t\t], \"\");\r\n\r\n\t\tlet keywords = getRegex([\".word\"], \"i\");\r\n\r\n\t\tlet normal = (stream, state) => {\r\n\t\t\tlet ch = stream.next();\r\n\r\n\t\t\t// Eat entire comment\r\n\t\t\tif (ch === \"#\") {\r\n\t\t\t\tstream.skipToEnd();\r\n\t\t\t\treturn \"comment\";\r\n\t\t\t}\r\n\t\t\r\n\t\t\t// Eat all digits of number\r\n\t\t\tif (/\\d/.test(ch)) {\r\n\t\t\t\tstream.eatWhile(/[\\w.%]/);\r\n\t\t\t\treturn \"number\";\r\n\t\t\t}\r\n\r\n\t\t\t// Eat all characters of register / keyword\r\n\t\t\tif (/[.\\w_]/.test(ch)) {\r\n\t\t\t\tstream.eatWhile(/[\\w\\\\\\-_.]/);\r\n\t\t\t\treturn \"variable\";\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tstartState: (basecol) => {\r\n\t\t\t\treturn { basecol: basecol || 0, indentDepth: 0, cur: normal };\r\n\t\t\t},\r\n\r\n\t\t\ttoken: (stream, state) => {\r\n\t\t\t\tif (stream.eatSpace()) return null;\r\n\t\t\t\tlet style = state.cur(stream, state);\r\n\t\t\t\tlet word = stream.current();\r\n\r\n\t\t\t\t// Use different colors for types, registers and keywords\r\n\t\t\t\tif (style === \"variable\") {\r\n\t\t\t\t\tif (keywords.test(word)) style = \"keyword\";\r\n\t\t\t\t\telse if (instTypes.test(word)) style = \"builtin\";\r\n\t\t\t\t\telse if (registers.test(word)) style = \"variable-2\";\r\n\t\t\t\t}\r\n\t\t\t\treturn style;\r\n\t\t\t}\r\n\t\t};\r\n\t});\r\n\r\n\t// inspiration from codemirror.net/addon/lint/javascript-lint.js \r\n\t// let validator = (text, options) => {\r\n\t// \tif(!window.JSHINT) {\r\n\t// \t\tif (window.console) {\r\n\t// \t\t\twindow.console.error(\"Error: window. not defined, CodeMirror Patmos-mode linting cannot run.\");\r\n\t// \t\t}\r\n\t// \t\treturn [];\r\n\t// \t}\r\n\t// \tif (!options.indent) // JSHint error.character actually is a column index, this fixes underlining on lines using tabs for indentation\r\n\t// \t\toptions.indent = 1; // JSHint default value is 4\r\n\t// \tJSHINT(text, options, options.globals);\r\n\t// \tlet errors = JSHINT.data().errors, result = [];\r\n\t// \tif (errors) parseErrors(errors, result);\r\n\t// \treturn result;\r\n\t// };\r\n\r\n\t// let parseErrors = (errors, output) => {\r\n\t// \tfor ( let i = 0; i < errors.length; i++) {\r\n\t// \t\tlet error = errors[i];\r\n\t// \t\tif (error) {\r\n\t// \t\t\tif (error.line <= 0) {\r\n\t// \t\t\t\tif (window.console)\r\n\t// \t\t\t\t\twindow.console.warn(\"Cannot display JSHint error (invalid line \" + error.line + \")\", error);\r\n\t// \t\t\t\tcontinue;\r\n\t// \t\t\t}\r\n\r\n\t// \t\t\tlet start = error.character - 1, end = start + 1;\r\n\t\t\t\t\r\n\t// \t\t\tif (error.evidence) {\r\n\t// \t\t\t\tlet index = error.evidence.substring(start).search(/.\\b/);\r\n\t// \t\t\t\tif (index > -1) end += index;\r\n\t// \t\t\t}\r\n\r\n\t// \t\t\t// Convert to format expected by validation service\r\n\t// \t\t\toutput.push({\r\n\t// \t\t\t\tmessage: error.reason,\r\n\t// \t\t\t\tseverity: error.code ? (error.code.startsWith('W') ? \"warning\" : \"error\") : \"error\",\r\n\t// \t\t\t\tfrom: CodeMirror.Pos(error.line - 1, start),\r\n\t// \t\t\t\tto: CodeMirror.Pos(error.line - 1, end)\r\n\t// \t\t\t});\r\n\t// \t\t}\r\n\t// \t}\r\n\t// };\r\n\r\n\t// CodeMirror.registerHelper(\"lint\", \"patmos\", validator);\r\n});\r\n  ","import React, { Component } from \"react\";\r\nimport CodeMirror from \"react-codemirror\";\r\nimport PropTypes from \"prop-types\";\r\nimport \"../../node_modules/codemirror/lib/codemirror.css\";\r\nimport \"./patmos-mode\";\r\n//import \"../../node_modules/codemirror/mode/patmos/patmos\";\r\n\r\nclass Editor extends Component{\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\tcode: \"\",\r\n\t\t\treadOnly: false,\r\n\t\t\tmode: \"patmos\",\r\n\t\t\tlint: true,\r\n\t\t};\r\n\r\n\t\tthis.updateCode = this.updateCode.bind(this);\r\n\t}\r\n\r\n\tupdateCode (newCode) {\r\n\t\tthis.setState({\r\n\t\t\tcode: newCode,\r\n\t\t});\r\n\t\tthis.props.editorUpdate(newCode);\r\n\t}\r\n\r\n\trender() {\r\n\t\tlet options = {\r\n\t\t\tmode: this.state.mode,\r\n\t\t\tlineNumbers: true,\r\n\t\t};\r\n\t\treturn(\r\n\t\t\t<div><CodeMirror value={this.state.code} onChange={this.updateCode} options={options} autoFocus={true}/></div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nEditor.propTypes = {\r\n\teditorUpdate : PropTypes.func\r\n};\r\n\r\nexport default Editor;\r\n","import React, { Fragment } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport \"../../CSS/Buttons.css\";\r\n\r\nconst buttonCSS = [\r\n\t\"btn button run col-2\", \r\n\t\"btn button step col-2\", \r\n\t\"btn button prev col-2\",\r\n\t\"btn button reset col-2\",\r\n\t\"btn button dump col-2\",\r\n];\r\n\r\n/**\r\n * DisplayButtons: Handles display of buttons and returns clicks of buttons.\r\n * @param {object} \tprops.bundles\t\t- Object consisting of all instruction bundles from editor\r\n * @param {number}\tprops.pc\t\t\t- Current CPU program counter\r\n * @param {func}\tprops.runClick\t\t- Button run clicked handler\r\n * @param {func}\tprops.stepClick\t\t- Button step clicked handler\r\n * @param {func}\tprops.prevClick\t\t- Button prev clicked handler\r\n * @param {func}\tprops.resetClick\t- Button reset clicked handler\r\n */\r\nconst DisplayButtons = (props) => {\r\n\treturn (\r\n\t\t<div className=\"button-container\">\r\n\t\t\t{forwardBtn(props.bundles, props.pc, props.runClick, props.stepClick)}\r\n\t\t\t{backwardsBtn(props.history, props.prevClick, props.resetClick)}\r\n\t\t\t<button type =\"button\" className={buttonCSS[4]} onClick = {props.dumpClick}>Dump</button>\r\n\t\t</div>  \r\n\t);\r\n};\r\n\r\n/**\r\n * fowardBtn: Handles the two buttons \"Run\" and \"Step\".\r\n * Disables the buttons if no instructions left in queue.\r\n * @param {Object} \tbundles \t- Object consisting of all instruction bundles from editor\r\n * @param {number} \tpc \t\t\t- Current CPU program counter\r\n * @param {func} \trunClick \t- Button run clicked handler\r\n * @param {func} \tstepClick \t- Button step clicked handler\r\n */\r\nconst forwardBtn = (bundles, pc, runClick, stepClick) => {\r\n\tlet tooltipRun = \"Run all remaining instructions in queue\";\r\n\tlet tooltipStep = \"Step next instruction in queue\";\r\n\r\n\tif (!bundles[pc]) {\r\n\t\ttooltipRun = \"No instructions to run\";\r\n\t\ttooltipStep = \"No instructions to step\";\r\n\t\treturn (\r\n\t\t\t<Fragment>\r\n\t\t\t\t<button title={tooltipRun} type=\"button\" className={buttonCSS[0]} disabled>Run</button>\r\n\t\t\t\t<button title={tooltipStep} type=\"button\" className={buttonCSS[1]} disabled>Step</button>\r\n\t\t\t</Fragment>\r\n\t\t);\r\n\t}\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<button title={tooltipRun} type=\"button\" className={buttonCSS[0]} onClick={runClick}  >Run</button>\r\n\t\t\t<button title={tooltipStep} type=\"button\" className={buttonCSS[1]} onClick={stepClick} >Step</button>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n\r\n/**\r\n * backwardsBtn: Handles the two buttons \"Prev\" and \"Reset\".\r\n * Disables the buttons if no instructions has been executed yet.\r\n * @param {number} \tpc \t\t\t- Current CPU program counter\r\n * @param {func} \tprevClick \t- Button prev clicked handler\r\n * @param {func} \tresetClick \t- Button reset clicked handler\r\n */\r\nconst backwardsBtn = (history, prevClick, resetClick) => {\r\n\tlet tooltipPrev = \"Steps one instruction back (decrement program count)\";\r\n\tlet tooltipReset = \"Reset registers & memory and jump to first instruction\";\r\n\r\n\tif (history.length === 0) {\r\n\t\ttooltipReset = \"No instructions run yet\";\r\n\t\ttooltipPrev = \"No instructions run yet\";\r\n\t\treturn (\r\n\t\t\t<Fragment>\r\n\t\t\t\t<button title={tooltipPrev} type=\"button\" className={buttonCSS[2]} disabled>Prev</button>\r\n\t\t\t\t<button title={tooltipReset} type=\"button\" className={buttonCSS[3]} disabled>Reset</button>\r\n\t\t\t</Fragment>\r\n\t\t);\r\n\t}\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<button title={tooltipPrev} type=\"button\" className={buttonCSS[2]} onClick={prevClick}  >Prev</button>\r\n\t\t\t<button title={tooltipReset} type=\"button\" className={buttonCSS[3]} onClick={resetClick}>Reset</button>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n\r\nDisplayButtons.propTypes = {\r\n\thistory     : PropTypes.array,\r\n\tbundles \t: PropTypes.object,\r\n\tpc \t\t\t: PropTypes.number,\r\n\trunClick \t: PropTypes.func,\r\n\tstepClick\t: PropTypes.func,\r\n\tprevClick \t: PropTypes.func,\r\n\tresetClick \t: PropTypes.func,\r\n\tdumpClick\t: PropTypes.func,\r\n};\r\n\r\n\r\nexport default DisplayButtons;\r\n","export const parseNum = (input) => typeof input == \"number\" ? input : Number(input);\r\nexport const parseReg = (input) => typeof input == \"number\" ? input : Number(input.match(/\\d+/i)[0]);\r\nexport const toUint32 = (n) => n >>> 0;\r\nexport const toInt32 = (n) => n | 0;\r\nexport const intToHex = (integer, length) => {\r\n\tinteger = Number(integer);\r\n\r\n\tif (integer < 0) {\r\n\t\tinteger = 0xFFFFFFFF + integer + 1;\r\n\t}\r\n\treturn integer.toString(16).toUpperCase().padStart(length, \"0\");\r\n};\r\nexport const intToHexStr = (integer, length) => {\r\n\treturn `0x${intToHex(integer, length)}`;\r\n};\r\n","import React, { Component } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { intToHex, intToHexStr } from \"../../Helpers/misc\";\r\nimport \"../../CSS/Simulator.css\";\r\nimport \"../../CSS/Buttons.css\";\r\nimport \"../../CSS/App.css\";\r\n\r\nconst tableCSS = \"table table-hover table-sm col-12\";\r\nconst maxSize = 0x00200000;\r\n\r\nclass DisplayStorage extends Component {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\tpagenumber\t: 1,\r\n\t\t\tpageRows \t: 0,\r\n\t\t\tmaxPage \t: 0,\r\n\t\t\thex\t\t\t: false,\r\n\t\t};\r\n\r\n\t\tthis.incPage = this.incPage.bind(this);\r\n\t\tthis.decPage = this.decPage.bind(this);\r\n\t\tthis.jumpPage = this.jumpPage.bind(this);\r\n\t\tthis.updateDimensions = this.updateDimensions.bind(this);\r\n\t\tthis.toggleHex = this.toggleHex.bind(this);\r\n\t}\r\n\r\n\tupdateDimensions() {\r\n\t\tlet pageRows = Math.floor((window.innerHeight - 220) / 35); // row 34.6\r\n\t\tthis.setState({ \r\n\t\t\tpageRows\t: pageRows,\r\n\t\t\tmaxPage\t\t: Math.ceil(maxSize / (pageRows*4)),\r\n\t\t});\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tthis.updateDimensions();\r\n\t\twindow.addEventListener(\"resize\", this.updateDimensions);\r\n\t}\r\n\t\r\n\tcomponentWillUnmount() {\r\n\t\twindow.removeEventListener(\"resize\", this.updateDimensions);\r\n\t}\r\n\r\n\tincPage() {\r\n\t\tif ((this.state.pagenumber+1) <= this.state.maxPage)\r\n\t\t\tthis.setState((prevState) => ({ pagenumber: prevState.pagenumber + 1 }));\r\n\t}\r\n\r\n\tdecPage() {\r\n\t\tif (this.state.pagenumber > 1)\r\n\t\t\tthis.setState((prevState) => ({ pagenumber: prevState.pagenumber - 1 }));\r\n\t}\r\n\r\n\tjumpPage() {\r\n\t\tlet des = parseInt(Number(prompt(\"What address do you want to jump to? Both hexadecimal and decimal numbers accepted.\")), 10) / (this.state.pageRows*4);\r\n\t\tif (des <= this.state.maxPage) \r\n\t\t\tthis.setState(() => ({ pagenumber: Math.floor(des)+1 }));\r\n\t}\r\n\r\n\ttoggleHex() {\r\n\t\tthis.setState((prevState) => ({ hex : prevState.hex ? false : true }));\r\n\t}\r\n\r\n\trender() {\r\n\t\treturn(\r\n\t\t\t<div>\r\n\t\t\t\t<ul className =\"nav nav-tabs justify-content-center\">\r\n\t\t\t\t\t<li className=\"nav-item\">\r\n\t\t\t\t\t\t<a href=\"#registers\" className=\"nav-link active\" data-toggle=\"tab\" role=\"tab\">Registers</a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t\t<li className=\"nav-item\">\r\n\t\t\t\t\t\t<a href=\"#gm\" className=\"nav-link\" data-toggle=\"tab\" role=\"tab\">Memory</a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\r\n\t\t\t\t<div className=\"tab-content\">\r\n\t\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane active table-scrolling\" id=\"registers\">\r\n\t\t\t\t\t\t{RenderRegTable(this.props.registers)}\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane\" id=\"gm\">\r\n\t\t\t\t\t\t{RenderMemoryTable(this.props.memory, this.state.pagenumber, this.state.pageRows, this.state.hex)}\r\n\t\t\t\t\t\t<div>\r\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-4\" onClick={this.decPage}>Prev</button>\r\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-4\" onClick={this.incPage}>Next</button>\r\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-4\" onClick={this.jumpPage}>Jump</button>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t<div>\r\n\t\t\t\t\t\t\t<button type=\"button\" className=\"btn button page-btn col-12\" onClick={this.toggleHex}>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tthis.state.hex ? \"Change to decimal\" : \"Change to hexadecimal\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t</button>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\t\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * RenderRegTable: Returns the register table with columns Register, Decimal, Hexadecimal\r\n * @param {Object} registers - Object containing all register values with the reg as key. r0-r31, p0-p7, s0-s15\r\n */\r\nconst RenderRegTable = (registers) => {\r\n\tvar rows = [];\r\n\r\n\t// Generate rows: 32 r-, 16 s-, and 8 p-rows.\r\n\tfor (let i = 0; i < 32; i++) {\r\n\t\trows.push(RegRow(\"r\", i, registers));\r\n\t}\r\n\tfor (let i = 0; i < 16; i++) {\r\n\t\trows.push(RegRow(\"s\", i, registers));\r\n\t}\r\n\tfor (let i = 0; i < 8; i++) {\r\n\t\trows.push(RegRow(\"p\", i, registers));\r\n\t}\r\n\r\n\t// This row overflows when scrolled all the way down. \r\n\trows.push(\r\n\t\t<tr key={\"bottom\"}>\r\n\t\t\t<th>---</th>\r\n\t\t\t<td>---</td>\r\n\t\t\t<td>---</td>\r\n\t\t</tr>\r\n\t);\r\n\r\n\t// Return table\r\n\treturn (\r\n\t\t<table className={tableCSS}>\r\n\t\t\t<thead className=\"header-stick\">\r\n\t\t\t\t<tr className=\"header-stick\">\r\n\t\t\t\t\t<th className=\"header-stick\" scope=\"col\">Register</th>\r\n\t\t\t\t\t<th className=\"header-stick\" scope=\"col\">Decimal</th>\r\n\t\t\t\t\t<th className=\"header-stick\" scope=\"col\">Hexadecimal</th>\r\n\t\t\t\t</tr>\r\n\t\t\t</thead>\r\n\t\t\t<tbody>\r\n\t\t\t\t{rows}\t\r\n\t\t\t</tbody>\r\n\t\t</table>\r\n\t);\r\n};\r\n\r\n/**\r\n * RenderMemoryTable: Returns the memory table with columns Address, +0, +1, +2, +3\r\n * @param {Object} props.memory\t\t- Object containing the memory of the program. \r\n */\r\nconst RenderMemoryTable = (memory, pagenumber, pageRows, hex) => {\r\n\tlet gm_temp, rows = [];\r\n\r\n\tlet startAddr = (pagenumber-1)*pageRows*4;\r\n\tlet endAddr = pagenumber*pageRows*4;\r\n\r\n\t// We don't want to display these fields:\r\n\tgm_temp = Object.assign({}, memory);\r\n\tdelete gm_temp[\"BASE_ADDR\"];\r\n\tdelete gm_temp[\"MAX_SIZE\"];\r\n\tdelete gm_temp[\"TEXT_END\"];\r\n\r\n\tfor (let i = startAddr; i < endAddr; i+= 4) {\r\n\t\tif (i <= maxSize) {\r\n\t\t\tif (gm_temp[i] === undefined) {\r\n\t\t\t\trows.push(zeroRow(i, hex));\r\n\t\t\t} else {\r\n\t\t\t\thex ? rows.push(MemoryRowHex(gm_temp, i)) : rows.push(MemoryRowDec(gm_temp, i));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\trows.push(emptyRow(i));\r\n\t\t}\r\n\t}\r\n\r\n\t// Return table\r\n\treturn (\r\n\t\t<table className={tableCSS}>\r\n\t\t\t<thead>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<th scope=\"col\">Address</th>\r\n\t\t\t\t\t<th scope=\"col\">+0</th>\r\n\t\t\t\t\t<th scope=\"col\">+1</th>\r\n\t\t\t\t\t<th scope=\"col\">+2</th>\r\n\t\t\t\t\t<th scope=\"col\">+3</th>\r\n\t\t\t\t</tr>\r\n\t\t\t</thead>\r\n\t\t\t<tbody>\r\n\t\t\t\t{rows}\r\n\t\t\t</tbody>\r\n\t\t</table>\r\n\t);\r\n};\r\n\r\nconst emptyRow = (key) => {\r\n\treturn(\r\n\t\t<tr key={key}>\r\n\t\t\t<td>----------</td>\r\n\t\t\t<td>---</td>\r\n\t\t\t<td>---</td>\r\n\t\t\t<td>---</td>\r\n\t\t\t<td>---</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\nconst zeroRow = (key, hex) => {\r\n\treturn(\r\n\t\t<tr key={key}>\r\n\t\t\t<td>{intToHexStr(key, 8)}</td>\r\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\r\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\r\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\r\n\t\t\t<td>{hex ? \"00\" : \"0\"}</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\n/**\r\n * MemoryRow: Returns one row of the memory table.\r\n * @param {Object} memory - Object containing the global memory of the program. \r\n */\r\nconst MemoryRowDec = (memory, key) => {\r\n\treturn(\r\n\t\t<tr key={key}>\r\n\t\t\t<td>{intToHexStr(key, 8)}</td>\r\n\t\t\t<td>{memory[`${key}`]}</td>\r\n\t\t\t<td>{memory[`${key+1}`]}</td>\r\n\t\t\t<td>{memory[`${key+2}`]}</td>\r\n\t\t\t<td>{memory[`${key+3}`]}</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\n/**\r\n * MemoryRow: Returns one row of the memory table in hexadecimal.\r\n * @param {Object} memory - Object containing the global memory of the program. \r\n */\r\nconst MemoryRowHex = (memory, key) => {\r\n\treturn(\r\n\t\t<tr key={key}>\r\n\t\t\t<td>{intToHexStr(key, 8)}</td>\r\n\t\t\t<td>{intToHex(memory[`${key}`], 2)}</td>\r\n\t\t\t<td>{intToHex(memory[`${key+1}`], 2)}</td>\r\n\t\t\t<td>{intToHex(memory[`${key+2}`], 2)}</td>\r\n\t\t\t<td>{intToHex(memory[`${key+3}`], 2)}</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\n/**\r\n * RegRow: Returns one row of the register table.\r\n * @param {string} letter \t\t- Either r, p or s\r\n * @param {number} idx \t\t\t- Current idx of the register\r\n * @param {Object} registers \t- Object containing all register values with the reg as key. r0-r31, p0-p7, s0-s15\r\n */\r\nconst RegRow = (letter, idx, registers) => {\r\n\tlet val = registers[`${letter}${idx}`];\r\n\r\n\treturn(\r\n\t\t<tr key={`${letter}${idx}`}>\r\n\t\t\t<td>{letter}{idx}</td>\r\n\t\t\t<td>{val}</td>\r\n\t\t\t<td>{intToHexStr(val, 8)}</td>\r\n\t\t</tr>\r\n\t);\r\n};\r\n\r\nDisplayStorage.propTypes = {\r\n\tregisters \t: PropTypes.object,\r\n\tmemory \t\t: PropTypes.object,\r\n};\r\n\r\nexport default DisplayStorage;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { intToHexStr } from \"../../Helpers/misc\";\r\nimport \"../../CSS/Simulator.css\";\r\n\r\n/**\r\n * DisplayCode: Displays all the instructions in the instruction queue as machine, basic and original code.\r\n * @param {number}\tprops.pc\t\t- Current CPU program counter\r\n * @param {Object}\tprops.bundles\t- Object consisting of all instruction bundles from editor\r\n */\r\nconst DisplayCode = (props) => {\r\n\treturn (\r\n\t\t<div className=\"code-container\">\r\n\t\t\t<table className=\"table table-hover table-sm\" id=\"displaycode\">\r\n\t\t\t\t<thead>\r\n\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t<th scope=\"col\">Machine Code</th>\r\n\t\t\t\t\t\t<th scope=\"col\">Basic Code</th>\r\n\t\t\t\t\t\t<th scope=\"col\">Original Code</th>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t</thead>\r\n\t\t\t\t<tbody>\r\n\t\t\t\t\t{GenMachineRows(props.pc, props.bundles)}\r\n\t\t\t\t</tbody>\r\n\t\t\t</table>\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\n/**\r\n * GenMachineRows: Generates all code table rows. \r\n * Done by calling MachineRow on each bundle in bundles. \r\n * @param {Object}\tprops.bundles\t- Object consisting of all instruction bundles from editor\r\n * @param {number}\tpc\t\t\t\t- Current CPU program counter\r\n */\r\nconst GenMachineRows = (pc, bundles) => {\r\n\tlet rows = [];\r\n\tfor (let o in bundles){\r\n\t\trows.push(MachineRow(bundles[o], pc, o));\r\n\t}\r\n\treturn rows;\r\n};\r\n\r\n/**\r\n * MachineRow: Generates one row of the table: Binary | Basic Code | Original code\r\n * Highlights row if current row is the same as program counter (i = pc).\r\n * @param {Object}\tbundles\t- Object consisting of all instruction bundles from editor\r\n * @param {number}\tpc\t\t- Current CPU program counter\r\n * @param {number} \taddr\t- Current bundle address \r\n */\r\nconst MachineRow = (bundle, pc, addr) => {\r\n\tlet idx = 0;\r\n\tlet color = pc === Number(addr) ? \"current-inst\" : \"\";\r\n\tlet rows = [];\r\n\t\r\n\tfor(let i of bundle){\r\n\t\trows.push(\r\n\t\t\t<tr key={idx} className={color} >\r\n\t\t\t\t<td>{intToHexStr(i.instruction.binary[0], 8)}</td>\r\n\t\t\t\t<td>{i.instruction.toString()}</td>\r\n\t\t\t\t<td>{i.original}</td>\r\n\t\t\t</tr>\r\n\t\t);\r\n\t\tidx++;\r\n\t}\r\n\treturn rows;\r\n};\r\n\r\nDisplayCode.propTypes = {\r\n\tpc \t\t\t\t: PropTypes.number,\r\n\tbundles\t\t\t: PropTypes.object,\r\n};\r\n\r\nexport default DisplayCode;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport DisplayButtons from \"./DisplayButtons\";\r\nimport DisplayStorage from \"./DisplayStorage\";\r\nimport DisplayCode from \"./DisplayCode\";\r\nimport \"../../CSS/Simulator.css\";\r\n\r\n/**\r\n * Simulator: Handles all the displaying under the \"Simulator\" tab.\r\n * @param {number}\tprops.pc\t\t\t- Current CPU program counter\r\n * @param {func}\tprops.runClick\t\t- Button run clicked handler\r\n * @param {func}\tprops.stepClick\t\t- Button step clicked handler\r\n * @param {func}\tprops.prevClick\t\t- Button prev clicked handler\r\n * @param {func}\tprops.resetClick\t- Button reset clicked handler\r\n * @param {Object}\tprops.bundles \t\t- Object containing all instruction bundles from editor\r\n * @param {Object} \tprops.registers \t- Object containing all register values with the reg as key. r0-r31, p0-p7, s0-s15\r\n * @param {Object} \tprops.memory\t\t- Object containing the global memory of the program\r\n * @param {string} \tprops.consoleOutput - The output string to console\r\n */\r\nconst Simulator = (props) => {\r\n\treturn(\r\n\t\t<div className=\"sim\">\r\n\t\t\t<div className=\"col-8 col-xl-9 sim-child\">\r\n\t\t\t\t<DisplayButtons \r\n\t\t\t\t\thistory = {props.history}\r\n\t\t\t\t\tstepClick = {props.stepClick} \r\n\t\t\t\t\trunClick = {props.runClick}\r\n\t\t\t\t\tprevClick = {props.prevClick}\r\n\t\t\t\t\tresetClick = {props.resetClick}\r\n\t\t\t\t\tdumpClick = {props.dumpClick}\r\n\t\t\t\t\tpc = {props.pc}\r\n\t\t\t\t\tbundles = {props.bundles}\r\n\t\t\t\t/>\r\n\t\t\t\t<DisplayCode\r\n\t\t\t\t\tpc = {props.pc}\r\n\t\t\t\t\tbundles = {props.bundles}\r\n\t\t\t\t/>\r\n\t\t\t</div>\r\n\r\n\t\t\t<div className=\"col-4 col-xl-3 reg-container sim-child\">\r\n\t\t\t\t<DisplayStorage\r\n\t\t\t\t\tregisters = {props.registers}\r\n\t\t\t\t\tmemory = {props.memory}\r\n\t\t\t\t/>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\nSimulator.propTypes = {\r\n\thistory         : PropTypes.array,\r\n\tpc \t\t\t\t: PropTypes.number,\r\n\trunClick \t\t: PropTypes.func,\r\n\tstepClick\t\t: PropTypes.func,\r\n\tprevClick \t\t: PropTypes.func,\r\n\tresetClick \t\t: PropTypes.func,\r\n\tdumpClick\t\t: PropTypes.func,\r\n\tbundles\t\t\t: PropTypes.object,\r\n\tregisters \t\t: PropTypes.object,\r\n\tmemory \t\t\t: PropTypes.object,\r\n};\r\n\r\nexport default Simulator;\r\n","import React, { Fragment } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport Editor from \"./Editor\";\r\nimport Simulator from \"./Simulator/Simulator\";\r\n\r\n/**\r\n * FrontEnd: Handles the entire front end of Chora. Splits into two tabs: Editor and Simulator.\r\n */\r\nconst FrontEnd = (props) => {\r\n\tlet click, toggle = \"tab\", errMes = \"\";\r\n\r\n\t// fix it so it displays correct line number instead of\r\n\tif (props.error.length) { \r\n\t\tfor (let i in props.error) errMes += props.error[i] === \"fine\" ? \"\" : `L${props.numMap[i]}: ` + props.error[i] + \"\\n\";\r\n\t\tclick = () => { alert(errMes); };\r\n\t\ttoggle = \"\";\r\n\t}\r\n\r\n\treturn (\r\n\t\t<Fragment>\r\n\t\t\t<ul className =\"nav nav-tabs justify-content-center\">\r\n\t\t\t\t<li className=\"nav-item\">\r\n\t\t\t\t\t<a href=\"#editor\" className=\"nav-link active\" data-toggle=\"tab\" role=\"tab\">Editor</a>\r\n\t\t\t\t</li>\r\n\t\t\t\t<li className=\"nav-item \">\r\n\t\t\t\t\t<a href=\"#simulator\" className=\"nav-link\" onClick={click} data-toggle={toggle} role=\"tab\">Simulator</a>\r\n\t\t\t\t</li>\r\n\t\t\t</ul>\r\n\r\n\t\t\t<div className=\"tab-content no-scroll\">\r\n\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane active\" id=\"editor\">\r\n\t\t\t\t\t<Editor\r\n\t\t\t\t\t\teditorUpdate = {props.editorUpdate}\r\n\t\t\t\t\t/>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div role=\"tabpanel\" className=\"tab-pane\" id=\"simulator\">\r\n\t\t\t\t\t<Simulator\r\n\t\t\t\t\t\thistory = {props.history}\r\n\t\t\t\t\t\tmemory = {props.memory}\r\n\t\t\t\t\t\tstepClick = {props.stepClick}\r\n\t\t\t\t\t\trunClick = {props.runClick}\r\n\t\t\t\t\t\tprevClick = {props.prevClick}\r\n\t\t\t\t\t\tresetClick = {props.resetClick}\r\n\t\t\t\t\t\tdumpClick = {props.dumpClick}\r\n\t\t\t\t\t\tregisters = {props.registers}\r\n\t\t\t\t\t\tpc = {props.pc}\r\n\t\t\t\t\t\tbundles = {props.bundles}\r\n\t\t\t\t\t/>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</Fragment>\r\n\t);\r\n};\r\n\r\nFrontEnd.propTypes = {\r\n\thistory         : PropTypes.array,\r\n\teditorUpdate \t: PropTypes.func,\r\n\tpc \t\t\t\t: PropTypes.number,\r\n\trunClick \t\t: PropTypes.func,\r\n\tstepClick\t\t: PropTypes.func,\r\n\tprevClick \t\t: PropTypes.func,\r\n\tresetClick \t\t: PropTypes.func,\r\n\tdumpClick\t\t: PropTypes.func,\r\n\tbundles\t\t\t: PropTypes.object,\r\n\tregisters \t\t: PropTypes.object,\r\n\tmemory \t\t\t: PropTypes.object,\r\n\terror\t\t\t: PropTypes.arrayOf(String),\r\n\tnumMap\t\t\t: PropTypes.array,\r\n};\r\n\r\nexport default FrontEnd;\r\n","class ProcessorState {\r\n\tconstructor() {\r\n\t\tthis.history = [];\r\n\t\tthis.reg = {\r\n\t\t\t// General-purpose registers\r\n\t\t\t\"r0\" : 0,\r\n\t\t\t\"r1\" : 0, \"r2\" : 0, \"r3\" : 0, \"r4\" : 0, \"r5\" : 0,\r\n\t\t\t\"r6\" : 0, \"r7\" : 0, \"r8\" : 0, \"r9\" : 0, \"r10\" : 0, \r\n\t\t\t\"r11\" : 0, \"r12\" : 0, \"r13\" : 0, \"r14\" : 0, \"r15\" : 0,\r\n\t\t\t\"r16\" : 0, \"r17\" : 0, \"r18\" : 0, \"r19\" : 0, \"r20\" : 0, \r\n\t\t\t\"r21\" : 0, \"r22\" : 0, \"r23\" : 0, \"r24\" : 0, \"r25\" : 0,\r\n\t\t\t\"r26\" : 0, \"r27\" : 0, \"r28\" : 0, \"r29\" : 0, \"r30\" : 0, \r\n\t\t\t\"r31\" : 0,\r\n\t\t\t// Special-purpose registers\r\n\t\t\t\"s0\" : 1, \"s1\" : 0, \"s2\" : 0, \"s3\" : 0, \"s4\" : 0, \"s5\" : 0,\r\n\t\t\t\"s6\" : 0, \"s7\" : 0, \"s8\" : 0, \"s9\" : 0, \"s10\" : 0,\r\n\t\t\t\"s11\" : 0, \"s12\" : 0, \"s13\" : 0, \"s14\" : 0, \"s15\" : 0,\r\n\t\t\t// Predicate registers\r\n\t\t\t\"p0\": 1, \"p1\": 0, \"p2\" : 0, \"p3\" : 0, \"p4\" : 0, \"p5\" : 0,\r\n\t\t\t\"p6\" : 0, \"p7\" : 0\r\n\t\t};\r\n\t\tthis.mem = {\r\n\t\t\t\"TEXT_END\" \t: 0,\r\n\t\t\t\"BASE_ADDR\"\t: 0x0,\r\n\t\t\t\"MAX_SIZE\"\t: 0x00200000 // 2MiB\r\n\t\t};\r\n\t\tthis.cpu = {\r\n\t\t\t\"base\": 0,\r\n\t\t\t\"pc\": 0\r\n\t\t};\r\n\t}\r\n\t\r\n\treset() {\r\n\t\tthis.history = [];\r\n\t\tthis.mem = {\r\n\t\t\t\"TEXT_END\" \t: 0,\r\n\t\t\t\"BASE_ADDR\"\t: 0x0,\r\n\t\t\t\"MAX_SIZE\"\t: 0x00200000 // 2MiB\r\n\t\t};\r\n\t\tthis.reg = {\r\n\t\t\t// General-purpose registers\r\n\t\t\t\"r0\" : 0,\r\n\t\t\t\"r1\" : 0, \"r2\" : 0, \"r3\" : 0, \"r4\" : 0, \"r5\" : 0,\r\n\t\t\t\"r6\" : 0, \"r7\" : 0, \"r8\" : 0, \"r9\" : 0, \"r10\" : 0, \r\n\t\t\t\"r11\" : 0, \"r12\" : 0, \"r13\" : 0, \"r14\" : 0, \"r15\" : 0,\r\n\t\t\t\"r16\" : 0, \"r17\" : 0, \"r18\" : 0, \"r19\" : 0, \"r20\" : 0, \r\n\t\t\t\"r21\" : 0, \"r22\" : 0, \"r23\" : 0, \"r24\" : 0, \"r25\" : 0,\r\n\t\t\t\"r26\" : 0, \"r27\" : 0, \"r28\" : 0, \"r29\" : 0, \"r30\" : 0, \r\n\t\t\t\"r31\" : 0,\r\n\t\t\t// Special-purpose registers\r\n\t\t\t\"s0\" : 1, \"s1\" : 0, \"s2\" : 0, \"s3\" : 0, \"s4\" : 0, \"s5\" : 0,\r\n\t\t\t\"s6\" : 0, \"s7\" : 0, \"s8\" : 0, \"s9\" : 0, \"s10\" : 0,\r\n\t\t\t\"s11\" : 0, \"s12\" : 0, \"s13\" : 0, \"s14\" : 0, \"s15\" : 0,\r\n\t\t\t// Predicate registers\r\n\t\t\t\"p0\": 1, \"p1\": 0, \"p2\" : 0, \"p3\" : 0, \"p4\" : 0, \"p5\" : 0,\r\n\t\t\t\"p6\" : 0, \"p7\" : 0\r\n\t\t};\r\n\t\tthis.cpu = {\r\n\t\t\t\"base\": 0,\r\n\t\t\t\"pc\": 0\r\n\t\t};\r\n\t}\r\n\t\r\n\tgetMemory() {\r\n\t\treturn this.mem;\r\n\t}\r\n\r\n\tgetReg() {\r\n\t\treturn this.reg; \r\n\t}\r\n\r\n\tupdateHistory(){\r\n\t\tlet r, m, c;\r\n\t\tr = Object.assign({}, this.reg);\r\n\t\tm = Object.assign({}, this.mem);\r\n\t\tc = Object.assign({}, this.cpu);\r\n\t\tthis.history.push({reg: r, mem: m, cpu: c});\r\n\t}\r\n\t\r\n\trewindOnce(){\r\n\t\tlet prev = this.history.pop();\r\n\t\tif(!prev)\r\n\t\t\treturn false;\r\n\t\tthis.reg = prev.reg;\r\n\t\tthis.mem = prev.mem;\r\n\t\tthis.cpu = prev.cpu;\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nexport default ProcessorState;\r\n","const pseudoTypes = [\r\n\t\"mov\", \"clr\", \"neg\", \"not\", \"li\", \"nop\", \"isodd\", \"pmov\", \"pnot\", \"pset\", \"pclr\"\r\n];\r\nconst binTypes = [\r\n\t\"add\", \"addi\", \"addl\", \"sub\", \"subi\", \"subl\", \"xor\", \"xori\", \"xorl\", \"sl\", \"sli\", \"sll\",\r\n\t\"sr\", \"sri\", \"srl\", \"sra\", \"srai\", \"sral\", \"nor\", \"norl\", \"shadd\", \"shadd2\", \"or\", \"ori\", \"orl\",\r\n\t\"and\", \"andi\", \"andl\",\r\n];\r\nconst compTypes = [\r\n\t\"btest\", \"btesti\", \"cmpeq\", \"cmpieq\", \"cmple\", \"cmpile\", \"cmplt\", \"cmpilt\", \r\n\t\"cmpneq\", \"cmpineq\", \"cmpule\", \"cmpiule\", \"cmpult\", \"cmpiult\"\r\n];\r\nconst loadTypes = [\r\n\t\"lbc\", \"lbl\", \"lbm\", \"lbs\", \"lbuc\", \"lbul\", \"lbum\", \"lbus\", \"lhc\", \"lhl\", \r\n\t\"lhm\", \"lhs\", \"lhuc\", \"lhul\", \"lhum\", \"lhus\", \"lwc\", \"lwl\", \"lwm\", \"lws\" \r\n];\r\nconst storeTypes = [\r\n\t\"sbc\", \"sbl\", \"sbm\", \"sbs\", \"shc\", \"shl\", \"shm\", \"shs\", \"swc\", \"swl\", \"swm\", \"sws\" \r\n];\r\nconst mulTypes = [\r\n\t\"mul\", \"mulu\"\t\r\n];\r\nconst stackTypes = [\r\n\t\"sens\", \"sfree\", \"sres\", \"sspill\",\r\n\t\"sspillr\", \"sensr\",\r\n];\r\nconst predTypes = [\r\n\t\"pand\", \"por\", \"pxor\"\r\n];\r\nconst moveTypes = [\r\n\t\"mts\", \"mfs\"\r\n];\r\nconst cfTypes = [\r\n\t\"callnd\", \"call\", \"brnd\", \"br\", \"brcfnd\", \"brcf\", \"trap\",\r\n\t\"retnd\", \"ret\", \"xretnd\", \"xret\",\r\n\r\n\t// Single reg\r\n\t\"callndr\", \"callr\", \"brndr\", \"brr\",\r\n\r\n\t// Two reg\r\n\t\"brcfr\", \"brcfndr\"\r\n];\r\nconst bitCopyTypes = [\r\n\t\"bcopy\"\r\n];\r\n\r\nconst instTypes = [].concat(\r\n\tpseudoTypes, binTypes, compTypes, loadTypes, storeTypes, \r\n\tmulTypes, stackTypes, predTypes, moveTypes, cfTypes, bitCopyTypes\r\n);\r\n\r\nconst pseudoMapping = {\r\n\t\"MOV_RR\" \t: \"add {1} = {2}, 0\",  \t\t// add \r\n\t\"CLR\" \t\t: \"add {1} = r0, 0\", \t\t// add\r\n\t\"NEG\" \t\t: \"sub {1} = r0, {2}\",\t\t// sub\r\n\t\"NOT\" \t\t: \"nor {1} = {2}, r0\",\t\t// nor\r\n\t\"LI_POS\" \t: \"add {1} = r0, {2}\",\t\t// add\r\n\t\"LI_NEG\" \t: \"sub {1} = r0, {2}\",\t\t// sub\r\n\t\"NOP\"\t\t: \"sub r0 = r0, 0\", \t\t// sub\r\n\t\"ISODD\" \t: \"btest {1} = {2}, r0\",\t// btest\r\n\t\"MOV_PR\" \t: \"cmpneq {1} = {2}, r0\",\t// cmpneq\r\n\t\"PMOV\" \t\t: \"por {1} = {2}, {2}\",\t\t// por\r\n\t\"PNOT\" \t\t: \"pxor {1} = {2}, p0\",\t\t// pxor\r\n\t\"PSET\" \t\t: \"por {1} = p0, p0\",\t\t// por\r\n\t\"PCLR\"\t\t: \"pxor {1} = p0, p0\",\t\t// pxor\r\n\t\"MOV_RP\" \t: \"bcopy {1} = r0, 0, {2}\" \t// bcopy\r\n};\r\n\r\n// Checks if type is allowed in pipeline two. \r\nconst allowedPipelineTwo = (type) => {\r\n\treturn binTypes.includes(type) || compTypes.includes(type);\r\n};\r\n\r\nconst getInstType = (type) => {\r\n\tlet idx, key, keys;\r\n\r\n\tlet instTypeStr = {\r\n\t\tbin \t: binTypes.includes(type),\r\n\t\tcomp \t: compTypes.includes(type),\r\n\t\tload\t: loadTypes.includes(type),\r\n\t\tstore \t: storeTypes.includes(type),\r\n\t\tmul\t\t: mulTypes.includes(type),\r\n\t\tstack\t: stackTypes.includes(type),\r\n\t\tpred \t: predTypes.includes(type),\r\n\t\tcf \t\t: cfTypes.includes(type),\r\n\t\tp1\t\t: type === \"mov\" || type === \"pmov\"\r\n\t};\r\n\t\r\n\tkeys = Object.keys(instTypeStr);\r\n\t\r\n\tfor (idx in keys) {\r\n\t\tkey = keys[idx];\r\n\t\tif (instTypeStr[key]) return key;\r\n\t}\r\n\treturn type;\r\n};\r\n\r\n\r\nexport { instTypes, binTypes, compTypes, loadTypes, storeTypes, mulTypes, \r\n\tstackTypes, predTypes, moveTypes, cfTypes, getInstType, allowedPipelineTwo,\r\n\tpseudoTypes, pseudoMapping };\r\n","// Arrays of register strings\r\nconst regStr = [\r\n\t\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\", \r\n\t\"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \r\n\t\"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\"\r\n];\r\nconst pregStr = [\r\n\t\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\r\n\t\"!p0\", \"!p1\", \"!p2\", \"!p3\", \"!p4\", \"!p5\", \"!p6\", \"!p7\",\r\n];\r\nconst sregStr = [\r\n\t\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \r\n\t\"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\"\r\n];\r\nconst allRegStr = [].concat(\r\n\tregStr, pregStr, sregStr\r\n);\r\n\r\nconst sregMap = {\r\n\tsl : \"s2\",\r\n\tsh : \"s3\",\r\n\tss : \"s5\",\r\n\tst : \"s6\",\r\n\tsrb : \"s7\",\r\n\tsro : \"s8\",\r\n\tsxb : \"s9\",\r\n\tsxo : \"s10\",\r\n};\r\n\r\nexport { regStr, pregStr, sregStr, allRegStr, sregMap };\r\n","import ProcessorState from \"./ProcessorState\";\r\nimport { binTypes, cfTypes } from \"../../Helpers/typeStrings\";\r\nimport { allRegStr } from \"../../Helpers/regStrings\";\r\n\r\nclass CPU {\r\n\tconstructor() {\r\n\t\tthis.state = new ProcessorState();\r\n\t\tthis.history = [];\r\n\t\tthis.bundles = {};\r\n\t\tthis.pending_branch = null;\r\n\t\twindow.state = this.state;\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.state.reset();\r\n\t\tthis.history = [];\r\n\t\tthis.bundles = {};\r\n\t\tthis.pending_branch = null;\r\n\t}\r\n\r\n\tgetPC() {\r\n\t\treturn this.state.cpu[\"pc\"];\r\n\t}\r\n\r\n\tstep() {\r\n\t\tlet bundle = this.bundles[this.state.cpu.pc];\r\n\t\tif(!bundle) return false;\r\n\t\tthis.state.updateHistory();\r\n\t\tbundle.length === 2 ? this.dualIssue(bundle) : this.execute(bundle[0].instruction);\r\n\t\tif (this.pending_branch) this.handlePendingBranch();\r\n\t\treturn true;\r\n\t}\r\n\r\n\tdualIssue(bundle) {\r\n\t\t// slight spaghetti to ensure that bundles like (p0) addi r1 = r0, 5 || (p0) addi r2 = r1, 5; work\r\n\t\tlet conflicts = {};\r\n\t\tfor(let op of bundle[0].ops){\r\n\t\t\tif(allRegStr.includes(op) && bundle[1].ops.includes(op)){\r\n\t\t\t\tconflicts[op] = {};\r\n\t\t\t}\r\n\t\t\t// store original values\r\n\t\t\tfor(let conflict in conflicts){\r\n\t\t\t\tconflicts[conflict].prev = this.state.reg[conflict];\r\n\t\t\t}\r\n\t\t\t// execute\r\n\t\t\tthis.execute(bundle[1].instruction);\r\n\t\t\t// store and reset\r\n\t\t\tfor(let conflict in conflicts){\r\n\t\t\t\tconflicts[conflict].next = this.state.reg[conflict];\r\n\t\t\t\tif(conflicts[conflict].prev !== conflicts[conflict].next){\r\n\t\t\t\t\tthis.state.reg[conflict] = conflicts[conflict].prev;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// execute\r\n\t\t\tthis.execute(bundle[0].instruction);\r\n\t\t\t// recover\r\n\t\t\tfor(let conflict in conflicts){\r\n\t\t\t\tthis.state.reg[conflict] = conflicts[conflict].next;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// execute\r\n\t\tthis.execute(bundle[1].instruction);\r\n\t\t// recover\r\n\t\tfor(let conflict in conflicts){\r\n\t\t\tthis.state.reg[conflict] = conflicts[conflict].next;\r\n\t\t}\r\n\t}\r\n\r\n\thandlePendingBranch() {\r\n\t\tif(this.pending_branch.delay !== 0){\r\n\t\t\tthis.pending_branch.delay--;\r\n\t\t} else {\r\n\t\t\tif(this.pending_branch.inst.name === \"br\"){\r\n\t\t\t\tthis.state.cpu.pc = this.pending_branch.pc;\r\n\t\t\t} else {\r\n\t\t\t\tthis.state.cpu.pc -= 4;\r\n\t\t\t}\r\n\t\t\tthis.pending_branch.inst.execute(this.state);\r\n\t\t\tthis.pending_branch = null;\r\n\t\t}\r\n\t}\r\n\r\n\t// Step one instruction backwards in queue\r\n\tprev() {\r\n\t\tthis.state.rewindOnce();\r\n\t}\r\n\r\n\t// Run all instructions.\r\n\trun() {\r\n\t\tconsole.time(\"Execution time\");\r\n\t\twhile(this.bundles[this.state.cpu.pc]){\r\n\t\t\tthis.step();\r\n\t\t}\r\n\t\tconsole.timeEnd(\"Execution time\");\r\n\t}\r\n\r\n\t/**\r\n\t * Map bundle array to corresponding offsets\r\n\t * @param {Object[]} bundles - An array of bundle objects.\r\n\t */\r\n\tpopulate(bundles){\r\n\t\tthis.reset();\r\n\t\tlet bundle, addr, base_set = false;\r\n\r\n\t\tfor(bundle of bundles){\r\n\t\t\taddr = bundle.offset;\r\n\t\t\tif(bundle.is_data){\r\n\t\t\t\tswitch(bundle.data.type){\r\n\t\t\t\t\tcase \"word\":\r\n\t\t\t\t\t\tthis.state.mem[addr + 3] = bundle.data.value & 0xFF;\r\n\t\t\t\t\t\tthis.state.mem[addr + 2] = (bundle.data.value >> 8) & 0xFF;\r\n\t\t\t\t\t\tthis.state.mem[addr + 1] = (bundle.data.value >> 16) & 0xFF;\r\n\t\t\t\t\t\tthis.state.mem[addr + 0] = (bundle.data.value >> 24) & 0xFF;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif(!base_set){\r\n\t\t\t\t\tthis.state.cpu.base = addr;\r\n\t\t\t\t\tthis.state.cpu.pc = addr;\r\n\t\t\t\t\tbase_set = true;\r\n\t\t\t\t}\r\n\t\t\t\tthis.bundles[addr] = bundle.instructions;\r\n\t\t\t\tthis.setMem(addr, bundle);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (bundle === undefined)\r\n\t\t\treturn false;\r\n\r\n\t\tthis.state.mem[\"TEXT_END\"] = Number(addr) + bundle.size;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tsetMem(addr, bundle){\r\n\t\tlet o = 0;\r\n\t\tfor(let inst of bundle.instructions){\r\n\t\t\tfor(let int of inst.instruction.binary){\r\n\t\t\t\tthis.state.mem[addr + o + 3] = int & 0xFF;\r\n\t\t\t\tthis.state.mem[addr + o + 2] = (int >> 8) & 0xFF;\r\n\t\t\t\tthis.state.mem[addr + o + 1] = (int >> 16) & 0xFF;\r\n\t\t\t\tthis.state.mem[addr + o + 0] = (int >> 24) & 0xFF;\r\n\t\t\t\to += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n \t* @param {Object} inst - Instruction object\r\n\t*/\r\n\texecute(inst) {\r\n\t\tif ( ((inst.pred & 0b1000) >>> 3) !== this.state.reg[`p${inst.pred & 0b0111}`] ) {\r\n\t\t\tif(!cfTypes.includes(inst.name) || inst.name.includes(\"nd\")){\r\n\t\t\t\tinst.execute(this.state);\r\n\t\t\t} else {\r\n\t\t\t\tlet delay = 0;\r\n\t\t\t\tswitch(inst.name){\r\n\t\t\t\t\tcase \"br\":\r\n\t\t\t\t\t\tdelay = 2;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tdelay = 3;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tthis.pending_branch = { delay, inst, pc: this.state.cpu.pc };\r\n\t\t\t\tthis.state.cpu.pc += 4;\r\n\t\t\t}\r\n\t\t} else if (cfTypes.includes(inst.name)){\r\n\t\t\tthis.state.cpu.pc += 4;\r\n\t\t}\r\n\r\n\t\tif(binTypes.includes(inst.name) && inst.type === \"l\") {\r\n\t\t\tthis.state.cpu.pc += 8;\r\n\t\t} else if(!cfTypes.includes(inst.name)){\r\n\t\t\tthis.state.cpu.pc += 4;\r\n\t\t}\r\n\t\tthis.setReadReg();\r\n\t}\r\n\r\n\tgetReg() {\r\n\t\treturn this.state.getReg();\r\n\t}\r\n\r\n\tgetMem() {\r\n\t\treturn this.state.getMemory();\r\n\t}\r\n\r\n\tsetReadReg() {\r\n\t\tthis.state.reg.r0 = 0;\r\n\t\tthis.state.reg.p0 = 1;\r\n\t\tthis.state.reg.s0 = 0;\r\n\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\tthis.state.reg.s0 |= this.state.reg[`p${i}`] << i;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default CPU;\r\n","import { compile_reg, compile_imm, compile_long } from \"./compilers\";\r\n\r\n/** \r\n * Represents a BinaryArithmetics instruction. Sets common fields. \r\n */\r\nclass BinaryArithmetics {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {number}          fields.func - Instruction function\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ name, func, pred, rd, rs1, op2 }) {\r\n\t\tthis.type = isNaN(op2) ? \"r\" : (Number(op2) > 0x0FFF ? \"l\" : \"i\");\r\n\t\tthis.pred = pred;\r\n\t\tthis.rd = rd;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.op2 = op2;\r\n\t\tthis.name = name;\r\n\t\tthis.func = func;\r\n        \r\n\t\t// nor, shadd, shadd2 does not have an immediate format\r\n\t\tif([0b1011, 0b1100, 0b1101].includes(func) && this.type === \"i\"){\r\n\t\t\tthis.type = \"l\";\r\n\t\t}\r\n\r\n\t\tswitch (this.type) {\r\n\t\t\tcase \"r\":\r\n\t\t\t\tthis.binary = compile_reg(pred, rd, rs1, op2, func);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"i\":\r\n\t\t\t\tthis.op2 &= 0xFFF;\r\n\t\t\t\tthis.binary = compile_imm(pred, func, rd, rs1, op2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"l\":\r\n\t\t\t\tthis.binary = compile_long(pred, rd, rs1, func, op2);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unexpected type in ${this.name}`);\r\n\t\t}\r\n\t}\r\n    \r\n\texecute(){\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = ${this.rs1}, ${this.op2}`;\r\n\t}\r\n}\r\n\r\nexport default BinaryArithmetics;","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rd, rs1, rs2, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\trd = parseReg(rd);\r\n\trs1 = parseReg(rs1);\r\n\trs2 = parseReg(rs2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= rs2 << 7;\r\n\tbinary[0] |= func << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_imm = (pred, func, rd, rs1, imm) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\timm = parseNum(imm);\r\n\trd = parseReg(rd);\r\n\trs1 = parseReg(rs1);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= (func & 0x7) << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= imm << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_long = (pred, rd, rs1, func, long) => {\r\n\tlet binary = [0, 0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\tlong = parseNum(long);\r\n\trd = parseReg(rd);\r\n\trs1 = parseReg(rs1);\r\n\r\n\tbinary[0] |= 1 << 31;\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b11111 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= func;\r\n\tbinary[1] = long & 0xFFFFFFFF;\r\n    \r\n\treturn binary;\r\n};\r\n","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Addition instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Add extends BinaryArithmetics {\r\n\t/**\r\n     * Create Add instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"add\", func: 0, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] + (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default Add;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Negated Bitwise OR instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Nor extends BinaryArithmetics {\r\n\t/**\r\n     * Create Nor instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"nor\", func: 11, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = ~((reg[this.rs1] | (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0);\r\n\t}\r\n}\r\n\r\nexport default Nor;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift-by-1-then-Add instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftAdd extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftAdd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"shadd\", func: 12, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = ((reg[this.rs1] << 1) + (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftAdd;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift-by-2-then-Add instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftAdd2 extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftAdd2 instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"shadd2\", func: 13, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = ((reg[this.rs1] << 2) + (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftAdd2;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift left instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftLeft extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftLeft instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"sl\", func: 3, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] << (this.type === \"r\" ? reg[this.op2] & 0x1F : Number(this.op2) & 0x1F)) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftLeft;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift right instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftRight extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftRight instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"sr\", func: 4, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] >>> (this.type === \"r\" ? reg[this.op2] & 0x1F : Number(this.op2) & 0x1F)) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftRight;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Shift right arithmetic instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass ShiftRightArithmetic extends BinaryArithmetics {\r\n\t/**\r\n     * Create ShiftRightArithmetic instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"sra\", func: 5, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] >> (this.type === \"r\" ? reg[this.op2] & 0x1F : Number(this.op2) & 0x1F)) | 0;\r\n\t}\r\n}\r\n\r\nexport default ShiftRightArithmetic;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Subtraction instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Sub extends BinaryArithmetics {\r\n\t/**\r\n     * Create Sub instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"sub\", func: 1, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] - (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default Sub;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Bitwise Exclusive OR instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Xor extends BinaryArithmetics {\r\n\t/**\r\n     * Create Xor instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"xor\", func: 2, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = (reg[this.rs1] ^ (this.type === \"r\" ? reg[this.op2] : Number(this.op2))) | 0;\r\n\t}\r\n}\r\n\r\nexport default Xor;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * Or instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass Or extends BinaryArithmetics {\r\n\t/**\r\n     * Create Or instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"or\", func: 6, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = reg[this.rs1] | (this.type === \"r\" ? reg[this.op2] : Number(this.op2));\r\n\t}\r\n}\r\n\r\nexport default Or;","import BinaryArithmetics from \"./BinaryArithmetics\";\r\n\r\n/** \r\n * And instruction class. \r\n * @extends BinaryArithmetics\r\n * @category BinaryArithmetics\r\n */\r\nclass And extends BinaryArithmetics {\r\n\t/**\r\n     * Create And instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, rd, rs1, op2 }) {\r\n\t\tsuper({ name: \"and\", func: 7, pred, rd, rs1, op2 });\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = reg[this.rs1] & (this.type === \"r\" ? reg[this.op2] : Number(this.op2));\r\n\t}\r\n}\r\n\r\nexport default And;","import { compile_reg, compile_imm } from \"./compilers\";\r\n\r\n/** \r\n * Represents a Compare instruction. Sets common fields. \r\n */\r\nclass Compare {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {number}          fields.func - Instruction function\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ name, pred, pd, rs1, op2, func }) {\r\n\t\tthis.type = isNaN(op2) ? \"r\" : \"i\";\r\n\t\tthis.pred = pred;\r\n\t\tthis.pd = pd;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.op2 = op2;\r\n\t\tthis.name = name;\r\n\t\tthis.func = func;\r\n\r\n\t\tswitch (this.type) {\r\n\t\t\tcase \"r\":\r\n\t\t\t\tthis.binary = compile_reg(pred, pd, rs1, op2, func);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"i\":\r\n\t\t\t\tthis.op2 &= 0x1F;\r\n\t\t\t\tthis.binary = compile_imm(pred, pd, rs1, op2, func);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unexpected type in ${this.name}`);\r\n\t\t}\r\n\t}\r\n    \r\n\texecute(){\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.pd} = ${this.rs1}, ${this.op2}`;\r\n\t}\r\n}\r\n\r\nexport default Compare;","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, pd, rs1, rs2, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\tpd = parseReg(pd);\r\n\trs1 = parseReg(rs1);\r\n\trs2 = parseReg(rs2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= pd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= rs2 << 7;\r\n\tbinary[0] |= 0b011 << 4;\r\n\tbinary[0] |= func << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_imm = (pred, pd, rs1, imm, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\timm = parseNum(imm);\r\n\tpd = parseReg(pd);\r\n\trs1 = parseReg(rs1);\r\n    \r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= pd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= ((imm & 0x1F) << 7);\r\n\tbinary[0] |= 0b110 << 4;\r\n\tbinary[0] |= func << 0;\r\n    \r\n\treturn binary;\r\n};\r\n\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Btest instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Btest extends Compare {\r\n\t/**\r\n     * Create Btest instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"btest\", func: 0b0110, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number((reg[this.rs1] & ( 1 << (this.type === \"r\" ? reg[this.op2] : Number(this.op2) & 0x1F ))) !== 0);\r\n\t}\r\n}\r\n\r\nexport default Btest;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmpeq instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmpeq extends Compare {\r\n\t/**\r\n     * Create Cmpeq instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmpeq\", func: 0b0000, pred, pd, rs1, op2});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number(reg[this.rs1] === (this.type === \"r\" ? \r\n\t\t\treg[this.op2] : ((Number(this.op2) << 27) >> 27)));\r\n\t}\r\n}\r\n\r\nexport default Cmpeq;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Btest instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmple extends Compare {\r\n\t/**\r\n     * Create Cmple instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmple\", func: 0b0011, pred, pd, rs1, op2});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number(reg[this.rs1] <= (this.type === \"r\" ? \r\n\t\t\treg[this.op2] : (Number(this.op2) << 27) >> 27));\r\n\t}\r\n}\r\n\r\nexport default Cmple;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmplt instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmplt extends Compare {\r\n\t/**\r\n     * Create Cmplt instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmplt\", func: 0b0010, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number(reg[this.rs1] < (this.type === \"r\" ? \r\n\t\t\treg[this.op2] : (Number(this.op2) << 27) >> 27));\r\n\t}\r\n}\r\n\r\nexport default Cmplt;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmpneq instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmpneq extends Compare {\r\n\t/**\r\n     * Create Cmpneq instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmpneq\", func: 0b0001, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number(reg[this.rs1] !== (this.type === \"r\" ? \r\n\t\t\treg[this.op2] : (Number(this.op2) << 27) >> 27));\r\n\t}\r\n}\r\n\r\nexport default Cmpneq;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmpule instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmpule extends Compare {\r\n\t/**\r\n     * Create Cmpule instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmpule\", func: 0b0101, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = Number((reg[this.rs1] >>> 0) <= ((this.type === \"r\" ? \r\n\t\t\treg[this.op2] : Number(this.op2)) >>> 0));\r\n\t}\r\n}\r\n\r\nexport default Cmpule;\r\n","import Compare from \"./Compare\";\r\n\r\n/** \r\n * Cmpult instruction class. \r\n * @extends Compare\r\n * @category Compare\r\n */\r\nclass Cmpult extends Compare {\r\n\t/**\r\n     * Create Cmpult instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.pd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, pd, rs1, op2 }) {\r\n\t\tsuper({name: \"cmpult\", func: 0b0100, pred, pd, rs1, op2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */   execute( { reg } ) {\r\n\t\treg[this.pd] = \r\n\t\t\tNumber((reg[this.rs1] >>> 0) < ((this.type === \"r\" ? \r\n\t\t\t\treg[this.op2] : Number(this.op2))) >>> 0);\r\n\t}\r\n}\r\n\r\nexport default Cmpult;\r\n","import { compile_reg, compile_reg2, compile_ireg, compile_imm } from \"./compilers\";\r\n\r\n/** \r\n * Represents a ControlFlow instruction. Sets common fields. \r\n */\r\nclass ControlFLow {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.op   - Type of control\r\n\t * @param {string}          fields.s1   - Either source register or immediate value\r\n\t * @param {string}          fields.s2   - Source register 2.\r\n     */\r\n\tconstructor({ name, pred, d, op, s1, s2 }) {\r\n\t\tthis.type = (!s1 && !s2) ? \"implicit\" : (isNaN(s1) ? (!s2 ? \"single_reg\" : \"two_reg\") : \"immediate\");\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.d = d;\r\n\t\tthis.op = op;\r\n\t\tthis.s1 = s1;\r\n\t\tthis.s2 = s2;\r\n\r\n\t\tswitch(this.type){\r\n\t\t\tcase \"implicit\":\r\n\t\t\t\tthis.binary = compile_ireg(this.pred, this.d, this.op);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"single_reg\":\r\n\t\t\t\tthis.binary = compile_reg(this.pred, this.d, this.op, this.s1);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"two_reg\":\r\n\t\t\t\tthis.binary = compile_reg2(this.pred, this.d, this.op, this.s1, this.s2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"immediate\":\r\n\t\t\t\tthis.s1 &= 0x3FFFFF;\r\n\t\t\t\tthis.binary = compile_imm(this.pred, this.op, this.d, this.s1);\r\n\t\t\t\tthis.s1 = (Number(this.s1) << 10) >> 8;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unexpected type in ${this.name}`);\r\n\t\t}\r\n\t}\r\n\texecute(){\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\ttoString(){\r\n\t\tlet s1 = this.s1 ? isNaN(this.s1) ? this.s1 : this.s1 >> 2 : \"\";\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${s1} ${this.s2 ? \", \"+this.s2 : \"\"}`;\r\n\t}\r\n}\r\n\r\nexport default ControlFLow;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, d, op, rs1) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\td = parseNum(d);\r\n\top = parseNum(op);\r\n\trs1 = parseReg(rs1);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b1100 << 23;\r\n\tbinary[0] |= d << 22;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= 0b01 << 2;\r\n\tbinary[0] |= op << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_reg2 = (pred, d, op, rs1, rs2) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\td = parseNum(d);\r\n\top = parseNum(op);\r\n\trs1 = parseReg(rs1);\r\n\trs2 = parseReg(rs2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b1100 << 23;\r\n\tbinary[0] |= d << 22;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= rs2 << 7;\r\n\tbinary[0] |= 0b10 << 2;\r\n\tbinary[0] |= op << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_ireg = (pred, d, op) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\td = parseNum(d);\r\n\top = parseNum(op);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b1100 << 23;\r\n\tbinary[0] |= d << 22;\r\n\tbinary[0] |= 0b00 << 2;\r\n\tbinary[0] |= op << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_imm = (pred, op, d, imm) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\top = parseNum(op);\r\n\td = parseNum(d); \r\n\timm = parseNum(imm);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b10 << 25;\r\n\tbinary[0] |= op << 23;\r\n\tbinary[0] |= d << 22;\r\n\tbinary[0] |= imm << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Br instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Br extends ControlFlow {\r\n\t/**\r\n     * Create Br instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"br\", d: 1, op: 0b01, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\tcpu.pc = this.type === \"immediate\" ? cpu.pc + addr : addr;\r\n\t}\r\n}\r\n\r\nexport default Br;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Br instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Brcf extends ControlFlow {\r\n\t/**\r\n     * Create Brcf instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"brcf\", d: 1, op: 0b10, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\tlet offset = this.type === \"two_reg\" ? reg[this.s2] : 0;\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr + offset;\r\n\t}\r\n}\r\n\r\nexport default Brcf;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Br instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Brcfnd extends ControlFlow {\r\n\t/**\r\n     * Create Brcfnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"brcfnd\", d: 0, op: 0b10, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\tlet offset = this.type === \"two_reg\" ? reg[this.s2] : 0;\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr + offset;\r\n\t}\r\n}\r\n\r\nexport default Brcfnd;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Brnd instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Brnd extends ControlFlow {\r\n\t/**\r\n     * Create Brnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"brnd\", d: 0, op: 0b01, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\tcpu.pc = (this.type === \"immediate\" ? cpu.pc + addr : addr);\r\n\t}\r\n}\r\n\r\nexport default Brnd;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Call instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Call extends ControlFlow {\r\n\t/**\r\n     * Create Call instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"call\", d: 1, op: 0b00, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1: reg[this.s1];\r\n\t\treg.s7 = cpu.base; \t// srb\r\n\t\treg.s8 = cpu.pc;\t// sro\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr; \t\t// should be offset(addr) but as we have no cache...\r\n\t}\r\n}\r\n\r\nexport default Call;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Call instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Callnd extends ControlFlow {\r\n\t/**\r\n     * Create Callnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"callnd\", d: 0, op: 0b00, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = this.type === \"immediate\" ? this.s1 : reg[this.s1];\r\n\t\treg.s7 = cpu.base;\t// srb\r\n\t\treg.s8 = cpu.pc;\t// sro\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr; \t\t// should be offset(addr) but as we have no cache...\r\n\t}\r\n}\r\n\r\nexport default Callnd;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Ret instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Ret extends ControlFlow {\r\n\t/**\r\n     * Create Ret instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"ret\", d: 1, op: 0b00, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\t//srb s7, sro s8\r\n\t\tcpu.base = reg.s7;\r\n\t\tcpu.pc = reg.s8 + 4; //should be offset(srb) + sro, but as we don't have cache. Also +4 is to set it to the next instruction.\r\n\t}\r\n}\r\n\r\nexport default Ret;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Retnd instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Retnd extends ControlFlow {\r\n\t/**\r\n     * Create Retnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"retnd\", d: 0, op: 0b00, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\t//srb s7, sro s8\r\n\t\tcpu.base = reg.s7;\r\n\t\tcpu.pc = reg.s8 + 4; //should be offset(sxb) + sxo, but as we don't have cache.\r\n\t}\r\n}\r\n\r\nexport default Retnd;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Trap instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Trap extends ControlFlow {\r\n\t/**\r\n     * Create Trap instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"trap\", d: 0, op: 0b11, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\tlet addr = 0xf0010080 + this.s1;\t//exception table base addr: 0xF0010080\r\n\t\treg.s9 = cpu.base; \t\t\t\t\t// sxb\r\n\t\treg.s10 = cpu.pc;\t\t\t\t\t// sxo\r\n\t\tcpu.base = addr;\r\n\t\tcpu.pc = addr; \t\t\t\t\t\t// should be offset(addr) but as we have no cache...\r\n\t}\r\n}\r\n\r\nexport default Trap;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Xret instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Xret extends ControlFlow {\r\n\t/**\r\n     * Create Xret instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"xret\", d: 1, op: 0b01, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\t//sxb s9, sxo s10\r\n\t\tcpu.base = reg.s9;\r\n\t\tcpu.pc = reg.s10 + 4; //should be offset(sxb) + sxo, but as we don't have cache.\r\n\t}\r\n}\r\n\r\nexport default Xret;","import ControlFlow from \"./ControlFlow\";\r\n\r\n/** \r\n * Xretnd instruction class. \r\n * @extends ControlFlow\r\n * @category ControlFlow\r\n */\r\nclass Xretnd extends ControlFlow {\r\n\t/**\r\n     * Create Xretnd instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string|number}   fields.op2  - Second operand. Can be a second source register or immediate value.\r\n     */\r\n\tconstructor({ pred, s1, s2 }) {\r\n\t\tsuper({ name: \"xretnd\", d: 0, op: 0b01, pred, s1, s2 });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state           - Processor state\r\n     * @param {Object.<string, number>} state.reg       - Registers\r\n     * @param {Object}                  state.cpu       - Object containing CPU internals such as PC.\r\n     * @param {number}                  state.cpu.base  - Base address\r\n     * @param {number}                  state.cpu.pc    - Program counter\r\n     */\r\n\texecute({ reg, cpu }) {\r\n\t\t//sxb s9, sxo s10\r\n\t\tcpu.base = reg.s9;\r\n\t\tcpu.pc = reg.s10 + 4; //should be offset(sxb) + sxo, but as we don't have cache.\r\n\t}\r\n}\r\n\r\nexport default Xretnd;","import { compile_reg } from \"./compilers\";\r\nimport { toUint32 } from \"../../../Helpers/misc\";\r\n\r\n/** \r\n * Represents a LoadTyped instruction. Sets common fields. \r\n */\r\nclass LoadTyped {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n     * @param {string}   \t\tfields.type - Instruction type\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ name, pred, rd, ra, type, imm }) {\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.rd = rd;\r\n\t\tthis.ra = ra;\r\n\t\tthis.type = type;\r\n\t\tthis.imm = toUint32(imm) & 0x7F;\t// Imm is interpreted unsigned\r\n\t\tthis.binary = compile_reg(pred, rd, ra, type, imm);\r\n\t}\r\n\r\n\texecute() {\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = [${this.ra} + ${this.imm}]`;\r\n\t}\r\n}\r\nexport default LoadTyped;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rd, ra, type, imm) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\timm = parseNum(imm);\r\n\ttype = parseNum(type);\r\n\trd = parseReg(rd);\r\n\tra = parseReg(ra);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01010 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= ra << 12;\r\n\tbinary[0] |= type << 7;\r\n\tbinary[0] |= imm << 0;\r\n\r\n\treturn binary;\r\n};\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lws instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lws extends LoadTyped {\r\n\t/**\r\n     * Create Lws instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lws\", pred, rd, ra, type: 0b00000, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 2);\r\n\t\tlet hh = mem[reg[\"s6\"] + address + 0];\r\n\t\tlet hl = mem[reg[\"s6\"] + address + 1];\r\n\t\tlet lh = mem[reg[\"s6\"] + address + 2];\r\n\t\tlet ll = mem[reg[\"s6\"] + address + 3];\r\n\r\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\r\n\t}\r\n}\r\n\r\nexport default Lws;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lwl instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lwl extends LoadTyped{\r\n\t/**\r\n     * Create Lwl instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lwl\", pred, rd, ra, type: 0b00001, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 2);\r\n\t\tlet hh = mem[address + 0];\r\n\t\tlet hl = mem[address + 1];\r\n\t\tlet lh = mem[address + 2];\r\n\t\tlet ll = mem[address + 3];\r\n\r\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\r\n\t}\r\n}\r\n\r\nexport default Lwl;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lwc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lwc extends LoadTyped {\r\n\t/**\r\n     * Create Lwc instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lwc\", pred, rd, ra, type: 0b00010, imm });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 2);\r\n\t\tlet hh = mem[address + 0];\r\n\t\tlet hl = mem[address + 1];\r\n\t\tlet lh = mem[address + 2];\r\n\t\tlet ll = mem[address + 3];\r\n\r\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\r\n\t}\r\n}\r\n\r\nexport default Lwc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lwm instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lwm extends LoadTyped {\r\n\t/**\r\n   * Create Lwm instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lwm\", pred, rd, ra, type: 0b00011, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 2);\r\n\t\tlet hh = mem[address + 0];\r\n\t\tlet hl = mem[address + 1];\r\n\t\tlet lh = mem[address + 2];\r\n\t\tlet ll = mem[address + 3];\r\n\r\n\t\treg[this.rd] = (hh << 24) | (hl << 16) | (lh << 8) | ll;\r\n\t}\r\n}\r\n\r\nexport default Lwm;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhs instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhs extends LoadTyped {\r\n\t/**\r\n   * Create Lhs instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhs\", pred, rd, ra, type: 0b00100, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[reg[\"s6\"] + address + 0];\r\n\t\tlet lo = mem[reg[\"s6\"] + address + 1];\r\n\t\r\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16;\r\n\t}\r\n}\r\n\r\nexport default Lhs;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhl instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhl extends LoadTyped{\r\n\t/**\r\n     * Create Lhl instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lhl\", pred, rd, ra, type: 0b00101, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16; \r\n\t}\r\n}\r\n\r\nexport default Lhl;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhc extends LoadTyped{\r\n\t/**\r\n     * Create Lhc instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lhc\", pred, rd, ra, type: 0b00110, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16; \r\n\t}\r\n\r\n}\r\n\r\nexport default Lhc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhm instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhm extends LoadTyped{\r\n\t/**\r\n     * Create Lhm instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lhm\", pred, rd, ra, type: 0b00111, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (((hi << 8) | lo) << 16) >> 16; \r\n\t}\r\n}\r\n\r\nexport default Lhm;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbs instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbs extends LoadTyped {\r\n\t/**\r\n\t * Create Lbs instruction.\r\n\t * @param {Object}          fields      - Fields to set \r\n\t * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}          fields.rd   - Destination register\r\n\t * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n\t */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lbs\", pred, rd, ra, type: 0b01000, imm });\r\n\t}\r\n\r\n\t/**\r\n\t * Executes the instruction\r\n\t * @param {Object}                  state        - Processor state\r\n\t * @param {Object.<string, number>} state.reg    - Registers\r\n\t */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = (mem[reg[\"s6\"] + reg[this.ra] + this.imm] << 24) >> 24;\r\n\t}\r\n\r\n}\r\n\r\nexport default Lbs;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbl instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbl extends LoadTyped {\r\n\t/**\r\n     * Create Lbl instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lbl\", pred, rd, ra, type: 0b01001, imm });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = (mem[reg[this.ra] + this.imm] << 24) >> 24;\r\n\t}\r\n}\r\n\r\nexport default Lbl;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbc extends LoadTyped {\r\n\t/**\r\n     * Create Lbc instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n     * @param {string}   \t\tfields.type - Second operand. Can be a second source register or immediate value.\r\n     * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lbc\", pred, rd, ra, type: 0b01010, imm });\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = (mem[reg[this.ra] + this.imm] << 24) >> 24;\r\n\t}\r\n}\r\n\r\nexport default Lbc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbm instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbm extends LoadTyped {\r\n\t/**\r\n\t * Create Lbm instruction.\r\n\t * @param {Object}          fields      - Fields to set \r\n\t * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}          fields.rd   - Destination register\r\n\t * @param {string}          fields.ra  \t- First source register\r\n\t * @param {number}\t\t\tfields.imm\t- Immediate value \r\n\t */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lbm\", pred, rd, ra, type: 0b01011, imm });\r\n\t}\r\n\r\n\t/**\r\n\t * Executes the instruction\r\n\t * @param {Object}                  state        - Processor state\r\n\t * @param {Object.<string, number>} state.reg    - Registers\r\n\t */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = (mem[reg[this.ra] + this.imm] << 24) >> 24;\r\n\t}\r\n}\r\n\r\nexport default Lbm;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhus instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhus extends LoadTyped {\r\n\t/**\r\n   * Create Lhus instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhus\", pred, rd, ra, type: 0b01100, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[reg[\"s6\"] + address + 0];\r\n\t\tlet lo = mem[reg[\"s6\"] + address + 1];\r\n\r\n\t\treg[this.rd] = (hi << 8) | lo;\r\n\t}\r\n}\r\n\r\nexport default Lhus;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhul instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhul extends LoadTyped {\r\n\t/**\r\n   * Create Lhul instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhul\", pred, rd, ra, type: 0b01101, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\t\r\n\t\treg[this.rd] = (hi << 8) | lo;\r\n\t}\r\n}\r\n\r\nexport default Lhul;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhuc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhuc extends LoadTyped {\r\n\t/**\r\n   * Create Lhuc instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhuc\", pred, rd, ra, type: 0b01110, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (hi << 8) | lo;\r\n\t}\r\n}\r\n\r\nexport default Lhuc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lhum instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lhum extends LoadTyped {\r\n\t/**\r\n   * Create Lhum instruction.\r\n   * @param {Object}          fields      - Fields to set \r\n   * @param {string|number}   fields.pred - Instruction predicate\r\n   * @param {string}          fields.rd   - Destination register\r\n   * @param {string}          fields.ra  \t- First source register\r\n   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n   */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({ name: \"lhum\", pred, rd, ra, type: 0b01111, imm });\r\n\t}\r\n\r\n\t/**\r\n   * Executes the instruction\r\n   * @param {Object}                  state        - Processor state\r\n   * @param {Object.<string, number>} state.reg    - Registers\r\n   */\r\n\texecute({ reg, mem }) {\r\n\t\tlet address = reg[this.ra] + (this.imm << 1);\r\n\t\tlet hi = mem[address + 0];\r\n\t\tlet lo = mem[address + 1];\r\n\r\n\t\treg[this.rd] = (hi << 8) | lo;\r\n\t}\r\n}\r\n\r\nexport default Lhum;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbus instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbus extends LoadTyped{\r\n\t/**\r\n     * Create Lbus instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lbus\", pred, rd, ra, type: 0b10000, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = mem[reg[\"s6\"] + reg[this.ra] + this.imm] & 0xFF; \r\n\t}\r\n}\r\n\r\nexport default Lbus;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbul instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbul extends LoadTyped{\r\n\t/**\r\n     * Create Lbul instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lbul\", pred, rd, ra, type: 0b10001, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = mem[reg[this.ra] + this.imm] & 0xFF; \r\n\t}\r\n}\r\n\r\nexport default Lbul;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbuc instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbuc extends LoadTyped{\r\n\t/**\r\n     * Create Lbuc instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lbuc\", pred, rd, ra, type: 0b10010, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = mem[reg[this.ra] + this.imm] & 0xFF; \r\n\t}\r\n}\r\n\r\nexport default Lbuc;\r\n","import LoadTyped from \"./LoadTyped\";\r\n\r\n/** \r\n * Lbum instruction class. \r\n * @extends LoadTyped\r\n * @category LoadTyped\r\n */\r\nclass Lbum extends LoadTyped{\r\n\t/**\r\n     * Create Lbum instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.ra  \t- First source register\r\n\t   * @param {number}\t\t\tfields.imm\t- Immediate value \r\n     */\r\n\tconstructor({ pred, rd, ra, imm }) {\r\n\t\tsuper({name: \"lbum\", pred, rd, ra, type: 0b10011, imm});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\treg[this.rd] = mem[reg[this.ra] + this.imm] & 0xFF; \r\n\t}\r\n}\r\n\r\nexport default Lbum;\r\n","import { compile_reg } from \"./compilers\";\r\n\r\n/** \r\n * Represents a Multiply instruction. Sets common fields. \r\n */\r\nclass Multiply {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string}          fields.rs2  - Second source register\r\n     * @param {number}          fields.func - Instruction function\r\n     */\r\n\tconstructor({ name, pred, rs1, rs2, func }) {\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.rs2 = rs2;\r\n\t\tthis.func = func; \r\n\t\tthis.binary = compile_reg(pred, rs1, rs2, func);\r\n\t}\r\n    \r\n\texecute(){\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rs1}, ${this.rs2}`;\r\n\t}\r\n}\r\nexport default Multiply;","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rs1, rs2, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\trs1 = parseReg(rs1);\r\n\trs2 = parseReg(rs2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= rs2 << 7;\r\n\tbinary[0] |= 0b010 << 4;\r\n\tbinary[0] |= func << 0;\r\n\r\n\treturn binary;\r\n};\r\n","import Multiply from \"./Multiply\";\r\n\r\n/** \r\n * Mul instruction class. \r\n * @extends Multiply\r\n * @category Multiply\r\n */\r\nclass Mul extends Multiply {\r\n\t/**\r\n     * Create Mul instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string}          fields.rs2  - Second source register\r\n     */\r\n\tconstructor({ pred, rs1, rs2 }) {\r\n\t\tsuper({name: \"mul\", func: 0b0000, pred, rs1, rs2});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[\"s2\"] = Math.imul(reg[this.rs1], reg[this.rs2]);\r\n\t\treg[\"s3\"] = (reg[this.rs1] * reg[this.rs2] / (2**32)) | 0;\r\n\t}\r\n}\r\n\r\nexport default Mul;\r\n","import Multiply from \"./Multiply\";\r\n\r\n/** \r\n * Mulu instruction class. \r\n * @extends Multiply\r\n * @category Multiply\r\n */\r\nclass Mulu extends Multiply {\r\n\t/**\r\n     * Create Mulu instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string}          fields.rs2  - Second source register\r\n     */\r\n\tconstructor({ pred, rs1, rs2 }) {\r\n\t\tsuper({name: \"mulu\", func: 0b0001, pred, rs1, rs2});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state       - Processor state\r\n     * @param {Object.<string, number>} state.reg   - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[\"s2\"] = Math.imul(reg[this.rs1], reg[this.rs2]);\r\n\t\treg[\"s3\"] = (((reg[this.rs1] >>> 0) * (reg[this.rs2] >>> 0))/(2**32))>>>0;\r\n\t}\r\n}\r\n\r\nexport default Mulu;\r\n","import { compile_reg } from \"./compilers\";\r\n\r\n/** \r\n * Represents a Predicate instruction. Sets common fields. \r\n */\r\nclass Predicate {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}\t\t\tfields.pd \t- Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {string}          fields.rs2  - Second source register\r\n     * @param {number}          fields.func - Instruction function\r\n     */\r\n\tconstructor({ name, pred, pd, ps1, ps2, func }) {\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.pd = pd;\r\n\t\tthis.neg1 = ps1[0] === \"!\";\r\n\t\tthis.neg2 = ps2[0] === \"!\";\r\n\t\tthis.ps1 = ps1.replace(\"!\", \"\");\r\n\t\tthis.ps2 = ps2.replace(\"!\", \"\");\r\n\t\tthis.func = func; \r\n\t\tthis.binary = compile_reg(pred, pd, ps1, ps2, func);\r\n\t}\r\n    \r\n\texecute(){\r\n\t\tconsole.error(\"Missing execute handler for\", this);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.pd} = ${this.neg1 ? \"!\" : \"\"}${this.ps1}, ${this.neg2 ? \"!\" : \"\"}${this.ps2}`;\r\n\t}\r\n}\r\n\r\nexport default Predicate;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, pd, ps1, ps2, func) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\tfunc = parseNum(func);\r\n\tpd = parseReg(pd);\r\n\tps1 = ps1[0] === \"!\" ? 0b1000 | parseReg(ps1) : parseReg(ps1);\r\n\tps2 = ps2[0] === \"!\" ? 0b1000 | parseReg(ps2) : parseReg(ps2);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= pd << 17;\r\n\tbinary[0] |= ps1 << 12;\r\n\tbinary[0] |= ps2 << 7;\r\n\tbinary[0] |= 0b100 << 4;\r\n\tbinary[0] |= func << 0;\r\n\r\n\treturn binary;\r\n};\r\n","import Predicate from \"./Predicate\";\r\n\r\n/** \r\n * Pand instruction class. \r\n * @extends Predicate\r\n * @category Predicate\r\n */\r\nclass Pand extends Predicate {\r\n\t/**\r\n     * Create Pand instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}\t\t\tfields.pd \t- Destination register\r\n     * @param {string}          fields.ps1  - First predicate register\r\n     * @param {string}          fields.ps2  - Second predicate register\r\n     */\r\n\tconstructor({ pred, pd, ps1, ps2 }) {\r\n\t\tsuper({name: \"pand\", pred, pd, ps1, ps2, func:0b0111});\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = ((this.neg1 ? ~reg[this.ps1] : reg[this.ps1]) & (this.neg2 ? ~reg[this.ps2] : reg[this.ps2])) & 0x1;\r\n\t}\r\n}\r\n\r\nexport default Pand;\r\n","import Predicate from \"./Predicate\";\r\n\r\n/** \r\n * Pand instruction class. \r\n * @extends Predicate\r\n * @category Predicate\r\n */\r\nclass Pxor extends Predicate {\r\n\t/**\r\n     * Create Pxor instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}\t\t\tfields.pd \t- Destination register\r\n     * @param {string}          fields.ps1  - First predicate register\r\n     * @param {string}          fields.ps2  - Second predicate register\r\n     */\r\n\tconstructor({ pred, pd, ps1, ps2 }) {\r\n\t\tsuper({name: \"pxor\", pred, pd, ps1, ps2, func:0b1010});\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = ((this.neg1 ? ~reg[this.ps1] : reg[this.ps1]) ^ (this.neg2 ? ~reg[this.ps2] : reg[this.ps2])) & 0x1;\r\n\t}\r\n}\r\n\r\nexport default Pxor;\r\n","import Predicate from \"./Predicate\";\r\n\r\n/** \r\n * Pand instruction class. \r\n * @extends Predicate\r\n * @category Predicate\r\n */\r\nclass Por extends Predicate {\r\n\t/**\r\n     * Create Por instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {string}\t\t\tfields.pd \t- Destination register\r\n     * @param {string}          fields.ps1  - First predicate register\r\n     * @param {string}          fields.ps2  - Second predicate register\r\n     */\r\n\tconstructor({ pred, pd, ps1, ps2 }) {\r\n\t\tsuper({name: \"por\", pred, pd, ps1, ps2, func:0b0110});\r\n\t}\r\n\t\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute( { reg } ) {\r\n\t\treg[this.pd] = ((this.neg1 ? ~reg[this.ps1] : reg[this.ps1]) | (this.neg2 ? ~reg[this.ps2] : reg[this.ps2])) & 0x1;\r\n\t}\r\n}\r\n\r\nexport default Por;\r\n","import { compile_reg, compile_imm } from \"./compilers\";\r\n\r\n/** \r\n * Represents a StackControl instruction. Sets common fields. \r\n */\r\nclass StackControl {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.op   - Type of control\r\n\t * @param {string}          fields.s1   - Either source register or immediate value\r\n     */\r\n\tconstructor({ name, pred, op, s1 }) {\r\n\t\tthis.type = isNaN(s1) ? \"r\" : \"i\";\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.op = op;\r\n\t\tthis.s1 = s1;\r\n\r\n\t\tif (this.type === \"r\") {\r\n\t\t\tthis.binary = compile_reg(pred, op, s1);\r\n\t\t} else {\r\n\t\t\tthis.s1 &= 0x3FFFF;\r\n\t\t\tthis.binary = compile_imm(pred, op, s1);\r\n\t\t}\r\n\t}\r\n\t\r\n\texecute(){\r\n\t\tthrow new Error(\"No execute handler\");\r\n\t}\r\n\t\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.s1}`;\r\n\t}\r\n}\r\n\r\nexport default StackControl;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, op, rs) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\top = parseNum(op);\r\n\trs = parseReg(rs);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01100 << 22;\r\n\tbinary[0] |= op << 20;\r\n\tbinary[0] |= 0b01 << 18;\r\n\tbinary[0] |= rs << 12;\r\n\r\n\treturn binary;\r\n};\r\n\r\nexport const compile_imm = (pred, op, imm) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\top = parseNum(op);\r\n\timm = parseNum(imm);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01100 << 22;\r\n\tbinary[0] |= op << 20;\r\n\tbinary[0] |= 0b00 << 18;\r\n\tbinary[0] |= imm << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n","import StackControl from \"./StackControl\";\r\n\r\n/** \r\n * Sres instruction class. \r\n * @extends StackControl\r\n * @category StackControl\r\n */\r\nclass Sens extends StackControl {\r\n\t/**\r\n     * Create Sens instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {number}\t\t\tfields.s1\t- Immediate value \r\n     */\r\n\tconstructor({ pred, s1 }) {\r\n\t\tsuper({name: \"sens\", pred, op: 0b01, s1});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\tlet n = Number(this.type === \"r\" ? reg[this.s1] : this.s1 << 2); // Word size to byte size\r\n\t\treg[\"s5\"] = Math.max(reg[\"s5\"], reg[\"s6\"] + n);\r\n        \r\n\t\t/*\r\n        let nfill;\r\n        nfill = n - (reg[\"s5\"] - reg[\"s6\"]); // n - (m_top - sc_top)\r\n        for (let i = 0; i < nfill; ++i){\r\n            // We aren't actually implementing a stack cache and thus no copying is needed.\r\n            //sc[reg[\"s5\"]] = gm[reg[\"s5\"]];\r\n            reg[\"s5\"] += 1;\r\n        }\r\n        */\r\n\t}\r\n}\r\n\r\nexport default Sens;\r\n","import StackControl from \"./StackControl\";\r\n\r\n/** \r\n * Sfree instruction class. \r\n * @extends StackControl\r\n * @category StackControl\r\n */\r\nclass Sfree extends StackControl {\r\n\t/**\r\n     * Create Sfree instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {number}\t\t\tfields.s1\t- Immediate value \r\n     */\r\n\tconstructor({ pred, s1 }) {\r\n\t\tsuper({name: \"sfree\", pred, op: 0b10, s1});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\t// Increment st by n words.\r\n\t\treg[\"s6\"] += Number(this.s1) << 2;\r\n\t\t// If st > ss, set ss = st\r\n\t\tif(reg[\"s6\"] > reg[\"s5\"]){\r\n\t\t\treg[\"s5\"] = reg[\"s6\"];\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default Sfree;\r\n","import StackControl from \"./StackControl\";\r\n\r\n/** \r\n * Sres instruction class. \r\n * @extends StackControl\r\n * @category StackControl\r\n */\r\nclass Sres extends StackControl {\r\n\t/**\r\n     * Create Sres instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.s1   - Immediate value\r\n     */\r\n\tconstructor({ pred, s1 }) {\r\n\t\tsuper({name: \"sres\", pred, op: 0b00, s1});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg/*, sc*/ }) {\r\n\t\t//let nspill;\r\n\t\treg[\"s6\"] -= Number(this.s1) << 2; // Words to bytes.\r\n\t\t/*nspill = reg[\"s5\"] - reg[\"s6\"]; //- sc[\"MAX_SIZE\"]; // max_size of our imaginary cache as 0 would be boring :)\r\n\t\tfor(let i = 0; i < nspill; ++i){\r\n\t\t\treg[\"s5\"] -= 1;\r\n\t\t\t// Copying not needed as we have no actual cache.\r\n\t\t\t//gm[reg[\"s5\"]] = sc[reg[\"s5\"]]; // No masking, just keep the keys identical between sc and gm.\r\n\t\t}*/\r\n\t}\r\n}\r\n\r\nexport default Sres;\r\n","import StackControl from \"./StackControl\";\r\n\r\n/** \r\n * Sspill instruction class. \r\n * @extends StackControl\r\n * @category StackControl\r\n */\r\nclass Sspill extends StackControl {\r\n\t/**\r\n     * Create Sspill instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n\t * @param {number}\t\t\tfields.s1\t- Immediate value \r\n     */\r\n\tconstructor({ pred, s1 }) {\r\n\t\tsuper({name: \"sspill\", pred, op: 0b11, s1});\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg  }) {\r\n\t\tlet n = Number(this.type === \"r\" ? reg[this.s1] : this.s1 << 2);\r\n\t\treg[\"s5\"] -= n;\r\n\t\t// not emulating the actual spill from cache to mem.\r\n\t}\r\n}\r\n\r\nexport default Sspill;\r\n","import {compile_reg} from \"./compilers\";\r\nimport { toUint32 } from \"../../../Helpers/misc\";\r\n\r\n/** \r\n * Represents a StoreTyped instruction. Sets common fields. \r\n */\r\nclass StoreTyped {\r\n\t/**\r\n     * Create base instruction.\r\n     * @param {Object}          fields      - Fields to set \r\n     * @param {string}          fields.name - Name of instruction\r\n     * @param {string|number}   fields.pred - Instruction predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {number}   \t\tfields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ name, pred, type, ra, rs, imm }) {\r\n\t\tthis.name = name;\r\n\t\tthis.pred = pred;\r\n\t\tthis.type = type;\r\n\t\tthis.ra = ra;\r\n\t\tthis.rs = rs;\r\n\t\tthis.imm = toUint32(imm) & 0x7F;\r\n\t\tthis.binary = compile_reg(pred, type, ra, rs, imm);\r\n\t}\r\n\r\n\texecute() {\r\n\t\tthrow new Error(\"Missing execute handler for\", this);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} [${this.ra} + ${this.imm}] = ${this.rs}`;\r\n\t}\r\n}\r\n\r\nexport default StoreTyped;\r\n","import { parseNum, parseReg } from \"../../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, type, ra, rs, offset) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\ttype = parseNum(type);\r\n\tra = parseReg(ra);\r\n\trs = parseReg(rs);\r\n\toffset = parseNum(offset);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01011 << 22;\r\n\tbinary[0] |= type << 17;\r\n\tbinary[0] |= ra << 12;\r\n\tbinary[0] |= rs << 7;\r\n\tbinary[0] |= offset << 0;\r\n\r\n\treturn binary;\r\n};\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sbc instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sbc extends StoreTyped {\r\n\t/**\r\n     * Create Sbc instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sbc\", pred, type: 0b01010, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm);\r\n\t\tmem[addr] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sbc;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sbl instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sbl extends StoreTyped {\r\n\t/**\r\n     * Create Sbl instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sbl\", pred, type: 0b01001, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm);\r\n\t\tmem[addr] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sbl;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sbm instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sbm extends StoreTyped {\r\n\t/**\r\n     * Create Sbm instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sbm\", pred, type: 0b01011, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm);\r\n\t\tmem[addr] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sbm;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sbs instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sbs extends StoreTyped {\r\n\t/**\r\n     * Create Sbs instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sbs\", pred, type: 0b01000, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[\"s6\"] + reg[this.ra] + (this.imm);\r\n\t\tmem[addr]   = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sbs;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Shc instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Shc extends StoreTyped {\r\n\t/**\r\n     * Create Shc instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"shc\", pred, type: 0b00110, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 1);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Shc;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Shl instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Shl extends StoreTyped {\r\n\t/**\r\n     * Create Shl instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"shl\", pred, type: 0b00101, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 1);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Shl;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Shm instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Shm extends StoreTyped {\r\n\t/**\r\n     * Create Shm instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"shm\", pred, type: 0b00111, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 1);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Shm;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Shs instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Shs extends StoreTyped {\r\n\t/**\r\n     * Create Shs instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"shs\", pred, type: 0b00100, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[\"s6\"] + reg[this.ra] + (this.imm << 1);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Shs;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Swc instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Swc extends StoreTyped {\r\n\t/**\r\n     * Create Swc instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"swc\", pred, type: 0b00010, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 2);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\r\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Swc;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Swl instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Swl extends StoreTyped {\r\n\t/**\r\n     * Create Swl instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"swl\", pred, type: 0b00001, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 2);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\r\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Swl;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Swm instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Swm extends StoreTyped {\r\n\t/**\r\n     * Create Swm instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"swm\", pred, type: 0b00011, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[this.ra] + (this.imm << 2);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\r\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Swm;\r\n","import StoreTyped from \"./StoreTyped\";\r\n\r\n/** \r\n * Sws instruction class. \r\n * @extends StoreTyped\r\n * @category StoreTyped\r\n */\r\nclass Sws extends StoreTyped {\r\n\t/**\r\n     * Create Sws instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.ra   - Destination\r\n     * @param {string}          fields.rs  \t- Source register\r\n     * @param {string|number}   fields.imm  - Immediate offset value\r\n     */\r\n\tconstructor({ pred, ra, rs, imm }) {\r\n\t\tsuper({name: \"sws\", pred, type: 0b00000, ra, rs, imm});\r\n\t}\r\n\r\n\t/**\t\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg, mem }) {\r\n\t\tlet addr = reg[\"s6\"] + reg[this.ra] + (this.imm << 2);\r\n\t\tmem[addr+0] = (reg[this.rs] >> 24) & 0xFF;\r\n\t\tmem[addr+1] = (reg[this.rs] >> 16) & 0xFF;\r\n\t\tmem[addr+2] = (reg[this.rs] >> 8) & 0xFF;\r\n\t\tmem[addr+3] = (reg[this.rs]) & 0xFF;\r\n\t}\r\n}\r\n\r\nexport default Sws;\r\n","import { parseNum, parseReg } from \"../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rd, rs1, imm, ps) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\timm = parseNum(imm);\r\n\trd = parseReg(rd);\r\n\trs1 = parseReg(rs1);\r\n\tps = ps[0] === \"!\" ? 0b1000 | parseReg(ps) : parseReg(ps);\r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01000 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= imm << 7;\r\n\tbinary[0] |= 0b101 << 4;\r\n\tbinary[0] |= ps << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n/** \r\n * Bitcopy instruction class. \r\n * @category Bitcopy\r\n */\r\nclass Bcopy {\r\n\t/**\r\n     * Create Bcopy instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n     * @param {string}          fields.rs1  - First source register\r\n     * @param {number}          fields.imm  - Second operand, immediate value.\r\n     * @param {string}          fields.ps   - Predicate register. (can be negated)\r\n     */\r\n\tconstructor({pred, rd, rs1, imm, ps}) {\r\n\t\tthis.name = \"bcopy\";\r\n\t\tthis.pred = pred;\r\n\t\tthis.rd = rd;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.imm = imm & 0x1F;\r\n\t\tthis.ps = ps; \r\n\t\tthis.binary = compile_reg(pred, rd, rs1, imm, ps); \r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\tlet shift = (this.ps[0] === \"!\") === (reg[this.ps.replace(\"!\",\"\")] === 1) ? 0 : 1; // Handle negation of p-register\r\n\t\treg[this.rd] = (reg[this.rs1] & ~(1 << this.imm)) | (shift << this.imm);\r\n\t}\r\n\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = ${this.rs1}, ${this.imm}, ${this.ps}`;\r\n\t}\r\n\r\n}\r\n\r\nexport default Bcopy;\r\n","import { parseNum, parseReg } from \"../../Helpers/misc\";\r\n\r\nexport const compile_reg = (pred, rd, ss) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\trd = parseReg(rd);\r\n\tss = parseReg(ss); \r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01001 << 22;\r\n\tbinary[0] |= rd << 17;\r\n\tbinary[0] |= 0b011 << 4;\r\n\tbinary[0] |= ss << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n/** \r\n * Move from special instruction class. \r\n * @category MoveFromSpecial\r\n */\r\nclass Mfs {\r\n\t/**\r\n     * Create Mfs instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rd   - Destination register\r\n\t * @param {string}\t\t\tfields.ss\t- Special source register\r\n     */\r\n\tconstructor({pred, rd, ss}) {\r\n\t\tthis.name = \"mfs\";\r\n\t\tthis.pred = pred;\r\n\t\tthis.rd = rd;\r\n\t\tthis.ss = ss;\r\n\t\tthis.binary = compile_reg(pred, rd, ss);\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.rd] = reg[this.ss];\r\n\t}\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.rd} = ${this.ss}`;\r\n\t}\r\n}\r\n\r\nexport default Mfs;\r\n","import { parseNum, parseReg } from \"../../Helpers/misc\";\r\n\r\nconst compile_reg = (pred, rs1, sd) => {\r\n\tlet binary = [0];\r\n\r\n\tpred = parseNum(pred);\r\n\trs1 = parseReg(rs1);\r\n\tsd = parseReg(sd); \r\n\r\n\tbinary[0] |= pred << 27;\r\n\tbinary[0] |= 0b01001 << 22;\r\n\tbinary[0] |= rs1 << 12;\r\n\tbinary[0] |= 0b010 << 4;\r\n\tbinary[0] |= sd << 0;\r\n\r\n\treturn binary;\r\n};\r\n\r\n/** \r\n * Move to special instruction class. \r\n * @category MoveToSpecial\r\n */\r\nclass Mts {\r\n\t/**\r\n     * Create Mts instruction.\r\n     * @param {Object}          fields      - Fields to set\r\n     * @param {string|number}   fields.pred - Predicate\r\n     * @param {string}          fields.rs1  - Source register\r\n     * @param {string}          fields.sd   - Special destination register\r\n     */\r\n\tconstructor({pred, rs1, sd}) {\r\n\t\tthis.name = \"mts\";\r\n\t\tthis.pred = pred;\r\n\t\tthis.rs1 = rs1;\r\n\t\tthis.sd = sd;\r\n\t\tthis.binary = compile_reg(pred, rs1, sd);\r\n\t}\r\n\r\n\t/**\r\n     * Executes the instruction\r\n     * @param {Object}                  state        - Processor state\r\n     * @param {Object.<string, number>} state.reg    - Registers\r\n     */\r\n\texecute({ reg }) {\r\n\t\treg[this.sd] = reg[this.rs1];\r\n\t\tif(this.sd === \"s0\"){\r\n\t\t\treg[this.sd] &= 0xFF;\r\n\t\t\treg[\"p0\"] = 1;\r\n\t\t\treg[\"p1\"] = reg[\"s0\"] >> 1;\r\n\t\t\treg[\"p2\"] = reg[\"s0\"] >> 2;\r\n\t\t\treg[\"p3\"] = reg[\"s0\"] >> 3;\r\n\t\t\treg[\"p4\"] = reg[\"s0\"] >> 4;\r\n\t\t\treg[\"p5\"] = reg[\"s0\"] >> 5;\r\n\t\t\treg[\"p6\"] = reg[\"s0\"] >> 6;\r\n\t\t\treg[\"p7\"] = reg[\"s0\"] >> 7;\r\n\t\t}\r\n\t}\r\n\ttoString(){\r\n\t\treturn `${this.pred ? `(${this.pred&0b1000 ? \"!\" : \"\"}p${this.pred&0b0111}) ` : \"\"}${this.name} ${this.sd} = ${this.rs1}`;\r\n\t}\r\n}\r\n\r\nexport default Mts;\r\n","import { getInstType } from \"./typeStrings\";\r\n\r\n// All instruction regular expressions\r\nconst regEx = {\r\n\t// Label, pred, type\r\n\t\"first\" : [/^(?!#)(?:(\\w+):\\s*)?(?:\\((!?)(p\\d)\\)\\s+)?(\\w+)\\s*/i,\t\t\t\t\t\t\"label: (ps) type\"],\r\n\r\n\t// Normal instructions (new)\r\n\t\"bin\" \t: [/^(r\\d{1,2})\\s*=\\s*(r\\d{1,2})\\s*,\\s*\\(?([^()\\s]+)\\)?$/i, \t\t\t\t\t\t\t\t\"rd = rs1, op2\"],\r\n\t\"comp\"\t: [/^(p\\d)\\s*=\\s*(r\\d{1,2})\\s*,\\s*(r?(?:0x)?(?:0b)?\\d+)$/i,\t\t\t\t\t\t\"pd = rs1, op2\"],\r\n\t\"load\"\t: [/^(r\\d{1,2})\\s*=\\s*\\[(r\\d{1,2})\\s*\\+\\s*(\\w+)\\]$/i,  \t\t\t\t\t\t\t\"rd = [rs + imm]\"],\r\n\t\"store\"\t: [/^\\[(r\\d{1,2})\\s*\\+\\s*((?:0x)?(?:0b)?\\d+)\\]\\s*=\\s*(r\\d{1,2})$/i,\t\t\t\t\"[rd + imm] = rs\"],\r\n\t\"mul\"\t: [/^(r\\d{1,2})\\s*,\\s*(r\\d{1,2})$/i,\t\t\t\t\t\t\t\t\t\t\t\"rs1, rs2\"],\r\n\t\"stack\"\t: [/^(r?(?:0x)?(?:0b)?\\d+)\\s?$/i,\t\t\t\t\t\t\t\t\t\t\t\t\"op2\"],\r\n\t\"pred\"\t: [/^(p\\d)\\s*=\\s*(!?p\\d)\\s*,\\s*(!?p\\d)$/i,\t\t\t\t\t\t\t\t\t\t\"pd = ps1, ps2\"],\r\n\t\"cf\"\t: [/^\\s*(-?\\w*),?\\s*(\\w*)$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"label\"],\r\n\t\"mts\"\t: [/^(sro|srb|sxo|sxb|sl|sh|ss|st|s\\d{1,2})\\s*=\\s*(r\\d{1,2})$/i,\t\t\t\t\"sd = rs\"],\r\n\t\"mfs\"\t: [/^(r\\d{1,2})\\s*=\\s*(sro|srb|sxo|sxb|sl|sh|ss|st|s\\d{1,2})$/i,\t\t\t\t\"rd = ss\"],\t\t\r\n\t\"bcopy\"\t: [/^(r\\d{1,2})\\s*=\\s*(r\\d{1,2}),\\s*((?:0x)?(?:0b)?\\d+),\\s*(!?p\\d)$/i,\t\"rd = rs, imm, [!]ps\"],\r\n\r\n\t// Pseudo instructions\r\n\t\"p1\"\t: [/^([rp]\\d{1,2})\\s*=\\s*([rp]\\d{1,2})$/i, \t\t\t\t\t\t\t\t\t\t\"mov, isodd, pmov\"],\r\n\t\"mov\"\t: [/ /i, \"\"],\r\n\t\"pmov\"\t: [/ /i, \"\"],\r\n\t\"isodd\"\t: [/^(p\\d)\\s*=\\s*(r\\d{1,2})$/i, \t\t\t\t\t\t\t\t\t\t\t\t\"pd = rd\"],\r\n\t\"clr\"\t: [/^([rp]\\d{1,2})$/i, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rd/pd\"],\r\n\t\"neg\"\t: [/^(r\\d{1,2})\\s*=\\s*-\\s*(r\\d{1,2})$/i,\t\t\t\t\t\t\t\t\t\t\"rd = -rs\"],\r\n\t\"not\"\t: [/^(r\\d{1,2})\\s*=\\s*!\\s*(r\\d{1,2})$/i,\t\t\t\t\t\t\t\t\t\t\"rd = !rs\"],\r\n\t\"li\"\t: [/^(r\\d{1,2})\\s*=\\s*(\\(?([^()\\s]+)\\)?)$/i,\t\t\t\t\t\t\t\t\t\"rd = imm\"],\r\n\t\"nop\" \t: [/^\\s*$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"nop\"],\r\n\t\"pset\"\t: [/^(p\\d)\\s*=\\s*1$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = 1\"],\r\n\t\"pnot\"\t: [/^(p\\d)\\s*=\\s*!\\s*(p\\d)$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = !ps\"],\r\n\t\"pclr\"\t: [/^(p\\d)\\s*=\\s*(0)$/i,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"pd = 0\"],\r\n};\r\n\r\n/**\r\n * Gets regular expression from type\r\n * @param {string} \ttype  - Instruction type\r\n * @returns a regular expression\r\n */\r\nconst getRegEx = (type) => {\r\n\tif (regEx[getInstType(type)] === undefined) {return -1; }\r\n\treturn regEx[getInstType(type)][0];\r\n};\r\n\r\nconst getRegExError = (type) => {\r\n\tif (regEx[getInstType(type)] === undefined) {return -1; }\r\n\treturn `Instruction ${type} should be on form: ${regEx[getInstType(type)][1]}`;\r\n};\r\n\r\nexport { getRegEx, getRegExError };\r\n","import { Add, Sub, Xor, Nor, ShiftLeft, ShiftRight, Or, And, ShiftRightArithmetic, ShiftAdd, ShiftAdd2 } from \"../Instructions/Binary Arithmetics/index\";\r\nimport { Btest, Cmpeq, Cmple, Cmplt, Cmpneq, Cmpule, Cmpult } from \"../Instructions/Compare/index\";\r\nimport { Br, Brcf, Brcfnd, Brnd, Call, Callnd, Ret, Retnd, Trap, Xret, Xretnd } from \"../Instructions/Control Flow/index\";\r\nimport { Lws, Lwl, Lwc, Lwm, Lhs, Lhl, Lhc, Lhm, Lbs, Lbl, Lbc, Lbm, Lhus, Lhul, Lhuc, Lhum, Lbus, Lbul, Lbuc, Lbum } from \"../Instructions/Load Typed/index\";\r\nimport { Mul, Mulu } from \"../Instructions/Multiply/index\";\r\nimport { Pand, Pxor, Por } from \"../Instructions/Predicate/index\";\r\nimport { Sens, Sfree, Sres, Sspill } from \"../Instructions/Stack Control/index\";\r\nimport { Sbc, Sbl, Sbm, Sbs, Shc, Shl, Shm, Shs, Swc, Swl, Swm, Sws } from \"../Instructions/Store Typed/index\";\r\nimport Bcopy from \"../Instructions/Bcopy\";\r\nimport Mfs from \"../Instructions/Mfs\";\r\nimport Mts from \"../Instructions/Mts\";\r\nimport { instTypes, binTypes, allowedPipelineTwo, pseudoTypes, pseudoMapping, cfTypes, loadTypes } from \"../../Helpers/typeStrings\";\r\nimport { regStr, allRegStr, sregMap } from \"../../Helpers/regStrings\";\r\nimport { getRegEx, getRegExError } from \"../../Helpers/regEx\";\r\n\r\nclass Assembler {\r\n\tconstructor() {\r\n\t\tthis.bundles = [];\r\n\t\tthis.labels = {};\r\n\t\tthis.offset = 0;\r\n\t\tthis.error = [];\r\n\t\tthis.numMap = [];\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.bundles = [];\r\n\t\tthis.labels = {};\r\n\t\tthis.offset = 0;\r\n\t\tthis.error = [];\r\n\t\tthis.numMap = [];\r\n\t}\r\n\r\n\t// should add debouncing :)\r\n\trun(editor) {\r\n\t\tthis.reset();\r\n\t\tlet input = this.cleanInput(editor);\r\n\t\tfor (let line of input)\r\n\t\t\tthis.parse(line);\r\n\t\tfor (let bundle of this.bundles) {\r\n\t\t\tif(this.resolveOperands(bundle))\r\n\t\t\t\tthis.compileBundle(bundle);\r\n\t\t}\r\n\t\treturn this.checkErr();\r\n\t}\r\n\r\n\t// if no errors, erase error array\r\n\tcheckErr() {\r\n\t\tfor (let key in this.error)\r\n\t\t\tif (this.error[key] !== \"fine\") return false;\r\n\t\tthis.error = [];\r\n\t\treturn true;\r\n\t}\r\n\r\n\tparse(line) {\r\n\t\tif(/^\\s*$/i.test(line)) return true;\r\n\t\tlet insts = line.split(\"||\");\r\n\t\tlet bundle = { is_data: false, data: null, offset: this.offset, instructions: [], size: 0 };\r\n\t\tlet idx = this.bundles.push(bundle) - 1;\r\n\t\t\r\n\t\t/* Perhaps change to is_data and and different regex for .word, .string etc. */\r\n\t\t//Figure out how to handle base and pc when a .word n+4 is injected into the asm as that indicates a code block that is n bytes...\r\n\t\tlet is_word = line.match(/^(?:(\\w+):)?(?:\\s+)?\\.word\\s+([^\\s]+)$/i);\r\n\t\tif(is_word) {\r\n\t\t\tbundle.is_data = true;\r\n\t\t\tbundle.data = {type: \"word\", value: is_word[2]};\r\n\t\t\tif(is_word[1]) this.labels[is_word[1]] = idx;\r\n\t\t\tthis.offset += 4;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\r\n\t\tif (insts.length > 2) {\r\n\t\t\tthis.error[idx] = \"Only two instructions per bundle allowed!\";\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\t\r\n\t\tfor (let j in insts) {\r\n\t\t\tlet inst = insts[j];\r\n\t\t\tinst = inst.trim();\r\n\t\t\t\r\n\t\t\t// Get instruction match\r\n\t\t\tlet match = inst.match(getRegEx(\"first\"));\r\n\t\t\tif (!match) { \r\n\t\t\t\tthis.error[idx] = getRegExError(\"first\"); \r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\t\t\tlet label = match[1];\r\n\t\t\tlet neg = match[2] === \"!\";\r\n\t\t\tlet pred = match[3] ? Number(match[3].toLowerCase().replace(\"p\", \"\")) : 0;\r\n\t\t\tlet type = match[4].toLowerCase();\r\n\t\t\tif (type === \"halt\") type = \"nop\";\r\n\t\t\tmatch = inst.replace(match[0], \"\").match(getRegEx(type));\r\n\t\t\t\r\n\t\t\t// Check if inst is a proper instruction\r\n\t\t\tif (!instTypes.includes(type)) {\r\n\t\t\t\tthis.error[idx] = `${type} is not an instruction`;\r\n\t\t\t\treturn false; \r\n\t\t\t} else if (!match){\r\n\t\t\t\tthis.error[idx] = getRegExError(type); \r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\r\n\t\t\t// Re-write pseudo instruction into its corresponding instruction\r\n\t\t\tif (pseudoTypes.includes(type)) {\r\n\t\t\t\tlet ptype = type.toUpperCase();\r\n\t\t\t\tswitch (ptype) {\r\n\t\t\t\t\tcase \"LI\":\r\n\t\t\t\t\t\tif (Number(match[2] < 0)) {\r\n\t\t\t\t\t\t\tptype = \"LI_NEG\";\r\n\t\t\t\t\t\t\tmatch[2] = -match[2];\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tptype = \"LI_POS\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"MOV\":\r\n\t\t\t\t\t\tptype += (regStr.includes(match[1])) ? \"_R\" : \"_P\";\r\n\t\t\t\t\t\tptype += (regStr.includes(match[2])) ? \"R\" : \"P\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: break;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Get the original instruction and get its match\r\n\t\t\t\tlet basic = pseudoMapping[ptype].replace(/{(\\d+)}/g, (_, n) => match[n]);\r\n\t\t\t\tmatch = basic.match(getRegEx(\"first\"));\r\n\t\t\t\ttype = match[4].toLowerCase();\r\n\t\t\t\tmatch = basic.replace(match[0], \"\").match(getRegEx(type));\r\n\t\t\t}\r\n\r\n\t\t\t// Define the instruction\r\n\t\t\tlet i = { pred: { p: pred, n: neg }, type, ops: match.slice(1), original: inst.replace(/\\s+/gi, \" \") };\r\n\t\t\tlet is_long_imm = (binTypes.includes(type) && Number(i.ops[2]) && ((Number(i.ops[2]) > 0xFFF) || [\"nor\", \"shadd\", \"shadd2\"].includes(type)));\r\n\t\t\t\r\n\t\t\t// Check if pipelined/bundled correctly\r\n\t\t\tif (insts.length === 2) {\r\n\t\t\t\tif (is_long_imm) {\r\n\t\t\t\t\tthis.error[idx] = \"Can't bundle a 64-bit instruction with anything else\";\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} else if (j === 1 && !allowedPipelineTwo(type)) {\r\n\t\t\t\t\tthis.error[idx] = `${type} can't run in pipeline two.`;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (label) this.labels[label] = idx;\r\n\t\t\tbundle.instructions.push(i);\r\n\t\t\tbundle[\"size\"] += is_long_imm ? 8 : 4;\r\n\t\t}\r\n\t\tthis.offset += bundle[\"size\"];\r\n\t\treturn true;\r\n\t}\r\n\r\n\tresolveOperands(bundle) {\r\n\t\tlet idx = bundle.offset/4;\r\n\r\n\t\tif(bundle.is_data){\r\n\t\t\tlet multi = bundle.data.value.match(/^(\\S+)([+-])(\\S+)$/i);\r\n\t\t\t\r\n\t\t\tif (Object.keys(this.labels).includes(bundle.data.value)){\r\n\t\t\t\tbundle.data.value = this.bundles[this.labels[bundle.data.value]].offset;\r\n\t\t\t}else if(multi && Object.keys(this.labels).includes(multi[1]) && Object.keys(this.labels).includes(multi[3])){\r\n\t\t\t\tlet t1 = this.bundles[this.labels[multi[1]]].offset;\r\n\t\t\t\tlet t2 = this.bundles[this.labels[multi[3]]].offset;\r\n\t\t\t\tbundle.data.value = multi[2] === \"+\" ? t1 + t2: t1 - t2 ;\r\n\t\t\t} else {\r\n\t\t\t\tbundle.data.value = Number(bundle.data.value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let instruction of bundle.instructions) {\r\n\t\t\tfor (let i in instruction.ops) {\r\n\t\t\t\tlet op = instruction.ops[i];\r\n\t\t\t\tlet op_lc = op.toLowerCase();\r\n\t\t\t\tlet multi = op.match(/^(\\S+)([+-])(\\S+)$/i);\r\n\t\t\t\tif (sregMap[op_lc]) {\r\n\t\t\t\t\tinstruction.ops[i] = sregMap[op_lc];\r\n\t\t\t\t} else if (allRegStr.includes(op_lc)) {\r\n\t\t\t\t\tinstruction.ops[i] = op_lc;\r\n\t\t\t\t} else if (Object.keys(this.labels).includes(op) || (multi && Object.keys(this.labels).includes(multi[1]) && Object.keys(this.labels).includes(multi[3]))) {\r\n\t\t\t\t\tlet target;\r\n\t\t\t\t\tif(multi){\r\n\t\t\t\t\t\tlet t1 = this.bundles[this.labels[multi[1]]].offset;\r\n\t\t\t\t\t\tlet t2 = this.bundles[this.labels[multi[3]]].offset;\r\n\t\t\t\t\t\ttarget = multi[2] === \"+\" ? t1 + t2: t1 - t2 ;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget = this.bundles[this.labels[op]].offset;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(cfTypes.includes(instruction.type)){\r\n\t\t\t\t\t\tif([\"br\", \"brnd\"].includes(instruction.type)){\r\n\t\t\t\t\t\t\tinstruction.ops[i] = String((target-bundle.offset) >> 2);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tinstruction.ops[i] = String(target >> 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if(loadTypes.includes(instruction.type)){\r\n\t\t\t\t\t\tlet shift = 0;\r\n\t\t\t\t\t\tif(instruction.type.includes(\"w\"))\r\n\t\t\t\t\t\t\tshift = 2;\r\n\t\t\t\t\t\telse if(instruction.type.includes(\"h\"))\r\n\t\t\t\t\t\t\tshift = 1;\r\n\t\t\t\t\t\tinstruction.ops[i] = String(target >> shift);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tinstruction.ops[i] = String(target);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (isNaN(op)) {\r\n\t\t\t\t\tthis.error[idx] = \"Can't resolve operands\";\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes empty lines and comments\r\n\t * @param \t{string} \teditor \t\t- User input editor \r\n\t * @returns {array}\t\toutput\t\t- Array of lines that are not empty or comments\r\n\t */\r\n\tcleanInput = (editor) => {\r\n\t\tlet lines = editor.replace(/~/gi, \"!\").split(/(?:\\r?\\n)/);\r\n\t\tlet output = [];\r\n\t\tfor (let i = 0; i < lines.length; ++i) {\r\n\t\t\tlet line = lines[i].split(\"#\", 1)[0].trim(); // Remove comments\r\n\t\t\tlet insts = line.split(\";\");\r\n\t\t\tfor (let j = 0; j < insts.length; ++j){\r\n\t\t\t\tlet only_label = insts[j].match(/^\\w+:$/);\r\n\t\t\t\tif (line) {\r\n\t\t\t\t\tif (only_label && i + 1 < lines.length) {\r\n\t\t\t\t\t\tlines[i + 1] = only_label[0] + \" \" + lines[i + 1];\r\n\t\t\t\t\t} else if (!only_label && insts[j]) {\r\n\t\t\t\t\t\toutput.push(insts[j]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.numMap[output.length-1] = i+1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn output;\r\n\t};\r\n\t\r\n\t/**\r\n\t * compileBundle creates a new instance of an instruction class for every instruction in\r\n\t * the input bundle (one or two instructions). Also sets the binary field of the Object\r\n\t * @param {*} bundle - One or two instructions.\r\n\t */\r\n\tcompileBundle(bundle) {\r\n\t\tfor (let i in bundle.instructions) {\r\n\t\t\tlet cInst;\r\n\t\t\tlet { pred, type, ops } = bundle.instructions[i];\r\n\t\t\tlet predicate = pred.p | (pred.n << 3);\r\n\r\n\t\t\tlet BinaryInst \t= { pred: predicate, rd:  ops[0], rs1: ops[1], op2: ops[2] };\r\n\t\t\tlet CompareInst = { pred: predicate, pd:  ops[0], rs1: ops[1], op2: ops[2] };\r\n\t\t\tlet ControlInst = { pred: predicate, s1:  ops[0], s2 : ops[1] };\r\n\t\t\tlet LoadInst \t= { pred: predicate, rd:  ops[0], ra:  ops[1], imm: ops[2] };\r\n\t\t\tlet MulInst \t= { pred: predicate, rs1: ops[0], rs2: ops[1] };\r\n\t\t\tlet PredInst \t= { pred: predicate, pd:  ops[0], ps1: ops[1], ps2: ops[2] };\r\n\t\t\tlet StackInst \t= { pred: predicate, s1:  ops[0] };\r\n\t\t\tlet StoreInst \t= { pred: predicate, ra:  ops[0], imm: ops[1], rs:  ops[2] };\r\n\t\t\tlet BcopyInst \t= { pred: predicate, rd:  ops[0], rs1: ops[1], imm: ops[2], ps: ops[3] };\r\n\r\n\t\t\t// Pick inst from its name/type\r\n\t\t\tswitch (type) {\r\n\t\t\t\t// BinaryArithmetics\r\n\t\t\t\tcase \"add\":\r\n\t\t\t\tcase \"addi\":\r\n\t\t\t\tcase \"addl\":\r\n\t\t\t\t\tcInst = new Add(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sub\":\r\n\t\t\t\tcase \"subi\":\r\n\t\t\t\tcase \"subl\":\r\n\t\t\t\t\tcInst = new Sub(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"or\":\r\n\t\t\t\tcase \"ori\":\r\n\t\t\t\tcase \"orl\":\r\n\t\t\t\t\tcInst = new Or(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"and\":\r\n\t\t\t\tcase \"andi\":\r\n\t\t\t\tcase \"andl\":\r\n\t\t\t\t\tcInst = new And(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"xor\":\r\n\t\t\t\tcase \"xori\":\r\n\t\t\t\tcase \"xorl\":\r\n\t\t\t\t\tcInst = new Xor(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"nor\":\r\n\t\t\t\tcase \"norl\":\r\n\t\t\t\t\tcInst = new Nor(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sl\":\r\n\t\t\t\tcase \"sli\":\r\n\t\t\t\tcase \"sll\":\r\n\t\t\t\t\tcInst = new ShiftLeft(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sr\":\r\n\t\t\t\tcase \"sri\":\r\n\t\t\t\tcase \"srl\":\r\n\t\t\t\t\tcInst = new ShiftRight(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sra\":\r\n\t\t\t\tcase \"srai\":\r\n\t\t\t\tcase \"sral\":\r\n\t\t\t\t\tcInst = new ShiftRightArithmetic(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shadd\":\r\n\t\t\t\t\tcInst = new ShiftAdd(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shadd2\":\r\n\t\t\t\t\tcInst = new ShiftAdd2(BinaryInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Compare\r\n\t\t\t\tcase \"btest\":\r\n\t\t\t\tcase \"btesti\":\r\n\t\t\t\t\tcInst = new Btest(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmpeq\":\r\n\t\t\t\tcase \"cmpieq\":\r\n\t\t\t\t\tcInst = new Cmpeq(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmple\":\r\n\t\t\t\tcase \"cmpile\":\r\n\t\t\t\t\tcInst = new Cmple(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmplt\":\r\n\t\t\t\tcase \"cmpilt\":\r\n\t\t\t\t\tcInst = new Cmplt(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmpneq\":\r\n\t\t\t\tcase \"cmpineq\":\r\n\t\t\t\t\tcInst = new Cmpneq(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmpule\":\r\n\t\t\t\tcase \"cmpiule\":\r\n\t\t\t\t\tcInst = new Cmpule(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"cmpult\":\r\n\t\t\t\tcase \"cmpiult\":\r\n\t\t\t\t\tcInst = new Cmpult(CompareInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// LoadType \r\n\t\t\t\tcase \"lbc\":\r\n\t\t\t\t\tcInst = new Lbc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbl\":\r\n\t\t\t\t\tcInst = new Lbl(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbm\":\r\n\t\t\t\t\tcInst = new Lbm(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbs\":\r\n\t\t\t\t\tcInst = new Lbs(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbuc\":\r\n\t\t\t\t\tcInst = new Lbuc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbul\":\r\n\t\t\t\t\tcInst = new Lbul(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbum\":\r\n\t\t\t\t\tcInst = new Lbum(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lbus\":\r\n\t\t\t\t\tcInst = new Lbus(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhc\":\r\n\t\t\t\t\tcInst = new Lhc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhl\":\r\n\t\t\t\t\tcInst = new Lhl(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhm\":\r\n\t\t\t\t\tcInst = new Lhm(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhs\":\r\n\t\t\t\t\tcInst = new Lhs(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhuc\":\r\n\t\t\t\t\tcInst = new Lhuc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhul\":\r\n\t\t\t\t\tcInst = new Lhul(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhum\":\r\n\t\t\t\t\tcInst = new Lhum(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lhus\":\r\n\t\t\t\t\tcInst = new Lhus(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lwc\":\r\n\t\t\t\t\tcInst = new Lwc(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lwl\":\r\n\t\t\t\t\tcInst = new Lwl(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lwm\":\r\n\t\t\t\t\tcInst = new Lwm(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"lws\":\r\n\t\t\t\t\tcInst = new Lws(LoadInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Multiply \r\n\t\t\t\tcase \"mul\":\r\n\t\t\t\t\tcInst = new Mul(MulInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"mulu\":\r\n\t\t\t\t\tcInst = new Mulu(MulInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Predicate\r\n\t\t\t\tcase \"pand\":\r\n\t\t\t\t\tcInst = new Pand(PredInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"por\":\r\n\t\t\t\t\tcInst = new Por(PredInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"pxor\":\r\n\t\t\t\t\tcInst = new Pxor(PredInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// StoreTyped\r\n\t\t\t\tcase \"sbc\":\r\n\t\t\t\t\tcInst = new Sbc(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sbl\":\r\n\t\t\t\t\tcInst = new Sbl(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sbm\":\r\n\t\t\t\t\tcInst = new Sbm(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sbs\":\r\n\t\t\t\t\tcInst = new Sbs(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shc\":\r\n\t\t\t\t\tcInst = new Shc(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shl\":\r\n\t\t\t\t\tcInst = new Shl(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shm\":\r\n\t\t\t\t\tcInst = new Shm(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"shs\":\r\n\t\t\t\t\tcInst = new Shs(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"swc\":\r\n\t\t\t\t\tcInst = new Swc(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"swl\":\r\n\t\t\t\t\tcInst = new Swl(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"swm\":\r\n\t\t\t\t\tcInst = new Swm(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sws\":\r\n\t\t\t\t\tcInst = new Sws(StoreInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Stack Control\r\n\t\t\t\tcase \"sens\":\r\n\t\t\t\tcase \"sensr\":\r\n\t\t\t\t\tcInst = new Sens(StackInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sfree\":\r\n\t\t\t\t\tcInst = new Sfree(StackInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sres\":\r\n\t\t\t\t\tcInst = new Sres(StackInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"sspill\":\r\n\t\t\t\tcase \"sspillr\":\r\n\t\t\t\t\tcInst = new Sspill(StackInst);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Control Flow \r\n\t\t\t\tcase \"br\":\r\n\t\t\t\tcase \"brr\":\r\n\t\t\t\t\tcInst = new Br(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"brcf\":\r\n\t\t\t\tcase \"brcfr\":\r\n\t\t\t\t\tcInst = new Brcf(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"brcfnd\":\r\n\t\t\t\tcase \"brcfndr\":\r\n\t\t\t\t\tcInst = new Brcfnd(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"brnd\":\r\n\t\t\t\tcase \"brndr\":\r\n\t\t\t\t\tcInst = new Brnd(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"call\":\r\n\t\t\t\tcase \"callr\":\r\n\t\t\t\t\tcInst = new Call(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"callnd\":\r\n\t\t\t\tcase \"callndr\":\r\n\t\t\t\t\tcInst = new Callnd(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"ret\":\r\n\t\t\t\t\tcInst = new Ret(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"retnd\":\r\n\t\t\t\t\tcInst = new Retnd(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"trap\":\r\n\t\t\t\t\tcInst = new Trap(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"xret\":\r\n\t\t\t\t\tcInst = new Xret(ControlInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"xretnd\":\r\n\t\t\t\t\tcInst = new Xretnd(ControlInst);\r\n\t\t\t\t\tbreak; \r\n\r\n\t\t\t\t// Rest\r\n\t\t\t\tcase \"bcopy\":\r\n\t\t\t\t\tcInst = new Bcopy(BcopyInst);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"mfs\":\r\n\t\t\t\t\tcInst = new Mfs({ pred: pred.p | (pred.n << 3), rd: ops[0], ss: ops[1] });\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"mts\":\r\n\t\t\t\t\tcInst = new Mts({ pred: pred.p | (pred.n << 3), rs1: ops[1], sd: ops[0] });\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Not implemented\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tconsole.log(`Instruction ${type} not implemented.`);\r\n\t\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\tif (bundle.instructions[i].original === \"halt\") {\r\n\t\t\t\tcInst.binary[0] = 0x05400000;\r\n\t\t\t\tcInst.toString = () => {return \"\"; };\r\n\t\t\t}\r\n\t\t\tif (Number(i) === 0 && bundle.instructions.length === 2) {\r\n\t\t\t\tcInst.binary[0] |= 1 << 31;\r\n\t\t\t}\r\n\t\t\tbundle.instructions[i].instruction = cInst;\r\n\r\n\t\t\tlet idx = bundle.offset/4;\r\n\t\t\tif (!this.error[idx]) this.error[idx] = \"fine\";\r\n\t\t}\r\n\t}\r\n}\r\nexport default Assembler;\r\n","import React, { Component } from \"react\";\r\nimport FrontEnd from \"./Front End/FrontEnd\";\r\nimport CPU from \"./Work Logic/Processor/CPU\";\r\nimport Assembler from \"./Work Logic/Processor/Assembler\";\r\nimport \"./CSS/App.css\";\r\n\r\nclass App extends Component {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.cpu = new CPU();\r\n\t\tthis.a = new Assembler();\r\n\t}\r\n\r\n\t/**\r\n\t * Handles code editor updates.\r\n\t * Resets CPU and runs assembler to generate instruction que and labels.\r\n\t * @param {string} \teditor \t- User input instructions\r\n\t */\r\n\teditorUpdate = (editor) => {\r\n\t\tconsole.clear();\r\n\t\tconsole.log(\"Run Assembler\");\r\n\t\tif (this.a.run(editor)) {\r\n\t\t\tconsole.log(\"Assembler ran successfully\");\r\n\t\t\tthis.cpu.populate(this.a.bundles);\r\n\t\t}\r\n\t\tthis.forceUpdate();\r\n\t}\r\n\r\n\t/**\r\n\t * Step one instruction, if any left to execute\r\n\t * @field que : All instructions\r\n\t * @field queLength: Amount of instructions\r\n\t */\r\n\tstepBtn = () => {\r\n\t\tthis.cpu.step();\r\n\t\tthis.forceUpdate(); // To re-render\r\n\t}\r\n\r\n\t/**\r\n\t * Run button pressed. Runs remaining instructions.\r\n\t */\r\n\trunBtn = () => {\r\n\t\tthis.cpu.run();\r\n\t\tthis.forceUpdate(); // To re-render\r\n\t}\r\n\r\n\t/**\r\n\t * Reset button pressed. Resets program execution:\r\n\t * Sets pc = 0, resets mem and registers and goes to first bundle\r\n\t */\r\n\tresetBtn = () => {\r\n\t\tthis.cpu.populate(this.a.bundles);\r\n\t\tthis.forceUpdate(); // To re-render\r\n\t}\r\n\r\n\t/**\r\n\t * Prev button pressed. Reverts the execution of the last bundle executed.\r\n\t */\r\n\tprevBtn = () => {\r\n\t\tthis.cpu.prev();\r\n\t\tthis.forceUpdate(); // To re-render\r\n\t}\r\n\r\n\t/**\r\n\t * Dump button pressed. Saves the binary stream to a file.\r\n\t */\r\n\tdumpBtn = () => {\r\n\t\tlet mem = this.cpu.getMem();\r\n\t\tlet dump = new Uint8Array(mem[\"TEXT_END\"]);\r\n\t\t\r\n\t\tfor (let i = 0; i < mem[\"TEXT_END\"]; i += 4) {\r\n\t\t\tdump[i] = mem[i];\r\n\t\t\tdump[i+1] = mem[i+1];\r\n\t\t\tdump[i+2] = mem[i+2];\r\n\t\t\tdump[i+3] = mem[i+3];\t\r\n\t\t}\r\n\r\n\t\tlet file = new Blob([dump], {type: \"application/octet-stream\"});\r\n\t\tlet a = document.createElement(\"a\"), url = URL.createObjectURL(file);\r\n\t\ta.href = url;\r\n\t\ta.download = \"chora.o\";\r\n\t\tdocument.body.appendChild(a);\r\n\t\ta.click();\r\n\t\tsetTimeout(function() {\r\n\t\t\tdocument.body.removeChild(a);\r\n\t\t\twindow.URL.revokeObjectURL(url);  \r\n\t\t}, 0); \r\n\t\t\r\n\t}\r\n\r\n\trender() {\r\n\t\tdocument.body.style.overflowY = \"hidden\";\r\n\t\treturn (\r\n\t\t\t<div className=\"no-scroll\">\r\n\t\t\t\t<FrontEnd\r\n\t\t\t\t\tregisters={this.cpu.getReg()}\r\n\t\t\t\t\tmemory={this.cpu.getMem()}\r\n\t\t\t\t\thistory={this.cpu.state.history}\r\n\t\t\t\t\teditorUpdate={this.editorUpdate}\r\n\t\t\t\t\tstepClick={this.stepBtn}\r\n\t\t\t\t\trunClick={this.runBtn}\r\n\t\t\t\t\tprevClick={this.prevBtn}\r\n\t\t\t\t\tresetClick={this.resetBtn}\r\n\t\t\t\t\tdumpClick = {this.dumpBtn}\r\n\t\t\t\t\tpc={this.cpu.getPC()}\r\n\t\t\t\t\tbundles={this.cpu.bundles}\r\n\t\t\t\t\terror={this.a.error}\r\n\t\t\t\t\tnumMap={this.a.numMap}\r\n\t\t\t\t/>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\"; \r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}